// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EXTENSIONRULESET_EXTENSIONS_DECLARATIVE_NET_REQUEST_FLAT_H_
#define FLATBUFFERS_GENERATED_EXTENSIONRULESET_EXTENSIONS_DECLARATIVE_NET_REQUEST_FLAT_H_

#include "flatbuffers/flatbuffers.h"

#include "components/url_pattern_index/flat/url_pattern_index_generated.h"

namespace extensions {
namespace declarative_net_request {
namespace flat {

struct UrlRuleMetadata;

struct ExtensionIndexedRuleset;

/// Additional extension related metadata for a url_pattern_index UrlRule.
struct UrlRuleMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_REDIRECT_URL = 6
  };
  /// ID of the UrlRule for which this metadata is stored.
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool KeyCompareLessThan(const UrlRuleMetadata *o) const {
    return id() < o->id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  /// Redirect url for this rule. Should represent a valid GURL.
  const flatbuffers::String *redirect_url() const {
    return GetPointer<const flatbuffers::String *>(VT_REDIRECT_URL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_REDIRECT_URL) &&
           verifier.Verify(redirect_url()) &&
           verifier.EndTable();
  }
};

struct UrlRuleMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(UrlRuleMetadata::VT_ID, id, 0);
  }
  void add_redirect_url(flatbuffers::Offset<flatbuffers::String> redirect_url) {
    fbb_.AddOffset(UrlRuleMetadata::VT_REDIRECT_URL, redirect_url);
  }
  UrlRuleMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UrlRuleMetadataBuilder &operator=(const UrlRuleMetadataBuilder &);
  flatbuffers::Offset<UrlRuleMetadata> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<UrlRuleMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<UrlRuleMetadata> CreateUrlRuleMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> redirect_url = 0) {
  UrlRuleMetadataBuilder builder_(_fbb);
  builder_.add_redirect_url(redirect_url);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<UrlRuleMetadata> CreateUrlRuleMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *redirect_url = nullptr) {
  return extensions::declarative_net_request::flat::CreateUrlRuleMetadata(
      _fbb,
      id,
      redirect_url ? _fbb.CreateString(redirect_url) : 0);
}

/// The top-level data structure used to store extensions URL rules for the
/// Declarative Net Request API.
struct ExtensionIndexedRuleset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BLACKLIST_INDEX = 4,
    VT_WHITELIST_INDEX = 6,
    VT_REDIRECT_INDEX = 8,
    VT_EXTENSION_METADATA = 10
  };
  /// The index of all blocking URL rules.
  const url_pattern_index::flat::UrlPatternIndex *blacklist_index() const {
    return GetPointer<const url_pattern_index::flat::UrlPatternIndex *>(VT_BLACKLIST_INDEX);
  }
  /// The index of all whitelist URL rules.
  const url_pattern_index::flat::UrlPatternIndex *whitelist_index() const {
    return GetPointer<const url_pattern_index::flat::UrlPatternIndex *>(VT_WHITELIST_INDEX);
  }
  /// The index of all redirect URL rules.
  const url_pattern_index::flat::UrlPatternIndex *redirect_index() const {
    return GetPointer<const url_pattern_index::flat::UrlPatternIndex *>(VT_REDIRECT_INDEX);
  }
  /// Extension related metadata. Sorted by id, to support fast lookup.
  /// Currently this is only used for redirect rules.
  const flatbuffers::Vector<flatbuffers::Offset<UrlRuleMetadata>> *extension_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UrlRuleMetadata>> *>(VT_EXTENSION_METADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLACKLIST_INDEX) &&
           verifier.VerifyTable(blacklist_index()) &&
           VerifyOffset(verifier, VT_WHITELIST_INDEX) &&
           verifier.VerifyTable(whitelist_index()) &&
           VerifyOffset(verifier, VT_REDIRECT_INDEX) &&
           verifier.VerifyTable(redirect_index()) &&
           VerifyOffset(verifier, VT_EXTENSION_METADATA) &&
           verifier.Verify(extension_metadata()) &&
           verifier.VerifyVectorOfTables(extension_metadata()) &&
           verifier.EndTable();
  }
};

struct ExtensionIndexedRulesetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blacklist_index(flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> blacklist_index) {
    fbb_.AddOffset(ExtensionIndexedRuleset::VT_BLACKLIST_INDEX, blacklist_index);
  }
  void add_whitelist_index(flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> whitelist_index) {
    fbb_.AddOffset(ExtensionIndexedRuleset::VT_WHITELIST_INDEX, whitelist_index);
  }
  void add_redirect_index(flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> redirect_index) {
    fbb_.AddOffset(ExtensionIndexedRuleset::VT_REDIRECT_INDEX, redirect_index);
  }
  void add_extension_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRuleMetadata>>> extension_metadata) {
    fbb_.AddOffset(ExtensionIndexedRuleset::VT_EXTENSION_METADATA, extension_metadata);
  }
  ExtensionIndexedRulesetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtensionIndexedRulesetBuilder &operator=(const ExtensionIndexedRulesetBuilder &);
  flatbuffers::Offset<ExtensionIndexedRuleset> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<ExtensionIndexedRuleset>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtensionIndexedRuleset> CreateExtensionIndexedRuleset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> blacklist_index = 0,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> whitelist_index = 0,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> redirect_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRuleMetadata>>> extension_metadata = 0) {
  ExtensionIndexedRulesetBuilder builder_(_fbb);
  builder_.add_extension_metadata(extension_metadata);
  builder_.add_redirect_index(redirect_index);
  builder_.add_whitelist_index(whitelist_index);
  builder_.add_blacklist_index(blacklist_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtensionIndexedRuleset> CreateExtensionIndexedRulesetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> blacklist_index = 0,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> whitelist_index = 0,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> redirect_index = 0,
    const std::vector<flatbuffers::Offset<UrlRuleMetadata>> *extension_metadata = nullptr) {
  return extensions::declarative_net_request::flat::CreateExtensionIndexedRuleset(
      _fbb,
      blacklist_index,
      whitelist_index,
      redirect_index,
      extension_metadata ? _fbb.CreateVector<flatbuffers::Offset<UrlRuleMetadata>>(*extension_metadata) : 0);
}

inline const extensions::declarative_net_request::flat::ExtensionIndexedRuleset *GetExtensionIndexedRuleset(const void *buf) {
  return flatbuffers::GetRoot<extensions::declarative_net_request::flat::ExtensionIndexedRuleset>(buf);
}

inline const char *ExtensionIndexedRulesetIdentifier() {
  return "EXTR";
}

inline bool ExtensionIndexedRulesetBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ExtensionIndexedRulesetIdentifier());
}

inline bool VerifyExtensionIndexedRulesetBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<extensions::declarative_net_request::flat::ExtensionIndexedRuleset>(ExtensionIndexedRulesetIdentifier());
}

inline void FinishExtensionIndexedRulesetBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<extensions::declarative_net_request::flat::ExtensionIndexedRuleset> root) {
  fbb.Finish(root, ExtensionIndexedRulesetIdentifier());
}

}  // namespace flat
}  // namespace declarative_net_request
}  // namespace extensions

#endif  // FLATBUFFERS_GENERATED_EXTENSIONRULESET_EXTENSIONS_DECLARATIVE_NET_REQUEST_FLAT_H_
