// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "client_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace ipc {
namespace invalidation {
class VersionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<Version> {
} _Version_default_instance_;
class ProtocolVersionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ProtocolVersion> {
} _ProtocolVersion_default_instance_;
class ClientVersionDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ClientVersion> {
} _ClientVersion_default_instance_;
class StatusPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<StatusP> {
} _StatusP_default_instance_;
class ObjectIdPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ObjectIdP> {
} _ObjectIdP_default_instance_;
class ApplicationClientIdPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ApplicationClientIdP> {
} _ApplicationClientIdP_default_instance_;
class InvalidationPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<InvalidationP> {
} _InvalidationP_default_instance_;
class RegistrationPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationP> {
} _RegistrationP_default_instance_;
class RegistrationSummaryDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationSummary> {
} _RegistrationSummary_default_instance_;
class ClientHeaderDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ClientHeader> {
} _ClientHeader_default_instance_;
class ClientToServerMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ClientToServerMessage> {
} _ClientToServerMessage_default_instance_;
class InitializeMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<InitializeMessage> {
} _InitializeMessage_default_instance_;
class RegistrationMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationMessage> {
} _RegistrationMessage_default_instance_;
class RegistrationSyncMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationSyncMessage> {
} _RegistrationSyncMessage_default_instance_;
class RegistrationSubtreeDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationSubtree> {
} _RegistrationSubtree_default_instance_;
class InfoMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<InfoMessage> {
} _InfoMessage_default_instance_;
class PropertyRecordDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<PropertyRecord> {
} _PropertyRecord_default_instance_;
class ServerHeaderDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ServerHeader> {
} _ServerHeader_default_instance_;
class ServerToClientMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ServerToClientMessage> {
} _ServerToClientMessage_default_instance_;
class TokenControlMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<TokenControlMessage> {
} _TokenControlMessage_default_instance_;
class RegistrationStatusDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationStatus> {
} _RegistrationStatus_default_instance_;
class RegistrationStatusMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationStatusMessage> {
} _RegistrationStatusMessage_default_instance_;
class RegistrationSyncRequestMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RegistrationSyncRequestMessage> {
} _RegistrationSyncRequestMessage_default_instance_;
class InvalidationMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<InvalidationMessage> {
} _InvalidationMessage_default_instance_;
class InfoRequestMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<InfoRequestMessage> {
} _InfoRequestMessage_default_instance_;
class RateLimitPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<RateLimitP> {
} _RateLimitP_default_instance_;
class ProtocolHandlerConfigPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ProtocolHandlerConfigP> {
} _ProtocolHandlerConfigP_default_instance_;
class ClientConfigPDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ClientConfigP> {
} _ClientConfigP_default_instance_;
class ConfigChangeMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ConfigChangeMessage> {
} _ConfigChangeMessage_default_instance_;
class ErrorMessageDefaultTypeInternal : public ::google::protobuf::internal::ExplicitlyConstructed<ErrorMessage> {
} _ErrorMessage_default_instance_;

namespace protobuf_client_5fprotocol_2eproto {

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTableField
    const TableStruct::entries[] = {
  {0, 0, 0, ::google::protobuf::internal::kInvalidMask, 0, 0},
};

PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::AuxillaryParseTableField
    const TableStruct::aux[] = {
  ::google::protobuf::internal::AuxillaryParseTableField(),
};
PROTOBUF_CONSTEXPR_VAR ::google::protobuf::internal::ParseTable const
    TableStruct::schema[] = {
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
  { NULL, NULL, 0, -1, -1, false },
};


void TableStruct::Shutdown() {
  _Version_default_instance_.Shutdown();
  _ProtocolVersion_default_instance_.Shutdown();
  _ClientVersion_default_instance_.Shutdown();
  _StatusP_default_instance_.Shutdown();
  _ObjectIdP_default_instance_.Shutdown();
  _ApplicationClientIdP_default_instance_.Shutdown();
  _InvalidationP_default_instance_.Shutdown();
  _RegistrationP_default_instance_.Shutdown();
  _RegistrationSummary_default_instance_.Shutdown();
  _ClientHeader_default_instance_.Shutdown();
  _ClientToServerMessage_default_instance_.Shutdown();
  _InitializeMessage_default_instance_.Shutdown();
  _RegistrationMessage_default_instance_.Shutdown();
  _RegistrationSyncMessage_default_instance_.Shutdown();
  _RegistrationSubtree_default_instance_.Shutdown();
  _InfoMessage_default_instance_.Shutdown();
  _PropertyRecord_default_instance_.Shutdown();
  _ServerHeader_default_instance_.Shutdown();
  _ServerToClientMessage_default_instance_.Shutdown();
  _TokenControlMessage_default_instance_.Shutdown();
  _RegistrationStatus_default_instance_.Shutdown();
  _RegistrationStatusMessage_default_instance_.Shutdown();
  _RegistrationSyncRequestMessage_default_instance_.Shutdown();
  _InvalidationMessage_default_instance_.Shutdown();
  _InfoRequestMessage_default_instance_.Shutdown();
  _RateLimitP_default_instance_.Shutdown();
  _ProtocolHandlerConfigP_default_instance_.Shutdown();
  _ClientConfigP_default_instance_.Shutdown();
  _ConfigChangeMessage_default_instance_.Shutdown();
  _ErrorMessage_default_instance_.Shutdown();
}

void TableStruct::InitDefaultsImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::InitProtobufDefaults();
  _Version_default_instance_.DefaultConstruct();
  _ProtocolVersion_default_instance_.DefaultConstruct();
  _ClientVersion_default_instance_.DefaultConstruct();
  _StatusP_default_instance_.DefaultConstruct();
  _ObjectIdP_default_instance_.DefaultConstruct();
  _ApplicationClientIdP_default_instance_.DefaultConstruct();
  _InvalidationP_default_instance_.DefaultConstruct();
  _RegistrationP_default_instance_.DefaultConstruct();
  _RegistrationSummary_default_instance_.DefaultConstruct();
  _ClientHeader_default_instance_.DefaultConstruct();
  _ClientToServerMessage_default_instance_.DefaultConstruct();
  _InitializeMessage_default_instance_.DefaultConstruct();
  _RegistrationMessage_default_instance_.DefaultConstruct();
  _RegistrationSyncMessage_default_instance_.DefaultConstruct();
  _RegistrationSubtree_default_instance_.DefaultConstruct();
  _InfoMessage_default_instance_.DefaultConstruct();
  _PropertyRecord_default_instance_.DefaultConstruct();
  _ServerHeader_default_instance_.DefaultConstruct();
  _ServerToClientMessage_default_instance_.DefaultConstruct();
  _TokenControlMessage_default_instance_.DefaultConstruct();
  _RegistrationStatus_default_instance_.DefaultConstruct();
  _RegistrationStatusMessage_default_instance_.DefaultConstruct();
  _RegistrationSyncRequestMessage_default_instance_.DefaultConstruct();
  _InvalidationMessage_default_instance_.DefaultConstruct();
  _InfoRequestMessage_default_instance_.DefaultConstruct();
  _RateLimitP_default_instance_.DefaultConstruct();
  _ProtocolHandlerConfigP_default_instance_.DefaultConstruct();
  _ClientConfigP_default_instance_.DefaultConstruct();
  _ConfigChangeMessage_default_instance_.DefaultConstruct();
  _ErrorMessage_default_instance_.DefaultConstruct();
  _ProtocolVersion_default_instance_.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
  _ClientVersion_default_instance_.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
  _InvalidationP_default_instance_.get_mutable()->object_id_ = const_cast< ::ipc::invalidation::ObjectIdP*>(
      ::ipc::invalidation::ObjectIdP::internal_default_instance());
  _RegistrationP_default_instance_.get_mutable()->object_id_ = const_cast< ::ipc::invalidation::ObjectIdP*>(
      ::ipc::invalidation::ObjectIdP::internal_default_instance());
  _ClientHeader_default_instance_.get_mutable()->protocol_version_ = const_cast< ::ipc::invalidation::ProtocolVersion*>(
      ::ipc::invalidation::ProtocolVersion::internal_default_instance());
  _ClientHeader_default_instance_.get_mutable()->registration_summary_ = const_cast< ::ipc::invalidation::RegistrationSummary*>(
      ::ipc::invalidation::RegistrationSummary::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->header_ = const_cast< ::ipc::invalidation::ClientHeader*>(
      ::ipc::invalidation::ClientHeader::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->initialize_message_ = const_cast< ::ipc::invalidation::InitializeMessage*>(
      ::ipc::invalidation::InitializeMessage::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->registration_message_ = const_cast< ::ipc::invalidation::RegistrationMessage*>(
      ::ipc::invalidation::RegistrationMessage::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->registration_sync_message_ = const_cast< ::ipc::invalidation::RegistrationSyncMessage*>(
      ::ipc::invalidation::RegistrationSyncMessage::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->invalidation_ack_message_ = const_cast< ::ipc::invalidation::InvalidationMessage*>(
      ::ipc::invalidation::InvalidationMessage::internal_default_instance());
  _ClientToServerMessage_default_instance_.get_mutable()->info_message_ = const_cast< ::ipc::invalidation::InfoMessage*>(
      ::ipc::invalidation::InfoMessage::internal_default_instance());
  _InitializeMessage_default_instance_.get_mutable()->application_client_id_ = const_cast< ::ipc::invalidation::ApplicationClientIdP*>(
      ::ipc::invalidation::ApplicationClientIdP::internal_default_instance());
  _InfoMessage_default_instance_.get_mutable()->client_version_ = const_cast< ::ipc::invalidation::ClientVersion*>(
      ::ipc::invalidation::ClientVersion::internal_default_instance());
  _InfoMessage_default_instance_.get_mutable()->client_config_ = const_cast< ::ipc::invalidation::ClientConfigP*>(
      ::ipc::invalidation::ClientConfigP::internal_default_instance());
  _ServerHeader_default_instance_.get_mutable()->protocol_version_ = const_cast< ::ipc::invalidation::ProtocolVersion*>(
      ::ipc::invalidation::ProtocolVersion::internal_default_instance());
  _ServerHeader_default_instance_.get_mutable()->registration_summary_ = const_cast< ::ipc::invalidation::RegistrationSummary*>(
      ::ipc::invalidation::RegistrationSummary::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->header_ = const_cast< ::ipc::invalidation::ServerHeader*>(
      ::ipc::invalidation::ServerHeader::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->token_control_message_ = const_cast< ::ipc::invalidation::TokenControlMessage*>(
      ::ipc::invalidation::TokenControlMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->invalidation_message_ = const_cast< ::ipc::invalidation::InvalidationMessage*>(
      ::ipc::invalidation::InvalidationMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->registration_status_message_ = const_cast< ::ipc::invalidation::RegistrationStatusMessage*>(
      ::ipc::invalidation::RegistrationStatusMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->registration_sync_request_message_ = const_cast< ::ipc::invalidation::RegistrationSyncRequestMessage*>(
      ::ipc::invalidation::RegistrationSyncRequestMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->config_change_message_ = const_cast< ::ipc::invalidation::ConfigChangeMessage*>(
      ::ipc::invalidation::ConfigChangeMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->info_request_message_ = const_cast< ::ipc::invalidation::InfoRequestMessage*>(
      ::ipc::invalidation::InfoRequestMessage::internal_default_instance());
  _ServerToClientMessage_default_instance_.get_mutable()->error_message_ = const_cast< ::ipc::invalidation::ErrorMessage*>(
      ::ipc::invalidation::ErrorMessage::internal_default_instance());
  _RegistrationStatus_default_instance_.get_mutable()->registration_ = const_cast< ::ipc::invalidation::RegistrationP*>(
      ::ipc::invalidation::RegistrationP::internal_default_instance());
  _RegistrationStatus_default_instance_.get_mutable()->status_ = const_cast< ::ipc::invalidation::StatusP*>(
      ::ipc::invalidation::StatusP::internal_default_instance());
  _ClientConfigP_default_instance_.get_mutable()->version_ = const_cast< ::ipc::invalidation::Version*>(
      ::ipc::invalidation::Version::internal_default_instance());
  _ClientConfigP_default_instance_.get_mutable()->protocol_handler_config_ = const_cast< ::ipc::invalidation::ProtocolHandlerConfigP*>(
      ::ipc::invalidation::ProtocolHandlerConfigP::internal_default_instance());
}

void InitDefaults() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &TableStruct::InitDefaultsImpl);
}
void AddDescriptorsImpl() {
  InitDefaults();
  ::google::protobuf::internal::OnShutdown(&TableStruct::Shutdown);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}

}  // namespace protobuf_client_5fprotocol_2eproto

bool StatusP_Code_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const StatusP_Code StatusP::SUCCESS;
const StatusP_Code StatusP::TRANSIENT_FAILURE;
const StatusP_Code StatusP::PERMANENT_FAILURE;
const StatusP_Code StatusP::Code_MIN;
const StatusP_Code StatusP::Code_MAX;
const int StatusP::Code_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool RegistrationP_OpType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RegistrationP_OpType RegistrationP::REGISTER;
const RegistrationP_OpType RegistrationP::UNREGISTER;
const RegistrationP_OpType RegistrationP::OpType_MIN;
const RegistrationP_OpType RegistrationP::OpType_MAX;
const int RegistrationP::OpType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool InitializeMessage_DigestSerializationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const InitializeMessage_DigestSerializationType InitializeMessage::BYTE_BASED;
const InitializeMessage_DigestSerializationType InitializeMessage::NUMBER_BASED;
const InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MIN;
const InitializeMessage_DigestSerializationType InitializeMessage::DigestSerializationType_MAX;
const int InitializeMessage::DigestSerializationType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool InfoRequestMessage_InfoType_IsValid(int value) {
  switch (value) {
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const InfoRequestMessage_InfoType InfoRequestMessage::GET_PERFORMANCE_COUNTERS;
const InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MIN;
const InfoRequestMessage_InfoType InfoRequestMessage::InfoType_MAX;
const int InfoRequestMessage::InfoType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ErrorMessage_Code_IsValid(int value) {
  switch (value) {
    case 1:
    case 10000:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ErrorMessage_Code ErrorMessage::AUTH_FAILURE;
const ErrorMessage_Code ErrorMessage::UNKNOWN_FAILURE;
const ErrorMessage_Code ErrorMessage::Code_MIN;
const ErrorMessage_Code ErrorMessage::Code_MAX;
const int ErrorMessage::Code_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Version::kMajorVersionFieldNumber;
const int Version::kMinorVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Version::Version()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.Version)
}
Version::Version(const Version& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&major_version_, &from.major_version_,
    static_cast<size_t>(reinterpret_cast<char*>(&minor_version_) -
    reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.Version)
}

void Version::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&major_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&minor_version_) -
      reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.Version)
  SharedDtor();
}

void Version::SharedDtor() {
}

void Version::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Version& Version::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

Version* Version::New(::google::protobuf::Arena* arena) const {
  Version* n = new Version;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.Version)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&major_version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minor_version_) -
        reinterpret_cast<char*>(&major_version_)) + sizeof(minor_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Version::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.Version)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 major_version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_major_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &major_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 minor_version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_minor_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minor_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.Version)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.Version)
  return false;
#undef DO_
}

void Version::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.Version)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 major_version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->major_version(), output);
  }

  // optional int32 minor_version = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->minor_version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.Version)
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.Version)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 major_version = 1;
    if (has_major_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->major_version());
    }

    // optional int32 minor_version = 2;
    if (has_minor_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minor_version());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Version::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Version*>(&from));
}

void Version::MergeFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.Version)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      major_version_ = from.major_version_;
    }
    if (cached_has_bits & 0x00000002u) {
      minor_version_ = from.minor_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::Swap(Version* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Version::InternalSwap(Version* other) {
  std::swap(major_version_, other->major_version_);
  std::swap(minor_version_, other->minor_version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Version::GetTypeName() const {
  return "ipc.invalidation.Version";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Version

// optional int32 major_version = 1;
bool Version::has_major_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Version::set_has_major_version() {
  _has_bits_[0] |= 0x00000001u;
}
void Version::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void Version::clear_major_version() {
  major_version_ = 0;
  clear_has_major_version();
}
::google::protobuf::int32 Version::major_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.Version.major_version)
  return major_version_;
}
void Version::set_major_version(::google::protobuf::int32 value) {
  set_has_major_version();
  major_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.Version.major_version)
}

// optional int32 minor_version = 2;
bool Version::has_minor_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Version::set_has_minor_version() {
  _has_bits_[0] |= 0x00000002u;
}
void Version::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void Version::clear_minor_version() {
  minor_version_ = 0;
  clear_has_minor_version();
}
::google::protobuf::int32 Version::minor_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.Version.minor_version)
  return minor_version_;
}
void Version::set_minor_version(::google::protobuf::int32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.Version.minor_version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProtocolVersion::kVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProtocolVersion::ProtocolVersion()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolVersion)
}
ProtocolVersion::ProtocolVersion(const ProtocolVersion& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolVersion)
}

void ProtocolVersion::SharedCtor() {
  _cached_size_ = 0;
  version_ = NULL;
}

ProtocolVersion::~ProtocolVersion() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolVersion)
  SharedDtor();
}

void ProtocolVersion::SharedDtor() {
  if (this != internal_default_instance()) {
    delete version_;
  }
}

void ProtocolVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProtocolVersion& ProtocolVersion::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ProtocolVersion* ProtocolVersion::New(::google::protobuf::Arena* arena) const {
  ProtocolVersion* n = new ProtocolVersion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProtocolVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolVersion)
  if (has_version()) {
    GOOGLE_DCHECK(version_ != NULL);
    version_->::ipc::invalidation::Version::Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ProtocolVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolVersion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolVersion)
  return false;
#undef DO_
}

void ProtocolVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolVersion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->version_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolVersion)
}

size_t ProtocolVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolVersion)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // optional .ipc.invalidation.Version version = 1;
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->version_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtocolVersion::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ProtocolVersion*>(&from));
}

void ProtocolVersion::MergeFrom(const ProtocolVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolVersion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_version()) {
    mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
  }
}

void ProtocolVersion::CopyFrom(const ProtocolVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolVersion::IsInitialized() const {
  return true;
}

void ProtocolVersion::Swap(ProtocolVersion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProtocolVersion::InternalSwap(ProtocolVersion* other) {
  std::swap(version_, other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ProtocolVersion::GetTypeName() const {
  return "ipc.invalidation.ProtocolVersion";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProtocolVersion

// optional .ipc.invalidation.Version version = 1;
bool ProtocolVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ProtocolVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void ProtocolVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void ProtocolVersion::clear_version() {
  if (version_ != NULL) version_->::ipc::invalidation::Version::Clear();
  clear_has_version();
}
const ::ipc::invalidation::Version& ProtocolVersion::version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolVersion.version)
  return version_ != NULL ? *version_
                         : *::ipc::invalidation::Version::internal_default_instance();
}
::ipc::invalidation::Version* ProtocolVersion::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    version_ = new ::ipc::invalidation::Version;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolVersion.version)
  return version_;
}
::ipc::invalidation::Version* ProtocolVersion::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ProtocolVersion.version)
  clear_has_version();
  ::ipc::invalidation::Version* temp = version_;
  version_ = NULL;
  return temp;
}
void ProtocolVersion::set_allocated_version(::ipc::invalidation::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ProtocolVersion.version)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientVersion::kVersionFieldNumber;
const int ClientVersion::kPlatformFieldNumber;
const int ClientVersion::kLanguageFieldNumber;
const int ClientVersion::kApplicationInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientVersion::ClientVersion()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientVersion)
}
ClientVersion::ClientVersion(const ClientVersion& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  platform_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_platform()) {
    platform_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.platform_);
  }
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_language()) {
    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  application_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_application_info()) {
    application_info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.application_info_);
  }
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientVersion)
}

void ClientVersion::SharedCtor() {
  _cached_size_ = 0;
  platform_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  application_info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = NULL;
}

ClientVersion::~ClientVersion() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientVersion)
  SharedDtor();
}

void ClientVersion::SharedDtor() {
  platform_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  application_info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete version_;
  }
}

void ClientVersion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientVersion& ClientVersion::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClientVersion* ClientVersion::New(::google::protobuf::Arena* arena) const {
  ClientVersion* n = new ClientVersion;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientVersion::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientVersion)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_platform()) {
      GOOGLE_DCHECK(!platform_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*platform_.UnsafeRawStringPointer())->clear();
    }
    if (has_language()) {
      GOOGLE_DCHECK(!language_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*language_.UnsafeRawStringPointer())->clear();
    }
    if (has_application_info()) {
      GOOGLE_DCHECK(!application_info_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*application_info_.UnsafeRawStringPointer())->clear();
    }
    if (has_version()) {
      GOOGLE_DCHECK(version_ != NULL);
      version_->::ipc::invalidation::Version::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClientVersion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientVersion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string platform = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_platform()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string language = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string application_info = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_application_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientVersion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientVersion)
  return false;
#undef DO_
}

void ClientVersion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientVersion)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->version_, output);
  }

  // optional string platform = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->platform(), output);
  }

  // optional string language = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->language(), output);
  }

  // optional string application_info = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->application_info(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientVersion)
}

size_t ClientVersion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientVersion)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 15u) {
    // optional string platform = 2;
    if (has_platform()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->platform());
    }

    // optional string language = 3;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string application_info = 4;
    if (has_application_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->application_info());
    }

    // optional .ipc.invalidation.Version version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->version_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientVersion::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientVersion*>(&from));
}

void ClientVersion::MergeFrom(const ClientVersion& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientVersion)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_platform();
      platform_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.platform_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_language();
      language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_application_info();
      application_info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.application_info_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
    }
  }
}

void ClientVersion::CopyFrom(const ClientVersion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientVersion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientVersion::IsInitialized() const {
  return true;
}

void ClientVersion::Swap(ClientVersion* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientVersion::InternalSwap(ClientVersion* other) {
  platform_.Swap(&other->platform_);
  language_.Swap(&other->language_);
  application_info_.Swap(&other->application_info_);
  std::swap(version_, other->version_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientVersion::GetTypeName() const {
  return "ipc.invalidation.ClientVersion";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientVersion

// optional .ipc.invalidation.Version version = 1;
bool ClientVersion::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ClientVersion::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
void ClientVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
void ClientVersion::clear_version() {
  if (version_ != NULL) version_->::ipc::invalidation::Version::Clear();
  clear_has_version();
}
const ::ipc::invalidation::Version& ClientVersion::version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.version)
  return version_ != NULL ? *version_
                         : *::ipc::invalidation::Version::internal_default_instance();
}
::ipc::invalidation::Version* ClientVersion::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    version_ = new ::ipc::invalidation::Version;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.version)
  return version_;
}
::ipc::invalidation::Version* ClientVersion::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.version)
  clear_has_version();
  ::ipc::invalidation::Version* temp = version_;
  version_ = NULL;
  return temp;
}
void ClientVersion::set_allocated_version(::ipc::invalidation::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.version)
}

// optional string platform = 2;
bool ClientVersion::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientVersion::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientVersion::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientVersion::clear_platform() {
  platform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_platform();
}
const ::std::string& ClientVersion::platform() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.platform)
  return platform_.GetNoArena();
}
void ClientVersion::set_platform(const ::std::string& value) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.platform)
}
#if LANG_CXX11
void ClientVersion::set_platform(::std::string&& value) {
  set_has_platform();
  platform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.platform)
}
#endif
void ClientVersion::set_platform(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.platform)
}
void ClientVersion::set_platform(const char* value, size_t size) {
  set_has_platform();
  platform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.platform)
}
::std::string* ClientVersion::mutable_platform() {
  set_has_platform();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.platform)
  return platform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientVersion::release_platform() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.platform)
  clear_has_platform();
  return platform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientVersion::set_allocated_platform(::std::string* platform) {
  if (platform != NULL) {
    set_has_platform();
  } else {
    clear_has_platform();
  }
  platform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), platform);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.platform)
}

// optional string language = 3;
bool ClientVersion::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientVersion::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientVersion::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientVersion::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
const ::std::string& ClientVersion::language() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.language)
  return language_.GetNoArena();
}
void ClientVersion::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.language)
}
#if LANG_CXX11
void ClientVersion::set_language(::std::string&& value) {
  set_has_language();
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.language)
}
#endif
void ClientVersion::set_language(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.language)
}
void ClientVersion::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.language)
}
::std::string* ClientVersion::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientVersion::release_language() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientVersion::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.language)
}

// optional string application_info = 4;
bool ClientVersion::has_application_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ClientVersion::set_has_application_info() {
  _has_bits_[0] |= 0x00000004u;
}
void ClientVersion::clear_has_application_info() {
  _has_bits_[0] &= ~0x00000004u;
}
void ClientVersion::clear_application_info() {
  application_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_application_info();
}
const ::std::string& ClientVersion::application_info() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientVersion.application_info)
  return application_info_.GetNoArena();
}
void ClientVersion::set_application_info(const ::std::string& value) {
  set_has_application_info();
  application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientVersion.application_info)
}
#if LANG_CXX11
void ClientVersion::set_application_info(::std::string&& value) {
  set_has_application_info();
  application_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientVersion.application_info)
}
#endif
void ClientVersion::set_application_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_application_info();
  application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientVersion.application_info)
}
void ClientVersion::set_application_info(const char* value, size_t size) {
  set_has_application_info();
  application_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientVersion.application_info)
}
::std::string* ClientVersion::mutable_application_info() {
  set_has_application_info();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientVersion.application_info)
  return application_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientVersion::release_application_info() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientVersion.application_info)
  clear_has_application_info();
  return application_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientVersion::set_allocated_application_info(::std::string* application_info) {
  if (application_info != NULL) {
    set_has_application_info();
  } else {
    clear_has_application_info();
  }
  application_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), application_info);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientVersion.application_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int StatusP::kCodeFieldNumber;
const int StatusP::kDescriptionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StatusP::StatusP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.StatusP)
}
StatusP::StatusP(const StatusP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.StatusP)
}

void StatusP::SharedCtor() {
  _cached_size_ = 0;
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

StatusP::~StatusP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.StatusP)
  SharedDtor();
}

void StatusP::SharedDtor() {
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void StatusP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StatusP& StatusP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

StatusP* StatusP::New(::google::protobuf::Arena* arena) const {
  StatusP* n = new StatusP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StatusP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.StatusP)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_description()) {
      GOOGLE_DCHECK(!description_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*description_.UnsafeRawStringPointer())->clear();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool StatusP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.StatusP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.StatusP.Code code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::StatusP_Code_IsValid(value)) {
            set_code(static_cast< ::ipc::invalidation::StatusP_Code >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.StatusP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.StatusP)
  return false;
#undef DO_
}

void StatusP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.StatusP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.StatusP.Code code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->description(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.StatusP)
}

size_t StatusP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.StatusP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string description = 2;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional .ipc.invalidation.StatusP.Code code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StatusP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StatusP*>(&from));
}

void StatusP::MergeFrom(const StatusP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.StatusP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_description();
      description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StatusP::CopyFrom(const StatusP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.StatusP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusP::IsInitialized() const {
  return true;
}

void StatusP::Swap(StatusP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StatusP::InternalSwap(StatusP* other) {
  description_.Swap(&other->description_);
  std::swap(code_, other->code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StatusP::GetTypeName() const {
  return "ipc.invalidation.StatusP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StatusP

// optional .ipc.invalidation.StatusP.Code code = 1;
bool StatusP::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void StatusP::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
void StatusP::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void StatusP::clear_code() {
  code_ = 1;
  clear_has_code();
}
::ipc::invalidation::StatusP_Code StatusP::code() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.code)
  return static_cast< ::ipc::invalidation::StatusP_Code >(code_);
}
void StatusP::set_code(::ipc::invalidation::StatusP_Code value) {
  assert(::ipc::invalidation::StatusP_Code_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.code)
}

// optional string description = 2;
bool StatusP::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void StatusP::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
void StatusP::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
void StatusP::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
const ::std::string& StatusP::description() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.StatusP.description)
  return description_.GetNoArena();
}
void StatusP::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.StatusP.description)
}
#if LANG_CXX11
void StatusP::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.StatusP.description)
}
#endif
void StatusP::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.StatusP.description)
}
void StatusP::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.StatusP.description)
}
::std::string* StatusP::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.StatusP.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* StatusP::release_description() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.StatusP.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void StatusP::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.StatusP.description)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObjectIdP::kSourceFieldNumber;
const int ObjectIdP::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObjectIdP::ObjectIdP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ObjectIdP)
}
ObjectIdP::ObjectIdP(const ObjectIdP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  source_ = from.source_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ObjectIdP)
}

void ObjectIdP::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = 0;
}

ObjectIdP::~ObjectIdP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ObjectIdP)
  SharedDtor();
}

void ObjectIdP::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ObjectIdP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ObjectIdP& ObjectIdP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ObjectIdP* ObjectIdP::New(::google::protobuf::Arena* arena) const {
  ObjectIdP* n = new ObjectIdP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ObjectIdP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ObjectIdP)
  if (has_name()) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  source_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ObjectIdP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ObjectIdP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 source = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_source();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &source_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ObjectIdP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ObjectIdP)
  return false;
#undef DO_
}

void ObjectIdP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ObjectIdP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 source = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->source(), output);
  }

  // optional bytes name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ObjectIdP)
}

size_t ObjectIdP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ObjectIdP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->name());
    }

    // optional int32 source = 1;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->source());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObjectIdP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ObjectIdP*>(&from));
}

void ObjectIdP::MergeFrom(const ObjectIdP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ObjectIdP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      source_ = from.source_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ObjectIdP::CopyFrom(const ObjectIdP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ObjectIdP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObjectIdP::IsInitialized() const {
  return true;
}

void ObjectIdP::Swap(ObjectIdP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObjectIdP::InternalSwap(ObjectIdP* other) {
  name_.Swap(&other->name_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ObjectIdP::GetTypeName() const {
  return "ipc.invalidation.ObjectIdP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ObjectIdP

// optional int32 source = 1;
bool ObjectIdP::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ObjectIdP::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
void ObjectIdP::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
void ObjectIdP::clear_source() {
  source_ = 0;
  clear_has_source();
}
::google::protobuf::int32 ObjectIdP::source() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.source)
  return source_;
}
void ObjectIdP::set_source(::google::protobuf::int32 value) {
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.source)
}

// optional bytes name = 2;
bool ObjectIdP::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ObjectIdP::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ObjectIdP::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ObjectIdP::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& ObjectIdP::name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ObjectIdP.name)
  return name_.GetNoArena();
}
void ObjectIdP::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ObjectIdP.name)
}
#if LANG_CXX11
void ObjectIdP::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ObjectIdP.name)
}
#endif
void ObjectIdP::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ObjectIdP.name)
}
void ObjectIdP::set_name(const void* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ObjectIdP.name)
}
::std::string* ObjectIdP::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ObjectIdP.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ObjectIdP::release_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ObjectIdP.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ObjectIdP::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ObjectIdP.name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ApplicationClientIdP::kClientTypeFieldNumber;
const int ApplicationClientIdP::kClientNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ApplicationClientIdP::ApplicationClientIdP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ApplicationClientIdP)
}
ApplicationClientIdP::ApplicationClientIdP(const ApplicationClientIdP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_name()) {
    client_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_name_);
  }
  client_type_ = from.client_type_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ApplicationClientIdP)
}

void ApplicationClientIdP::SharedCtor() {
  _cached_size_ = 0;
  client_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  client_type_ = 0;
}

ApplicationClientIdP::~ApplicationClientIdP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ApplicationClientIdP)
  SharedDtor();
}

void ApplicationClientIdP::SharedDtor() {
  client_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ApplicationClientIdP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ApplicationClientIdP& ApplicationClientIdP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ApplicationClientIdP* ApplicationClientIdP::New(::google::protobuf::Arena* arena) const {
  ApplicationClientIdP* n = new ApplicationClientIdP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ApplicationClientIdP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ApplicationClientIdP)
  if (has_client_name()) {
    GOOGLE_DCHECK(!client_name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*client_name_.UnsafeRawStringPointer())->clear();
  }
  client_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ApplicationClientIdP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ApplicationClientIdP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 client_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_client_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_name = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ApplicationClientIdP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ApplicationClientIdP)
  return false;
#undef DO_
}

void ApplicationClientIdP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ApplicationClientIdP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 client_type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
  }

  // optional bytes client_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ApplicationClientIdP)
}

size_t ApplicationClientIdP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ApplicationClientIdP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes client_name = 2;
    if (has_client_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->client_name());
    }

    // optional int32 client_type = 1;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplicationClientIdP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ApplicationClientIdP*>(&from));
}

void ApplicationClientIdP::MergeFrom(const ApplicationClientIdP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ApplicationClientIdP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_client_name();
      client_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ApplicationClientIdP::CopyFrom(const ApplicationClientIdP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ApplicationClientIdP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplicationClientIdP::IsInitialized() const {
  return true;
}

void ApplicationClientIdP::Swap(ApplicationClientIdP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ApplicationClientIdP::InternalSwap(ApplicationClientIdP* other) {
  client_name_.Swap(&other->client_name_);
  std::swap(client_type_, other->client_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ApplicationClientIdP::GetTypeName() const {
  return "ipc.invalidation.ApplicationClientIdP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ApplicationClientIdP

// optional int32 client_type = 1;
bool ApplicationClientIdP::has_client_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ApplicationClientIdP::set_has_client_type() {
  _has_bits_[0] |= 0x00000002u;
}
void ApplicationClientIdP::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void ApplicationClientIdP::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
::google::protobuf::int32 ApplicationClientIdP::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_type)
  return client_type_;
}
void ApplicationClientIdP::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_type)
}

// optional bytes client_name = 2;
bool ApplicationClientIdP::has_client_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ApplicationClientIdP::set_has_client_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ApplicationClientIdP::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ApplicationClientIdP::clear_client_name() {
  client_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_name();
}
const ::std::string& ApplicationClientIdP::client_name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ApplicationClientIdP.client_name)
  return client_name_.GetNoArena();
}
void ApplicationClientIdP::set_client_name(const ::std::string& value) {
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ApplicationClientIdP.client_name)
}
#if LANG_CXX11
void ApplicationClientIdP::set_client_name(::std::string&& value) {
  set_has_client_name();
  client_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ApplicationClientIdP.client_name)
}
#endif
void ApplicationClientIdP::set_client_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ApplicationClientIdP.client_name)
}
void ApplicationClientIdP::set_client_name(const void* value, size_t size) {
  set_has_client_name();
  client_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ApplicationClientIdP.client_name)
}
::std::string* ApplicationClientIdP::mutable_client_name() {
  set_has_client_name();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ApplicationClientIdP.client_name)
  return client_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ApplicationClientIdP::release_client_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ApplicationClientIdP.client_name)
  clear_has_client_name();
  return client_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ApplicationClientIdP::set_allocated_client_name(::std::string* client_name) {
  if (client_name != NULL) {
    set_has_client_name();
  } else {
    clear_has_client_name();
  }
  client_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ApplicationClientIdP.client_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InvalidationP::kObjectIdFieldNumber;
const int InvalidationP::kIsKnownVersionFieldNumber;
const int InvalidationP::kVersionFieldNumber;
const int InvalidationP::kIsTrickleRestartFieldNumber;
const int InvalidationP::kPayloadFieldNumber;
const int InvalidationP::kBridgeArrivalTimeMsDeprecatedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InvalidationP::InvalidationP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationP)
}
InvalidationP::InvalidationP(const InvalidationP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_payload()) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  if (from.has_object_id()) {
    object_id_ = new ::ipc::invalidation::ObjectIdP(*from.object_id_);
  } else {
    object_id_ = NULL;
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_trickle_restart_) -
    reinterpret_cast<char*>(&version_)) + sizeof(is_trickle_restart_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationP)
}

void InvalidationP::SharedCtor() {
  _cached_size_ = 0;
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&object_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_trickle_restart_) -
      reinterpret_cast<char*>(&object_id_)) + sizeof(is_trickle_restart_));
}

InvalidationP::~InvalidationP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationP)
  SharedDtor();
}

void InvalidationP::SharedDtor() {
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete object_id_;
  }
}

void InvalidationP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InvalidationP& InvalidationP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

InvalidationP* InvalidationP::New(::google::protobuf::Arena* arena) const {
  InvalidationP* n = new InvalidationP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InvalidationP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationP)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_payload()) {
      GOOGLE_DCHECK(!payload_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*payload_.UnsafeRawStringPointer())->clear();
    }
    if (has_object_id()) {
      GOOGLE_DCHECK(object_id_ != NULL);
      object_id_->::ipc::invalidation::ObjectIdP::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 60u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_trickle_restart_) -
        reinterpret_cast<char*>(&version_)) + sizeof(is_trickle_restart_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InvalidationP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_known_version = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_is_known_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_known_version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 version = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_version();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &version_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes payload = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_bridge_arrival_time_ms_deprecated();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &bridge_arrival_time_ms_deprecated_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_trickle_restart = 6 [default = false];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_is_trickle_restart();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_trickle_restart_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationP)
  return false;
#undef DO_
}

void InvalidationP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->object_id_, output);
  }

  // optional bool is_known_version = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_known_version(), output);
  }

  // optional int64 version = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->version(), output);
  }

  // optional bytes payload = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->payload(), output);
  }

  // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->bridge_arrival_time_ms_deprecated(), output);
  }

  // optional bool is_trickle_restart = 6 [default = false];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->is_trickle_restart(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationP)
}

size_t InvalidationP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 63u) {
    // optional bytes payload = 4;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->object_id_);
    }

    // optional int64 version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->version());
    }

    // optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
    if (has_bridge_arrival_time_ms_deprecated()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->bridge_arrival_time_ms_deprecated());
    }

    // optional bool is_known_version = 2;
    if (has_is_known_version()) {
      total_size += 1 + 1;
    }

    // optional bool is_trickle_restart = 6 [default = false];
    if (has_is_trickle_restart()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InvalidationP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InvalidationP*>(&from));
}

void InvalidationP::MergeFrom(const InvalidationP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_payload();
      payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      bridge_arrival_time_ms_deprecated_ = from.bridge_arrival_time_ms_deprecated_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_known_version_ = from.is_known_version_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_trickle_restart_ = from.is_trickle_restart_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InvalidationP::CopyFrom(const InvalidationP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvalidationP::IsInitialized() const {
  return true;
}

void InvalidationP::Swap(InvalidationP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InvalidationP::InternalSwap(InvalidationP* other) {
  payload_.Swap(&other->payload_);
  std::swap(object_id_, other->object_id_);
  std::swap(version_, other->version_);
  std::swap(bridge_arrival_time_ms_deprecated_, other->bridge_arrival_time_ms_deprecated_);
  std::swap(is_known_version_, other->is_known_version_);
  std::swap(is_trickle_restart_, other->is_trickle_restart_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InvalidationP::GetTypeName() const {
  return "ipc.invalidation.InvalidationP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InvalidationP

// optional .ipc.invalidation.ObjectIdP object_id = 1;
bool InvalidationP::has_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InvalidationP::set_has_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
void InvalidationP::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void InvalidationP::clear_object_id() {
  if (object_id_ != NULL) object_id_->::ipc::invalidation::ObjectIdP::Clear();
  clear_has_object_id();
}
const ::ipc::invalidation::ObjectIdP& InvalidationP::object_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.object_id)
  return object_id_ != NULL ? *object_id_
                         : *::ipc::invalidation::ObjectIdP::internal_default_instance();
}
::ipc::invalidation::ObjectIdP* InvalidationP::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) {
    object_id_ = new ::ipc::invalidation::ObjectIdP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.object_id)
  return object_id_;
}
::ipc::invalidation::ObjectIdP* InvalidationP::release_object_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.object_id)
  clear_has_object_id();
  ::ipc::invalidation::ObjectIdP* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
void InvalidationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.object_id)
}

// optional bool is_known_version = 2;
bool InvalidationP::has_is_known_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void InvalidationP::set_has_is_known_version() {
  _has_bits_[0] |= 0x00000010u;
}
void InvalidationP::clear_has_is_known_version() {
  _has_bits_[0] &= ~0x00000010u;
}
void InvalidationP::clear_is_known_version() {
  is_known_version_ = false;
  clear_has_is_known_version();
}
bool InvalidationP::is_known_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_known_version)
  return is_known_version_;
}
void InvalidationP::set_is_known_version(bool value) {
  set_has_is_known_version();
  is_known_version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_known_version)
}

// optional int64 version = 3;
bool InvalidationP::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InvalidationP::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
void InvalidationP::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void InvalidationP::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
::google::protobuf::int64 InvalidationP::version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.version)
  return version_;
}
void InvalidationP::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.version)
}

// optional bool is_trickle_restart = 6 [default = false];
bool InvalidationP::has_is_trickle_restart() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void InvalidationP::set_has_is_trickle_restart() {
  _has_bits_[0] |= 0x00000020u;
}
void InvalidationP::clear_has_is_trickle_restart() {
  _has_bits_[0] &= ~0x00000020u;
}
void InvalidationP::clear_is_trickle_restart() {
  is_trickle_restart_ = false;
  clear_has_is_trickle_restart();
}
bool InvalidationP::is_trickle_restart() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.is_trickle_restart)
  return is_trickle_restart_;
}
void InvalidationP::set_is_trickle_restart(bool value) {
  set_has_is_trickle_restart();
  is_trickle_restart_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.is_trickle_restart)
}

// optional bytes payload = 4;
bool InvalidationP::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InvalidationP::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
void InvalidationP::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
void InvalidationP::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
const ::std::string& InvalidationP::payload() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.payload)
  return payload_.GetNoArena();
}
void InvalidationP::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.payload)
}
#if LANG_CXX11
void InvalidationP::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.InvalidationP.payload)
}
#endif
void InvalidationP::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.InvalidationP.payload)
}
void InvalidationP::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InvalidationP.payload)
}
::std::string* InvalidationP::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationP.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* InvalidationP::release_payload() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InvalidationP.payload)
  clear_has_payload();
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void InvalidationP::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InvalidationP.payload)
}

// optional int64 bridge_arrival_time_ms_deprecated = 5 [deprecated = true];
bool InvalidationP::has_bridge_arrival_time_ms_deprecated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InvalidationP::set_has_bridge_arrival_time_ms_deprecated() {
  _has_bits_[0] |= 0x00000008u;
}
void InvalidationP::clear_has_bridge_arrival_time_ms_deprecated() {
  _has_bits_[0] &= ~0x00000008u;
}
void InvalidationP::clear_bridge_arrival_time_ms_deprecated() {
  bridge_arrival_time_ms_deprecated_ = GOOGLE_LONGLONG(0);
  clear_has_bridge_arrival_time_ms_deprecated();
}
::google::protobuf::int64 InvalidationP::bridge_arrival_time_ms_deprecated() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
  return bridge_arrival_time_ms_deprecated_;
}
void InvalidationP::set_bridge_arrival_time_ms_deprecated(::google::protobuf::int64 value) {
  set_has_bridge_arrival_time_ms_deprecated();
  bridge_arrival_time_ms_deprecated_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InvalidationP.bridge_arrival_time_ms_deprecated)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationP::kObjectIdFieldNumber;
const int RegistrationP::kOpTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationP::RegistrationP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationP)
}
RegistrationP::RegistrationP(const RegistrationP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_object_id()) {
    object_id_ = new ::ipc::invalidation::ObjectIdP(*from.object_id_);
  } else {
    object_id_ = NULL;
  }
  op_type_ = from.op_type_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationP)
}

void RegistrationP::SharedCtor() {
  _cached_size_ = 0;
  object_id_ = NULL;
  op_type_ = 1;
}

RegistrationP::~RegistrationP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationP)
  SharedDtor();
}

void RegistrationP::SharedDtor() {
  if (this != internal_default_instance()) {
    delete object_id_;
  }
}

void RegistrationP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationP& RegistrationP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationP* RegistrationP::New(::google::protobuf::Arena* arena) const {
  RegistrationP* n = new RegistrationP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationP)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_object_id()) {
      GOOGLE_DCHECK(object_id_ != NULL);
      object_id_->::ipc::invalidation::ObjectIdP::Clear();
    }
    op_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ObjectIdP object_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_object_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::RegistrationP_OpType_IsValid(value)) {
            set_op_type(static_cast< ::ipc::invalidation::RegistrationP_OpType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationP)
  return false;
#undef DO_
}

void RegistrationP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ObjectIdP object_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->object_id_, output);
  }

  // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->op_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationP)
}

size_t RegistrationP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional .ipc.invalidation.ObjectIdP object_id = 1;
    if (has_object_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->object_id_);
    }

    // optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
    if (has_op_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->op_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationP*>(&from));
}

void RegistrationP::MergeFrom(const RegistrationP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_object_id()->::ipc::invalidation::ObjectIdP::MergeFrom(from.object_id());
    }
    if (cached_has_bits & 0x00000002u) {
      op_type_ = from.op_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RegistrationP::CopyFrom(const RegistrationP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationP::IsInitialized() const {
  return true;
}

void RegistrationP::Swap(RegistrationP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationP::InternalSwap(RegistrationP* other) {
  std::swap(object_id_, other->object_id_);
  std::swap(op_type_, other->op_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationP::GetTypeName() const {
  return "ipc.invalidation.RegistrationP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationP

// optional .ipc.invalidation.ObjectIdP object_id = 1;
bool RegistrationP::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegistrationP::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RegistrationP::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegistrationP::clear_object_id() {
  if (object_id_ != NULL) object_id_->::ipc::invalidation::ObjectIdP::Clear();
  clear_has_object_id();
}
const ::ipc::invalidation::ObjectIdP& RegistrationP::object_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.object_id)
  return object_id_ != NULL ? *object_id_
                         : *::ipc::invalidation::ObjectIdP::internal_default_instance();
}
::ipc::invalidation::ObjectIdP* RegistrationP::mutable_object_id() {
  set_has_object_id();
  if (object_id_ == NULL) {
    object_id_ = new ::ipc::invalidation::ObjectIdP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationP.object_id)
  return object_id_;
}
::ipc::invalidation::ObjectIdP* RegistrationP::release_object_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationP.object_id)
  clear_has_object_id();
  ::ipc::invalidation::ObjectIdP* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
void RegistrationP::set_allocated_object_id(::ipc::invalidation::ObjectIdP* object_id) {
  delete object_id_;
  object_id_ = object_id;
  if (object_id) {
    set_has_object_id();
  } else {
    clear_has_object_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationP.object_id)
}

// optional .ipc.invalidation.RegistrationP.OpType op_type = 2;
bool RegistrationP::has_op_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RegistrationP::set_has_op_type() {
  _has_bits_[0] |= 0x00000002u;
}
void RegistrationP::clear_has_op_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void RegistrationP::clear_op_type() {
  op_type_ = 1;
  clear_has_op_type();
}
::ipc::invalidation::RegistrationP_OpType RegistrationP::op_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationP.op_type)
  return static_cast< ::ipc::invalidation::RegistrationP_OpType >(op_type_);
}
void RegistrationP::set_op_type(::ipc::invalidation::RegistrationP_OpType value) {
  assert(::ipc::invalidation::RegistrationP_OpType_IsValid(value));
  set_has_op_type();
  op_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationP.op_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationSummary::kNumRegistrationsFieldNumber;
const int RegistrationSummary::kRegistrationDigestFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationSummary::RegistrationSummary()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSummary)
}
RegistrationSummary::RegistrationSummary(const RegistrationSummary& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  registration_digest_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_registration_digest()) {
    registration_digest_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.registration_digest_);
  }
  num_registrations_ = from.num_registrations_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSummary)
}

void RegistrationSummary::SharedCtor() {
  _cached_size_ = 0;
  registration_digest_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  num_registrations_ = 0;
}

RegistrationSummary::~RegistrationSummary() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSummary)
  SharedDtor();
}

void RegistrationSummary::SharedDtor() {
  registration_digest_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void RegistrationSummary::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationSummary& RegistrationSummary::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationSummary* RegistrationSummary::New(::google::protobuf::Arena* arena) const {
  RegistrationSummary* n = new RegistrationSummary;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationSummary::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSummary)
  if (has_registration_digest()) {
    GOOGLE_DCHECK(!registration_digest_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*registration_digest_.UnsafeRawStringPointer())->clear();
  }
  num_registrations_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationSummary::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSummary)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_registrations = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_num_registrations();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_registrations_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes registration_digest = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_registration_digest()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSummary)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSummary)
  return false;
#undef DO_
}

void RegistrationSummary::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSummary)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_registrations = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_registrations(), output);
  }

  // optional bytes registration_digest = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->registration_digest(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSummary)
}

size_t RegistrationSummary::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSummary)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes registration_digest = 2;
    if (has_registration_digest()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->registration_digest());
    }

    // optional int32 num_registrations = 1;
    if (has_num_registrations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_registrations());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationSummary::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationSummary*>(&from));
}

void RegistrationSummary::MergeFrom(const RegistrationSummary& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSummary)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_registration_digest();
      registration_digest_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.registration_digest_);
    }
    if (cached_has_bits & 0x00000002u) {
      num_registrations_ = from.num_registrations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RegistrationSummary::CopyFrom(const RegistrationSummary& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSummary)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSummary::IsInitialized() const {
  return true;
}

void RegistrationSummary::Swap(RegistrationSummary* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationSummary::InternalSwap(RegistrationSummary* other) {
  registration_digest_.Swap(&other->registration_digest_);
  std::swap(num_registrations_, other->num_registrations_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationSummary::GetTypeName() const {
  return "ipc.invalidation.RegistrationSummary";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationSummary

// optional int32 num_registrations = 1;
bool RegistrationSummary::has_num_registrations() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RegistrationSummary::set_has_num_registrations() {
  _has_bits_[0] |= 0x00000002u;
}
void RegistrationSummary::clear_has_num_registrations() {
  _has_bits_[0] &= ~0x00000002u;
}
void RegistrationSummary::clear_num_registrations() {
  num_registrations_ = 0;
  clear_has_num_registrations();
}
::google::protobuf::int32 RegistrationSummary::num_registrations() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.num_registrations)
  return num_registrations_;
}
void RegistrationSummary::set_num_registrations(::google::protobuf::int32 value) {
  set_has_num_registrations();
  num_registrations_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.num_registrations)
}

// optional bytes registration_digest = 2;
bool RegistrationSummary::has_registration_digest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegistrationSummary::set_has_registration_digest() {
  _has_bits_[0] |= 0x00000001u;
}
void RegistrationSummary::clear_has_registration_digest() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegistrationSummary::clear_registration_digest() {
  registration_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_registration_digest();
}
const ::std::string& RegistrationSummary::registration_digest() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSummary.registration_digest)
  return registration_digest_.GetNoArena();
}
void RegistrationSummary::set_registration_digest(const ::std::string& value) {
  set_has_registration_digest();
  registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.RegistrationSummary.registration_digest)
}
#if LANG_CXX11
void RegistrationSummary::set_registration_digest(::std::string&& value) {
  set_has_registration_digest();
  registration_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.RegistrationSummary.registration_digest)
}
#endif
void RegistrationSummary::set_registration_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_registration_digest();
  registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.RegistrationSummary.registration_digest)
}
void RegistrationSummary::set_registration_digest(const void* value, size_t size) {
  set_has_registration_digest();
  registration_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.RegistrationSummary.registration_digest)
}
::std::string* RegistrationSummary::mutable_registration_digest() {
  set_has_registration_digest();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSummary.registration_digest)
  return registration_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* RegistrationSummary::release_registration_digest() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationSummary.registration_digest)
  clear_has_registration_digest();
  return registration_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void RegistrationSummary::set_allocated_registration_digest(::std::string* registration_digest) {
  if (registration_digest != NULL) {
    set_has_registration_digest();
  } else {
    clear_has_registration_digest();
  }
  registration_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), registration_digest);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationSummary.registration_digest)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientHeader::kProtocolVersionFieldNumber;
const int ClientHeader::kClientTokenFieldNumber;
const int ClientHeader::kRegistrationSummaryFieldNumber;
const int ClientHeader::kClientTimeMsFieldNumber;
const int ClientHeader::kMaxKnownServerTimeMsFieldNumber;
const int ClientHeader::kMessageIdFieldNumber;
const int ClientHeader::kClientTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientHeader::ClientHeader()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientHeader)
}
ClientHeader::ClientHeader(const ClientHeader& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_token()) {
    client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
  }
  message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message_id()) {
    message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
  }
  if (from.has_protocol_version()) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion(*from.protocol_version_);
  } else {
    protocol_version_ = NULL;
  }
  if (from.has_registration_summary()) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary(*from.registration_summary_);
  } else {
    registration_summary_ = NULL;
  }
  ::memcpy(&client_time_ms_, &from.client_time_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&client_time_ms_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientHeader)
}

void ClientHeader::SharedCtor() {
  _cached_size_ = 0;
  client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&protocol_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&client_type_) -
      reinterpret_cast<char*>(&protocol_version_)) + sizeof(client_type_));
}

ClientHeader::~ClientHeader() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientHeader)
  SharedDtor();
}

void ClientHeader::SharedDtor() {
  client_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete protocol_version_;
  }
  if (this != internal_default_instance()) {
    delete registration_summary_;
  }
}

void ClientHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientHeader& ClientHeader::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClientHeader* ClientHeader::New(::google::protobuf::Arena* arena) const {
  ClientHeader* n = new ClientHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientHeader)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_client_token()) {
      GOOGLE_DCHECK(!client_token_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*client_token_.UnsafeRawStringPointer())->clear();
    }
    if (has_message_id()) {
      GOOGLE_DCHECK(!message_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_protocol_version()) {
      GOOGLE_DCHECK(protocol_version_ != NULL);
      protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
    }
    if (has_registration_summary()) {
      GOOGLE_DCHECK(registration_summary_ != NULL);
      registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 112u) {
    ::memset(&client_time_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_type_) -
        reinterpret_cast<char*>(&client_time_ms_)) + sizeof(client_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClientHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_protocol_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_token = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_summary()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 client_time_ms = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_client_time_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &client_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 max_known_server_time_ms = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_max_known_server_time_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &max_known_server_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string message_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 client_type = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_client_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientHeader)
  return false;
#undef DO_
}

void ClientHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->protocol_version_, output);
  }

  // optional bytes client_token = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_token(), output);
  }

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->registration_summary_, output);
  }

  // optional int64 client_time_ms = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->client_time_ms(), output);
  }

  // optional int64 max_known_server_time_ms = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->max_known_server_time_ms(), output);
  }

  // optional string message_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->message_id(), output);
  }

  // optional int32 client_type = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->client_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientHeader)
}

size_t ClientHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientHeader)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 127u) {
    // optional bytes client_token = 2;
    if (has_client_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->client_token());
    }

    // optional string message_id = 6;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message_id());
    }

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->protocol_version_);
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    if (has_registration_summary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_summary_);
    }

    // optional int64 client_time_ms = 4;
    if (has_client_time_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->client_time_ms());
    }

    // optional int64 max_known_server_time_ms = 5;
    if (has_max_known_server_time_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->max_known_server_time_ms());
    }

    // optional int32 client_type = 7;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientHeader::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientHeader*>(&from));
}

void ClientHeader::MergeFrom(const ClientHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 127u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_client_token();
      client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message_id();
      message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
    }
    if (cached_has_bits & 0x00000010u) {
      client_time_ms_ = from.client_time_ms_;
    }
    if (cached_has_bits & 0x00000020u) {
      max_known_server_time_ms_ = from.max_known_server_time_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientHeader::CopyFrom(const ClientHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientHeader::IsInitialized() const {
  return true;
}

void ClientHeader::Swap(ClientHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientHeader::InternalSwap(ClientHeader* other) {
  client_token_.Swap(&other->client_token_);
  message_id_.Swap(&other->message_id_);
  std::swap(protocol_version_, other->protocol_version_);
  std::swap(registration_summary_, other->registration_summary_);
  std::swap(client_time_ms_, other->client_time_ms_);
  std::swap(max_known_server_time_ms_, other->max_known_server_time_ms_);
  std::swap(client_type_, other->client_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientHeader::GetTypeName() const {
  return "ipc.invalidation.ClientHeader";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientHeader

// optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
bool ClientHeader::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ClientHeader::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
}
void ClientHeader::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void ClientHeader::clear_protocol_version() {
  if (protocol_version_ != NULL) protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
  clear_has_protocol_version();
}
const ::ipc::invalidation::ProtocolVersion& ClientHeader::protocol_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.protocol_version)
  return protocol_version_ != NULL ? *protocol_version_
                         : *::ipc::invalidation::ProtocolVersion::internal_default_instance();
}
::ipc::invalidation::ProtocolVersion* ClientHeader::mutable_protocol_version() {
  set_has_protocol_version();
  if (protocol_version_ == NULL) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.protocol_version)
  return protocol_version_;
}
::ipc::invalidation::ProtocolVersion* ClientHeader::release_protocol_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.protocol_version)
  clear_has_protocol_version();
  ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
  protocol_version_ = NULL;
  return temp;
}
void ClientHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version) {
  delete protocol_version_;
  protocol_version_ = protocol_version;
  if (protocol_version) {
    set_has_protocol_version();
  } else {
    clear_has_protocol_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.protocol_version)
}

// optional bytes client_token = 2;
bool ClientHeader::has_client_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientHeader::set_has_client_token() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientHeader::clear_has_client_token() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientHeader::clear_client_token() {
  client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_token();
}
const ::std::string& ClientHeader::client_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_token)
  return client_token_.GetNoArena();
}
void ClientHeader::set_client_token(const ::std::string& value) {
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_token)
}
#if LANG_CXX11
void ClientHeader::set_client_token(::std::string&& value) {
  set_has_client_token();
  client_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientHeader.client_token)
}
#endif
void ClientHeader::set_client_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.client_token)
}
void ClientHeader::set_client_token(const void* value, size_t size) {
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.client_token)
}
::std::string* ClientHeader::mutable_client_token() {
  set_has_client_token();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.client_token)
  return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientHeader::release_client_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.client_token)
  clear_has_client_token();
  return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientHeader::set_allocated_client_token(::std::string* client_token) {
  if (client_token != NULL) {
    set_has_client_token();
  } else {
    clear_has_client_token();
  }
  client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.client_token)
}

// optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
bool ClientHeader::has_registration_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ClientHeader::set_has_registration_summary() {
  _has_bits_[0] |= 0x00000008u;
}
void ClientHeader::clear_has_registration_summary() {
  _has_bits_[0] &= ~0x00000008u;
}
void ClientHeader::clear_registration_summary() {
  if (registration_summary_ != NULL) registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
  clear_has_registration_summary();
}
const ::ipc::invalidation::RegistrationSummary& ClientHeader::registration_summary() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.registration_summary)
  return registration_summary_ != NULL ? *registration_summary_
                         : *::ipc::invalidation::RegistrationSummary::internal_default_instance();
}
::ipc::invalidation::RegistrationSummary* ClientHeader::mutable_registration_summary() {
  set_has_registration_summary();
  if (registration_summary_ == NULL) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.registration_summary)
  return registration_summary_;
}
::ipc::invalidation::RegistrationSummary* ClientHeader::release_registration_summary() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.registration_summary)
  clear_has_registration_summary();
  ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
  registration_summary_ = NULL;
  return temp;
}
void ClientHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary) {
  delete registration_summary_;
  registration_summary_ = registration_summary;
  if (registration_summary) {
    set_has_registration_summary();
  } else {
    clear_has_registration_summary();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.registration_summary)
}

// optional int64 client_time_ms = 4;
bool ClientHeader::has_client_time_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ClientHeader::set_has_client_time_ms() {
  _has_bits_[0] |= 0x00000010u;
}
void ClientHeader::clear_has_client_time_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
void ClientHeader::clear_client_time_ms() {
  client_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_client_time_ms();
}
::google::protobuf::int64 ClientHeader::client_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_time_ms)
  return client_time_ms_;
}
void ClientHeader::set_client_time_ms(::google::protobuf::int64 value) {
  set_has_client_time_ms();
  client_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_time_ms)
}

// optional int64 max_known_server_time_ms = 5;
bool ClientHeader::has_max_known_server_time_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ClientHeader::set_has_max_known_server_time_ms() {
  _has_bits_[0] |= 0x00000020u;
}
void ClientHeader::clear_has_max_known_server_time_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
void ClientHeader::clear_max_known_server_time_ms() {
  max_known_server_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_max_known_server_time_ms();
}
::google::protobuf::int64 ClientHeader::max_known_server_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.max_known_server_time_ms)
  return max_known_server_time_ms_;
}
void ClientHeader::set_max_known_server_time_ms(::google::protobuf::int64 value) {
  set_has_max_known_server_time_ms();
  max_known_server_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.max_known_server_time_ms)
}

// optional string message_id = 6;
bool ClientHeader::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientHeader::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientHeader::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientHeader::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_id();
}
const ::std::string& ClientHeader::message_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.message_id)
  return message_id_.GetNoArena();
}
void ClientHeader::set_message_id(const ::std::string& value) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.message_id)
}
#if LANG_CXX11
void ClientHeader::set_message_id(::std::string&& value) {
  set_has_message_id();
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ClientHeader.message_id)
}
#endif
void ClientHeader::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ClientHeader.message_id)
}
void ClientHeader::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ClientHeader.message_id)
}
::std::string* ClientHeader::mutable_message_id() {
  set_has_message_id();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientHeader.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ClientHeader::release_message_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientHeader.message_id)
  clear_has_message_id();
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ClientHeader::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientHeader.message_id)
}

// optional int32 client_type = 7;
bool ClientHeader::has_client_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ClientHeader::set_has_client_type() {
  _has_bits_[0] |= 0x00000040u;
}
void ClientHeader::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000040u;
}
void ClientHeader::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
::google::protobuf::int32 ClientHeader::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientHeader.client_type)
  return client_type_;
}
void ClientHeader::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientHeader.client_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientToServerMessage::kHeaderFieldNumber;
const int ClientToServerMessage::kInitializeMessageFieldNumber;
const int ClientToServerMessage::kRegistrationMessageFieldNumber;
const int ClientToServerMessage::kRegistrationSyncMessageFieldNumber;
const int ClientToServerMessage::kInvalidationAckMessageFieldNumber;
const int ClientToServerMessage::kInfoMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientToServerMessage::ClientToServerMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientToServerMessage)
}
ClientToServerMessage::ClientToServerMessage(const ClientToServerMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::ipc::invalidation::ClientHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_initialize_message()) {
    initialize_message_ = new ::ipc::invalidation::InitializeMessage(*from.initialize_message_);
  } else {
    initialize_message_ = NULL;
  }
  if (from.has_registration_message()) {
    registration_message_ = new ::ipc::invalidation::RegistrationMessage(*from.registration_message_);
  } else {
    registration_message_ = NULL;
  }
  if (from.has_registration_sync_message()) {
    registration_sync_message_ = new ::ipc::invalidation::RegistrationSyncMessage(*from.registration_sync_message_);
  } else {
    registration_sync_message_ = NULL;
  }
  if (from.has_invalidation_ack_message()) {
    invalidation_ack_message_ = new ::ipc::invalidation::InvalidationMessage(*from.invalidation_ack_message_);
  } else {
    invalidation_ack_message_ = NULL;
  }
  if (from.has_info_message()) {
    info_message_ = new ::ipc::invalidation::InfoMessage(*from.info_message_);
  } else {
    info_message_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientToServerMessage)
}

void ClientToServerMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&info_message_) -
      reinterpret_cast<char*>(&header_)) + sizeof(info_message_));
}

ClientToServerMessage::~ClientToServerMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientToServerMessage)
  SharedDtor();
}

void ClientToServerMessage::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete initialize_message_;
  }
  if (this != internal_default_instance()) {
    delete registration_message_;
  }
  if (this != internal_default_instance()) {
    delete registration_sync_message_;
  }
  if (this != internal_default_instance()) {
    delete invalidation_ack_message_;
  }
  if (this != internal_default_instance()) {
    delete info_message_;
  }
}

void ClientToServerMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientToServerMessage& ClientToServerMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClientToServerMessage* ClientToServerMessage::New(::google::protobuf::Arena* arena) const {
  ClientToServerMessage* n = new ClientToServerMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientToServerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientToServerMessage)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_header()) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->::ipc::invalidation::ClientHeader::Clear();
    }
    if (has_initialize_message()) {
      GOOGLE_DCHECK(initialize_message_ != NULL);
      initialize_message_->::ipc::invalidation::InitializeMessage::Clear();
    }
    if (has_registration_message()) {
      GOOGLE_DCHECK(registration_message_ != NULL);
      registration_message_->::ipc::invalidation::RegistrationMessage::Clear();
    }
    if (has_registration_sync_message()) {
      GOOGLE_DCHECK(registration_sync_message_ != NULL);
      registration_sync_message_->::ipc::invalidation::RegistrationSyncMessage::Clear();
    }
    if (has_invalidation_ack_message()) {
      GOOGLE_DCHECK(invalidation_ack_message_ != NULL);
      invalidation_ack_message_->::ipc::invalidation::InvalidationMessage::Clear();
    }
    if (has_info_message()) {
      GOOGLE_DCHECK(info_message_ != NULL);
      info_message_->::ipc::invalidation::InfoMessage::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClientToServerMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientToServerMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ClientHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_initialize_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_sync_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invalidation_ack_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InfoMessage info_message = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientToServerMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientToServerMessage)
  return false;
#undef DO_
}

void ClientToServerMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientToServerMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ClientHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->header_, output);
  }

  // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->initialize_message_, output);
  }

  // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->registration_message_, output);
  }

  // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->registration_sync_message_, output);
  }

  // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->invalidation_ack_message_, output);
  }

  // optional .ipc.invalidation.InfoMessage info_message = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->info_message_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientToServerMessage)
}

size_t ClientToServerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientToServerMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 63u) {
    // optional .ipc.invalidation.ClientHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .ipc.invalidation.InitializeMessage initialize_message = 2;
    if (has_initialize_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->initialize_message_);
    }

    // optional .ipc.invalidation.RegistrationMessage registration_message = 3;
    if (has_registration_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_message_);
    }

    // optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
    if (has_registration_sync_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_sync_message_);
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
    if (has_invalidation_ack_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->invalidation_ack_message_);
    }

    // optional .ipc.invalidation.InfoMessage info_message = 6;
    if (has_info_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->info_message_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientToServerMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientToServerMessage*>(&from));
}

void ClientToServerMessage::MergeFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientToServerMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::ipc::invalidation::ClientHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_initialize_message()->::ipc::invalidation::InitializeMessage::MergeFrom(from.initialize_message());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_registration_message()->::ipc::invalidation::RegistrationMessage::MergeFrom(from.registration_message());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_sync_message()->::ipc::invalidation::RegistrationSyncMessage::MergeFrom(from.registration_sync_message());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_invalidation_ack_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_ack_message());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_info_message()->::ipc::invalidation::InfoMessage::MergeFrom(from.info_message());
    }
  }
}

void ClientToServerMessage::CopyFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientToServerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToServerMessage::IsInitialized() const {
  return true;
}

void ClientToServerMessage::Swap(ClientToServerMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientToServerMessage::InternalSwap(ClientToServerMessage* other) {
  std::swap(header_, other->header_);
  std::swap(initialize_message_, other->initialize_message_);
  std::swap(registration_message_, other->registration_message_);
  std::swap(registration_sync_message_, other->registration_sync_message_);
  std::swap(invalidation_ack_message_, other->invalidation_ack_message_);
  std::swap(info_message_, other->info_message_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientToServerMessage::GetTypeName() const {
  return "ipc.invalidation.ClientToServerMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientToServerMessage

// optional .ipc.invalidation.ClientHeader header = 1;
bool ClientToServerMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientToServerMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientToServerMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientToServerMessage::clear_header() {
  if (header_ != NULL) header_->::ipc::invalidation::ClientHeader::Clear();
  clear_has_header();
}
const ::ipc::invalidation::ClientHeader& ClientToServerMessage::header() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.header)
  return header_ != NULL ? *header_
                         : *::ipc::invalidation::ClientHeader::internal_default_instance();
}
::ipc::invalidation::ClientHeader* ClientToServerMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ipc::invalidation::ClientHeader;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.header)
  return header_;
}
::ipc::invalidation::ClientHeader* ClientToServerMessage::release_header() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.header)
  clear_has_header();
  ::ipc::invalidation::ClientHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_header(::ipc::invalidation::ClientHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.header)
}

// optional .ipc.invalidation.InitializeMessage initialize_message = 2;
bool ClientToServerMessage::has_initialize_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientToServerMessage::set_has_initialize_message() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientToServerMessage::clear_has_initialize_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientToServerMessage::clear_initialize_message() {
  if (initialize_message_ != NULL) initialize_message_->::ipc::invalidation::InitializeMessage::Clear();
  clear_has_initialize_message();
}
const ::ipc::invalidation::InitializeMessage& ClientToServerMessage::initialize_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.initialize_message)
  return initialize_message_ != NULL ? *initialize_message_
                         : *::ipc::invalidation::InitializeMessage::internal_default_instance();
}
::ipc::invalidation::InitializeMessage* ClientToServerMessage::mutable_initialize_message() {
  set_has_initialize_message();
  if (initialize_message_ == NULL) {
    initialize_message_ = new ::ipc::invalidation::InitializeMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.initialize_message)
  return initialize_message_;
}
::ipc::invalidation::InitializeMessage* ClientToServerMessage::release_initialize_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.initialize_message)
  clear_has_initialize_message();
  ::ipc::invalidation::InitializeMessage* temp = initialize_message_;
  initialize_message_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_initialize_message(::ipc::invalidation::InitializeMessage* initialize_message) {
  delete initialize_message_;
  initialize_message_ = initialize_message;
  if (initialize_message) {
    set_has_initialize_message();
  } else {
    clear_has_initialize_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.initialize_message)
}

// optional .ipc.invalidation.RegistrationMessage registration_message = 3;
bool ClientToServerMessage::has_registration_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ClientToServerMessage::set_has_registration_message() {
  _has_bits_[0] |= 0x00000004u;
}
void ClientToServerMessage::clear_has_registration_message() {
  _has_bits_[0] &= ~0x00000004u;
}
void ClientToServerMessage::clear_registration_message() {
  if (registration_message_ != NULL) registration_message_->::ipc::invalidation::RegistrationMessage::Clear();
  clear_has_registration_message();
}
const ::ipc::invalidation::RegistrationMessage& ClientToServerMessage::registration_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_message)
  return registration_message_ != NULL ? *registration_message_
                         : *::ipc::invalidation::RegistrationMessage::internal_default_instance();
}
::ipc::invalidation::RegistrationMessage* ClientToServerMessage::mutable_registration_message() {
  set_has_registration_message();
  if (registration_message_ == NULL) {
    registration_message_ = new ::ipc::invalidation::RegistrationMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_message)
  return registration_message_;
}
::ipc::invalidation::RegistrationMessage* ClientToServerMessage::release_registration_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_message)
  clear_has_registration_message();
  ::ipc::invalidation::RegistrationMessage* temp = registration_message_;
  registration_message_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_registration_message(::ipc::invalidation::RegistrationMessage* registration_message) {
  delete registration_message_;
  registration_message_ = registration_message;
  if (registration_message) {
    set_has_registration_message();
  } else {
    clear_has_registration_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_message)
}

// optional .ipc.invalidation.RegistrationSyncMessage registration_sync_message = 4;
bool ClientToServerMessage::has_registration_sync_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ClientToServerMessage::set_has_registration_sync_message() {
  _has_bits_[0] |= 0x00000008u;
}
void ClientToServerMessage::clear_has_registration_sync_message() {
  _has_bits_[0] &= ~0x00000008u;
}
void ClientToServerMessage::clear_registration_sync_message() {
  if (registration_sync_message_ != NULL) registration_sync_message_->::ipc::invalidation::RegistrationSyncMessage::Clear();
  clear_has_registration_sync_message();
}
const ::ipc::invalidation::RegistrationSyncMessage& ClientToServerMessage::registration_sync_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  return registration_sync_message_ != NULL ? *registration_sync_message_
                         : *::ipc::invalidation::RegistrationSyncMessage::internal_default_instance();
}
::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::mutable_registration_sync_message() {
  set_has_registration_sync_message();
  if (registration_sync_message_ == NULL) {
    registration_sync_message_ = new ::ipc::invalidation::RegistrationSyncMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  return registration_sync_message_;
}
::ipc::invalidation::RegistrationSyncMessage* ClientToServerMessage::release_registration_sync_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.registration_sync_message)
  clear_has_registration_sync_message();
  ::ipc::invalidation::RegistrationSyncMessage* temp = registration_sync_message_;
  registration_sync_message_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_registration_sync_message(::ipc::invalidation::RegistrationSyncMessage* registration_sync_message) {
  delete registration_sync_message_;
  registration_sync_message_ = registration_sync_message;
  if (registration_sync_message) {
    set_has_registration_sync_message();
  } else {
    clear_has_registration_sync_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.registration_sync_message)
}

// optional .ipc.invalidation.InvalidationMessage invalidation_ack_message = 5;
bool ClientToServerMessage::has_invalidation_ack_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ClientToServerMessage::set_has_invalidation_ack_message() {
  _has_bits_[0] |= 0x00000010u;
}
void ClientToServerMessage::clear_has_invalidation_ack_message() {
  _has_bits_[0] &= ~0x00000010u;
}
void ClientToServerMessage::clear_invalidation_ack_message() {
  if (invalidation_ack_message_ != NULL) invalidation_ack_message_->::ipc::invalidation::InvalidationMessage::Clear();
  clear_has_invalidation_ack_message();
}
const ::ipc::invalidation::InvalidationMessage& ClientToServerMessage::invalidation_ack_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  return invalidation_ack_message_ != NULL ? *invalidation_ack_message_
                         : *::ipc::invalidation::InvalidationMessage::internal_default_instance();
}
::ipc::invalidation::InvalidationMessage* ClientToServerMessage::mutable_invalidation_ack_message() {
  set_has_invalidation_ack_message();
  if (invalidation_ack_message_ == NULL) {
    invalidation_ack_message_ = new ::ipc::invalidation::InvalidationMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  return invalidation_ack_message_;
}
::ipc::invalidation::InvalidationMessage* ClientToServerMessage::release_invalidation_ack_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
  clear_has_invalidation_ack_message();
  ::ipc::invalidation::InvalidationMessage* temp = invalidation_ack_message_;
  invalidation_ack_message_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_invalidation_ack_message(::ipc::invalidation::InvalidationMessage* invalidation_ack_message) {
  delete invalidation_ack_message_;
  invalidation_ack_message_ = invalidation_ack_message;
  if (invalidation_ack_message) {
    set_has_invalidation_ack_message();
  } else {
    clear_has_invalidation_ack_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.invalidation_ack_message)
}

// optional .ipc.invalidation.InfoMessage info_message = 6;
bool ClientToServerMessage::has_info_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ClientToServerMessage::set_has_info_message() {
  _has_bits_[0] |= 0x00000020u;
}
void ClientToServerMessage::clear_has_info_message() {
  _has_bits_[0] &= ~0x00000020u;
}
void ClientToServerMessage::clear_info_message() {
  if (info_message_ != NULL) info_message_->::ipc::invalidation::InfoMessage::Clear();
  clear_has_info_message();
}
const ::ipc::invalidation::InfoMessage& ClientToServerMessage::info_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientToServerMessage.info_message)
  return info_message_ != NULL ? *info_message_
                         : *::ipc::invalidation::InfoMessage::internal_default_instance();
}
::ipc::invalidation::InfoMessage* ClientToServerMessage::mutable_info_message() {
  set_has_info_message();
  if (info_message_ == NULL) {
    info_message_ = new ::ipc::invalidation::InfoMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientToServerMessage.info_message)
  return info_message_;
}
::ipc::invalidation::InfoMessage* ClientToServerMessage::release_info_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientToServerMessage.info_message)
  clear_has_info_message();
  ::ipc::invalidation::InfoMessage* temp = info_message_;
  info_message_ = NULL;
  return temp;
}
void ClientToServerMessage::set_allocated_info_message(::ipc::invalidation::InfoMessage* info_message) {
  delete info_message_;
  info_message_ = info_message;
  if (info_message) {
    set_has_info_message();
  } else {
    clear_has_info_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientToServerMessage.info_message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitializeMessage::kClientTypeFieldNumber;
const int InitializeMessage::kNonceFieldNumber;
const int InitializeMessage::kApplicationClientIdFieldNumber;
const int InitializeMessage::kDigestSerializationTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitializeMessage::InitializeMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InitializeMessage)
}
InitializeMessage::InitializeMessage(const InitializeMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_nonce()) {
    nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
  }
  if (from.has_application_client_id()) {
    application_client_id_ = new ::ipc::invalidation::ApplicationClientIdP(*from.application_client_id_);
  } else {
    application_client_id_ = NULL;
  }
  ::memcpy(&client_type_, &from.client_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&digest_serialization_type_) -
    reinterpret_cast<char*>(&client_type_)) + sizeof(digest_serialization_type_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InitializeMessage)
}

void InitializeMessage::SharedCtor() {
  _cached_size_ = 0;
  nonce_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&application_client_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&client_type_) -
      reinterpret_cast<char*>(&application_client_id_)) + sizeof(client_type_));
  digest_serialization_type_ = 1;
}

InitializeMessage::~InitializeMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InitializeMessage)
  SharedDtor();
}

void InitializeMessage::SharedDtor() {
  nonce_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete application_client_id_;
  }
}

void InitializeMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InitializeMessage& InitializeMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

InitializeMessage* InitializeMessage::New(::google::protobuf::Arena* arena) const {
  InitializeMessage* n = new InitializeMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitializeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InitializeMessage)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_nonce()) {
      GOOGLE_DCHECK(!nonce_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*nonce_.UnsafeRawStringPointer())->clear();
    }
    if (has_application_client_id()) {
      GOOGLE_DCHECK(application_client_id_ != NULL);
      application_client_id_->::ipc::invalidation::ApplicationClientIdP::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 12u) {
    client_type_ = 0;
    digest_serialization_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InitializeMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InitializeMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 client_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_client_type();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &client_type_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes nonce = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_application_client_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value)) {
            set_digest_serialization_type(static_cast< ::ipc::invalidation::InitializeMessage_DigestSerializationType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InitializeMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InitializeMessage)
  return false;
#undef DO_
}

void InitializeMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InitializeMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 client_type = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->client_type(), output);
  }

  // optional bytes nonce = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->nonce(), output);
  }

  // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->application_client_id_, output);
  }

  // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->digest_serialization_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InitializeMessage)
}

size_t InitializeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InitializeMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes nonce = 2;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

    // optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
    if (has_application_client_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->application_client_id_);
    }

    // optional int32 client_type = 1;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->client_type());
    }

    // optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
    if (has_digest_serialization_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->digest_serialization_type());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitializeMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InitializeMessage*>(&from));
}

void InitializeMessage::MergeFrom(const InitializeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InitializeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_nonce();
      nonce_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nonce_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_application_client_id()->::ipc::invalidation::ApplicationClientIdP::MergeFrom(from.application_client_id());
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      digest_serialization_type_ = from.digest_serialization_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InitializeMessage::CopyFrom(const InitializeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InitializeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeMessage::IsInitialized() const {
  return true;
}

void InitializeMessage::Swap(InitializeMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitializeMessage::InternalSwap(InitializeMessage* other) {
  nonce_.Swap(&other->nonce_);
  std::swap(application_client_id_, other->application_client_id_);
  std::swap(client_type_, other->client_type_);
  std::swap(digest_serialization_type_, other->digest_serialization_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InitializeMessage::GetTypeName() const {
  return "ipc.invalidation.InitializeMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeMessage

// optional int32 client_type = 1;
bool InitializeMessage::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InitializeMessage::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
void InitializeMessage::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
void InitializeMessage::clear_client_type() {
  client_type_ = 0;
  clear_has_client_type();
}
::google::protobuf::int32 InitializeMessage::client_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.client_type)
  return client_type_;
}
void InitializeMessage::set_client_type(::google::protobuf::int32 value) {
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.client_type)
}

// optional bytes nonce = 2;
bool InitializeMessage::has_nonce() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InitializeMessage::set_has_nonce() {
  _has_bits_[0] |= 0x00000001u;
}
void InitializeMessage::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000001u;
}
void InitializeMessage::clear_nonce() {
  nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nonce();
}
const ::std::string& InitializeMessage::nonce() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.nonce)
  return nonce_.GetNoArena();
}
void InitializeMessage::set_nonce(const ::std::string& value) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.nonce)
}
#if LANG_CXX11
void InitializeMessage::set_nonce(::std::string&& value) {
  set_has_nonce();
  nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.InitializeMessage.nonce)
}
#endif
void InitializeMessage::set_nonce(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.InitializeMessage.nonce)
}
void InitializeMessage::set_nonce(const void* value, size_t size) {
  set_has_nonce();
  nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.InitializeMessage.nonce)
}
::std::string* InitializeMessage::mutable_nonce() {
  set_has_nonce();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.nonce)
  return nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* InitializeMessage::release_nonce() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.nonce)
  clear_has_nonce();
  return nonce_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void InitializeMessage::set_allocated_nonce(::std::string* nonce) {
  if (nonce != NULL) {
    set_has_nonce();
  } else {
    clear_has_nonce();
  }
  nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nonce);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.nonce)
}

// optional .ipc.invalidation.ApplicationClientIdP application_client_id = 3;
bool InitializeMessage::has_application_client_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InitializeMessage::set_has_application_client_id() {
  _has_bits_[0] |= 0x00000002u;
}
void InitializeMessage::clear_has_application_client_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void InitializeMessage::clear_application_client_id() {
  if (application_client_id_ != NULL) application_client_id_->::ipc::invalidation::ApplicationClientIdP::Clear();
  clear_has_application_client_id();
}
const ::ipc::invalidation::ApplicationClientIdP& InitializeMessage::application_client_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.application_client_id)
  return application_client_id_ != NULL ? *application_client_id_
                         : *::ipc::invalidation::ApplicationClientIdP::internal_default_instance();
}
::ipc::invalidation::ApplicationClientIdP* InitializeMessage::mutable_application_client_id() {
  set_has_application_client_id();
  if (application_client_id_ == NULL) {
    application_client_id_ = new ::ipc::invalidation::ApplicationClientIdP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InitializeMessage.application_client_id)
  return application_client_id_;
}
::ipc::invalidation::ApplicationClientIdP* InitializeMessage::release_application_client_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InitializeMessage.application_client_id)
  clear_has_application_client_id();
  ::ipc::invalidation::ApplicationClientIdP* temp = application_client_id_;
  application_client_id_ = NULL;
  return temp;
}
void InitializeMessage::set_allocated_application_client_id(::ipc::invalidation::ApplicationClientIdP* application_client_id) {
  delete application_client_id_;
  application_client_id_ = application_client_id;
  if (application_client_id) {
    set_has_application_client_id();
  } else {
    clear_has_application_client_id();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InitializeMessage.application_client_id)
}

// optional .ipc.invalidation.InitializeMessage.DigestSerializationType digest_serialization_type = 4;
bool InitializeMessage::has_digest_serialization_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InitializeMessage::set_has_digest_serialization_type() {
  _has_bits_[0] |= 0x00000008u;
}
void InitializeMessage::clear_has_digest_serialization_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void InitializeMessage::clear_digest_serialization_type() {
  digest_serialization_type_ = 1;
  clear_has_digest_serialization_type();
}
::ipc::invalidation::InitializeMessage_DigestSerializationType InitializeMessage::digest_serialization_type() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InitializeMessage.digest_serialization_type)
  return static_cast< ::ipc::invalidation::InitializeMessage_DigestSerializationType >(digest_serialization_type_);
}
void InitializeMessage::set_digest_serialization_type(::ipc::invalidation::InitializeMessage_DigestSerializationType value) {
  assert(::ipc::invalidation::InitializeMessage_DigestSerializationType_IsValid(value));
  set_has_digest_serialization_type();
  digest_serialization_type_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InitializeMessage.digest_serialization_type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationMessage::kRegistrationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationMessage::RegistrationMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationMessage)
}
RegistrationMessage::RegistrationMessage(const RegistrationMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      registration_(from.registration_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationMessage)
}

void RegistrationMessage::SharedCtor() {
  _cached_size_ = 0;
}

RegistrationMessage::~RegistrationMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationMessage)
  SharedDtor();
}

void RegistrationMessage::SharedDtor() {
}

void RegistrationMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationMessage& RegistrationMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationMessage* RegistrationMessage::New(::google::protobuf::Arena* arena) const {
  RegistrationMessage* n = new RegistrationMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationMessage)
  registration_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationP registration = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_registration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationMessage)
  return false;
#undef DO_
}

void RegistrationMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationP registration = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registration_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->registration(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationMessage)
}

size_t RegistrationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.RegistrationP registration = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registration_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->registration(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationMessage*>(&from));
}

void RegistrationMessage::MergeFrom(const RegistrationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registration_.MergeFrom(from.registration_);
}

void RegistrationMessage::CopyFrom(const RegistrationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationMessage::IsInitialized() const {
  return true;
}

void RegistrationMessage::Swap(RegistrationMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationMessage::InternalSwap(RegistrationMessage* other) {
  registration_.InternalSwap(&other->registration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationMessage

// repeated .ipc.invalidation.RegistrationP registration = 1;
int RegistrationMessage::registration_size() const {
  return registration_.size();
}
void RegistrationMessage::clear_registration() {
  registration_.Clear();
}
const ::ipc::invalidation::RegistrationP& RegistrationMessage::registration(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Get(index);
}
::ipc::invalidation::RegistrationP* RegistrationMessage::mutable_registration(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Mutable(index);
}
::ipc::invalidation::RegistrationP* RegistrationMessage::add_registration() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationMessage.registration)
  return registration_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationP >*
RegistrationMessage::mutable_registration() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationMessage.registration)
  return &registration_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationP >&
RegistrationMessage::registration() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationMessage.registration)
  return registration_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationSyncMessage::kSubtreeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationSyncMessage::RegistrationSyncMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncMessage)
}
RegistrationSyncMessage::RegistrationSyncMessage(const RegistrationSyncMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      subtree_(from.subtree_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncMessage)
}

void RegistrationSyncMessage::SharedCtor() {
  _cached_size_ = 0;
}

RegistrationSyncMessage::~RegistrationSyncMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncMessage)
  SharedDtor();
}

void RegistrationSyncMessage::SharedDtor() {
}

void RegistrationSyncMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationSyncMessage& RegistrationSyncMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationSyncMessage* RegistrationSyncMessage::New(::google::protobuf::Arena* arena) const {
  RegistrationSyncMessage* n = new RegistrationSyncMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationSyncMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncMessage)
  subtree_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationSyncMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_subtree()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncMessage)
  return false;
#undef DO_
}

void RegistrationSyncMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->subtree_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->subtree(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncMessage)
}

size_t RegistrationSyncMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->subtree_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->subtree(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationSyncMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationSyncMessage*>(&from));
}

void RegistrationSyncMessage::MergeFrom(const RegistrationSyncMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  subtree_.MergeFrom(from.subtree_);
}

void RegistrationSyncMessage::CopyFrom(const RegistrationSyncMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSyncMessage::IsInitialized() const {
  return true;
}

void RegistrationSyncMessage::Swap(RegistrationSyncMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationSyncMessage::InternalSwap(RegistrationSyncMessage* other) {
  subtree_.InternalSwap(&other->subtree_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationSyncMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationSyncMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationSyncMessage

// repeated .ipc.invalidation.RegistrationSubtree subtree = 1;
int RegistrationSyncMessage::subtree_size() const {
  return subtree_.size();
}
void RegistrationSyncMessage::clear_subtree() {
  subtree_.Clear();
}
const ::ipc::invalidation::RegistrationSubtree& RegistrationSyncMessage::subtree(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Get(index);
}
::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::mutable_subtree(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Mutable(index);
}
::ipc::invalidation::RegistrationSubtree* RegistrationSyncMessage::add_subtree() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >*
RegistrationSyncMessage::mutable_subtree() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSyncMessage.subtree)
  return &subtree_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationSubtree >&
RegistrationSyncMessage::subtree() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSyncMessage.subtree)
  return subtree_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationSubtree::kRegisteredObjectFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationSubtree::RegistrationSubtree()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSubtree)
}
RegistrationSubtree::RegistrationSubtree(const RegistrationSubtree& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      registered_object_(from.registered_object_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSubtree)
}

void RegistrationSubtree::SharedCtor() {
  _cached_size_ = 0;
}

RegistrationSubtree::~RegistrationSubtree() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSubtree)
  SharedDtor();
}

void RegistrationSubtree::SharedDtor() {
}

void RegistrationSubtree::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationSubtree& RegistrationSubtree::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationSubtree* RegistrationSubtree::New(::google::protobuf::Arena* arena) const {
  RegistrationSubtree* n = new RegistrationSubtree;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationSubtree::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSubtree)
  registered_object_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationSubtree::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSubtree)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_registered_object()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSubtree)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSubtree)
  return false;
#undef DO_
}

void RegistrationSubtree::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSubtree)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registered_object_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->registered_object(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSubtree)
}

size_t RegistrationSubtree::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSubtree)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.ObjectIdP registered_object = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registered_object_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->registered_object(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationSubtree::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationSubtree*>(&from));
}

void RegistrationSubtree::MergeFrom(const RegistrationSubtree& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSubtree)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registered_object_.MergeFrom(from.registered_object_);
}

void RegistrationSubtree::CopyFrom(const RegistrationSubtree& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSubtree)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSubtree::IsInitialized() const {
  return true;
}

void RegistrationSubtree::Swap(RegistrationSubtree* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationSubtree::InternalSwap(RegistrationSubtree* other) {
  registered_object_.InternalSwap(&other->registered_object_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationSubtree::GetTypeName() const {
  return "ipc.invalidation.RegistrationSubtree";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationSubtree

// repeated .ipc.invalidation.ObjectIdP registered_object = 1;
int RegistrationSubtree::registered_object_size() const {
  return registered_object_.size();
}
void RegistrationSubtree::clear_registered_object() {
  registered_object_.Clear();
}
const ::ipc::invalidation::ObjectIdP& RegistrationSubtree::registered_object(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Get(index);
}
::ipc::invalidation::ObjectIdP* RegistrationSubtree::mutable_registered_object(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Mutable(index);
}
::ipc::invalidation::ObjectIdP* RegistrationSubtree::add_registered_object() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >*
RegistrationSubtree::mutable_registered_object() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationSubtree.registered_object)
  return &registered_object_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::ObjectIdP >&
RegistrationSubtree::registered_object() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationSubtree.registered_object)
  return registered_object_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InfoMessage::kClientVersionFieldNumber;
const int InfoMessage::kConfigParameterFieldNumber;
const int InfoMessage::kPerformanceCounterFieldNumber;
const int InfoMessage::kServerRegistrationSummaryRequestedFieldNumber;
const int InfoMessage::kClientConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InfoMessage::InfoMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InfoMessage)
}
InfoMessage::InfoMessage(const InfoMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      config_parameter_(from.config_parameter_),
      performance_counter_(from.performance_counter_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_client_version()) {
    client_version_ = new ::ipc::invalidation::ClientVersion(*from.client_version_);
  } else {
    client_version_ = NULL;
  }
  if (from.has_client_config()) {
    client_config_ = new ::ipc::invalidation::ClientConfigP(*from.client_config_);
  } else {
    client_config_ = NULL;
  }
  server_registration_summary_requested_ = from.server_registration_summary_requested_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoMessage)
}

void InfoMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&client_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&server_registration_summary_requested_) -
      reinterpret_cast<char*>(&client_version_)) + sizeof(server_registration_summary_requested_));
}

InfoMessage::~InfoMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InfoMessage)
  SharedDtor();
}

void InfoMessage::SharedDtor() {
  if (this != internal_default_instance()) {
    delete client_version_;
  }
  if (this != internal_default_instance()) {
    delete client_config_;
  }
}

void InfoMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InfoMessage& InfoMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

InfoMessage* InfoMessage::New(::google::protobuf::Arena* arena) const {
  InfoMessage* n = new InfoMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InfoMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoMessage)
  config_parameter_.Clear();
  performance_counter_.Clear();
  if (_has_bits_[0 / 32] & 3u) {
    if (has_client_version()) {
      GOOGLE_DCHECK(client_version_ != NULL);
      client_version_->::ipc::invalidation::ClientVersion::Clear();
    }
    if (has_client_config()) {
      GOOGLE_DCHECK(client_config_ != NULL);
      client_config_->::ipc::invalidation::ClientConfigP::Clear();
    }
  }
  server_registration_summary_requested_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InfoMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ClientVersion client_version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_config_parameter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_performance_counter()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool server_registration_summary_requested = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_server_registration_summary_requested();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &server_registration_summary_requested_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ClientConfigP client_config = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_client_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoMessage)
  return false;
#undef DO_
}

void InfoMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ClientVersion client_version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->client_version_, output);
  }

  // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->config_parameter_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->config_parameter(static_cast<int>(i)), output);
  }

  // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->performance_counter_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->performance_counter(static_cast<int>(i)), output);
  }

  // optional bool server_registration_summary_requested = 4;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->server_registration_summary_requested(), output);
  }

  // optional .ipc.invalidation.ClientConfigP client_config = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->client_config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoMessage)
}

size_t InfoMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->config_parameter_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->config_parameter(static_cast<int>(i)));
    }
  }

  // repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->performance_counter_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->performance_counter(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 7u) {
    // optional .ipc.invalidation.ClientVersion client_version = 1;
    if (has_client_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_version_);
    }

    // optional .ipc.invalidation.ClientConfigP client_config = 5;
    if (has_client_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->client_config_);
    }

    // optional bool server_registration_summary_requested = 4;
    if (has_server_registration_summary_requested()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InfoMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InfoMessage*>(&from));
}

void InfoMessage::MergeFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  config_parameter_.MergeFrom(from.config_parameter_);
  performance_counter_.MergeFrom(from.performance_counter_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_client_version()->::ipc::invalidation::ClientVersion::MergeFrom(from.client_version());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_client_config()->::ipc::invalidation::ClientConfigP::MergeFrom(from.client_config());
    }
    if (cached_has_bits & 0x00000004u) {
      server_registration_summary_requested_ = from.server_registration_summary_requested_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void InfoMessage::CopyFrom(const InfoMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoMessage::IsInitialized() const {
  return true;
}

void InfoMessage::Swap(InfoMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InfoMessage::InternalSwap(InfoMessage* other) {
  config_parameter_.InternalSwap(&other->config_parameter_);
  performance_counter_.InternalSwap(&other->performance_counter_);
  std::swap(client_version_, other->client_version_);
  std::swap(client_config_, other->client_config_);
  std::swap(server_registration_summary_requested_, other->server_registration_summary_requested_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InfoMessage::GetTypeName() const {
  return "ipc.invalidation.InfoMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InfoMessage

// optional .ipc.invalidation.ClientVersion client_version = 1;
bool InfoMessage::has_client_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InfoMessage::set_has_client_version() {
  _has_bits_[0] |= 0x00000001u;
}
void InfoMessage::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void InfoMessage::clear_client_version() {
  if (client_version_ != NULL) client_version_->::ipc::invalidation::ClientVersion::Clear();
  clear_has_client_version();
}
const ::ipc::invalidation::ClientVersion& InfoMessage::client_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_version)
  return client_version_ != NULL ? *client_version_
                         : *::ipc::invalidation::ClientVersion::internal_default_instance();
}
::ipc::invalidation::ClientVersion* InfoMessage::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == NULL) {
    client_version_ = new ::ipc::invalidation::ClientVersion;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_version)
  return client_version_;
}
::ipc::invalidation::ClientVersion* InfoMessage::release_client_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_version)
  clear_has_client_version();
  ::ipc::invalidation::ClientVersion* temp = client_version_;
  client_version_ = NULL;
  return temp;
}
void InfoMessage::set_allocated_client_version(::ipc::invalidation::ClientVersion* client_version) {
  delete client_version_;
  client_version_ = client_version;
  if (client_version) {
    set_has_client_version();
  } else {
    clear_has_client_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_version)
}

// repeated .ipc.invalidation.PropertyRecord config_parameter = 2;
int InfoMessage::config_parameter_size() const {
  return config_parameter_.size();
}
void InfoMessage::clear_config_parameter() {
  config_parameter_.Clear();
}
const ::ipc::invalidation::PropertyRecord& InfoMessage::config_parameter(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Get(index);
}
::ipc::invalidation::PropertyRecord* InfoMessage::mutable_config_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Mutable(index);
}
::ipc::invalidation::PropertyRecord* InfoMessage::add_config_parameter() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
InfoMessage::mutable_config_parameter() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.config_parameter)
  return &config_parameter_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
InfoMessage::config_parameter() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.config_parameter)
  return config_parameter_;
}

// repeated .ipc.invalidation.PropertyRecord performance_counter = 3;
int InfoMessage::performance_counter_size() const {
  return performance_counter_.size();
}
void InfoMessage::clear_performance_counter() {
  performance_counter_.Clear();
}
const ::ipc::invalidation::PropertyRecord& InfoMessage::performance_counter(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Get(index);
}
::ipc::invalidation::PropertyRecord* InfoMessage::mutable_performance_counter(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Mutable(index);
}
::ipc::invalidation::PropertyRecord* InfoMessage::add_performance_counter() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >*
InfoMessage::mutable_performance_counter() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoMessage.performance_counter)
  return &performance_counter_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::PropertyRecord >&
InfoMessage::performance_counter() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoMessage.performance_counter)
  return performance_counter_;
}

// optional bool server_registration_summary_requested = 4;
bool InfoMessage::has_server_registration_summary_requested() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InfoMessage::set_has_server_registration_summary_requested() {
  _has_bits_[0] |= 0x00000004u;
}
void InfoMessage::clear_has_server_registration_summary_requested() {
  _has_bits_[0] &= ~0x00000004u;
}
void InfoMessage::clear_server_registration_summary_requested() {
  server_registration_summary_requested_ = false;
  clear_has_server_registration_summary_requested();
}
bool InfoMessage::server_registration_summary_requested() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.server_registration_summary_requested)
  return server_registration_summary_requested_;
}
void InfoMessage::set_server_registration_summary_requested(bool value) {
  set_has_server_registration_summary_requested();
  server_registration_summary_requested_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.InfoMessage.server_registration_summary_requested)
}

// optional .ipc.invalidation.ClientConfigP client_config = 5;
bool InfoMessage::has_client_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InfoMessage::set_has_client_config() {
  _has_bits_[0] |= 0x00000002u;
}
void InfoMessage::clear_has_client_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void InfoMessage::clear_client_config() {
  if (client_config_ != NULL) client_config_->::ipc::invalidation::ClientConfigP::Clear();
  clear_has_client_config();
}
const ::ipc::invalidation::ClientConfigP& InfoMessage::client_config() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoMessage.client_config)
  return client_config_ != NULL ? *client_config_
                         : *::ipc::invalidation::ClientConfigP::internal_default_instance();
}
::ipc::invalidation::ClientConfigP* InfoMessage::mutable_client_config() {
  set_has_client_config();
  if (client_config_ == NULL) {
    client_config_ = new ::ipc::invalidation::ClientConfigP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InfoMessage.client_config)
  return client_config_;
}
::ipc::invalidation::ClientConfigP* InfoMessage::release_client_config() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.InfoMessage.client_config)
  clear_has_client_config();
  ::ipc::invalidation::ClientConfigP* temp = client_config_;
  client_config_ = NULL;
  return temp;
}
void InfoMessage::set_allocated_client_config(::ipc::invalidation::ClientConfigP* client_config) {
  delete client_config_;
  client_config_ = client_config;
  if (client_config) {
    set_has_client_config();
  } else {
    clear_has_client_config();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.InfoMessage.client_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PropertyRecord::kNameFieldNumber;
const int PropertyRecord::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PropertyRecord::PropertyRecord()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.PropertyRecord)
}
PropertyRecord::PropertyRecord(const PropertyRecord& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.PropertyRecord)
}

void PropertyRecord::SharedCtor() {
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = 0;
}

PropertyRecord::~PropertyRecord() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.PropertyRecord)
  SharedDtor();
}

void PropertyRecord::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PropertyRecord::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PropertyRecord& PropertyRecord::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

PropertyRecord* PropertyRecord::New(::google::protobuf::Arena* arena) const {
  PropertyRecord* n = new PropertyRecord;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PropertyRecord::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.PropertyRecord)
  if (has_name()) {
    GOOGLE_DCHECK(!name_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*name_.UnsafeRawStringPointer())->clear();
  }
  value_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool PropertyRecord::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.PropertyRecord)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 value = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_value();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.PropertyRecord)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.PropertyRecord)
  return false;
#undef DO_
}

void PropertyRecord::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.PropertyRecord)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->value(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.PropertyRecord)
}

size_t PropertyRecord::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.PropertyRecord)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->value());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PropertyRecord::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PropertyRecord*>(&from));
}

void PropertyRecord::MergeFrom(const PropertyRecord& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.PropertyRecord)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PropertyRecord::CopyFrom(const PropertyRecord& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.PropertyRecord)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PropertyRecord::IsInitialized() const {
  return true;
}

void PropertyRecord::Swap(PropertyRecord* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PropertyRecord::InternalSwap(PropertyRecord* other) {
  name_.Swap(&other->name_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PropertyRecord::GetTypeName() const {
  return "ipc.invalidation.PropertyRecord";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PropertyRecord

// optional string name = 1;
bool PropertyRecord::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PropertyRecord::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void PropertyRecord::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void PropertyRecord::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
const ::std::string& PropertyRecord::name() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.name)
  return name_.GetNoArena();
}
void PropertyRecord::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.name)
}
#if LANG_CXX11
void PropertyRecord::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.PropertyRecord.name)
}
#endif
void PropertyRecord::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.PropertyRecord.name)
}
void PropertyRecord::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.PropertyRecord.name)
}
::std::string* PropertyRecord::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.PropertyRecord.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* PropertyRecord::release_name() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.PropertyRecord.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void PropertyRecord::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.PropertyRecord.name)
}

// optional int32 value = 2;
bool PropertyRecord::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PropertyRecord::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void PropertyRecord::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void PropertyRecord::clear_value() {
  value_ = 0;
  clear_has_value();
}
::google::protobuf::int32 PropertyRecord::value() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.PropertyRecord.value)
  return value_;
}
void PropertyRecord::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.PropertyRecord.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServerHeader::kProtocolVersionFieldNumber;
const int ServerHeader::kClientTokenFieldNumber;
const int ServerHeader::kRegistrationSummaryFieldNumber;
const int ServerHeader::kServerTimeMsFieldNumber;
const int ServerHeader::kMessageIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ServerHeader::ServerHeader()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ServerHeader)
}
ServerHeader::ServerHeader(const ServerHeader& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_client_token()) {
    client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
  }
  message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_message_id()) {
    message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
  }
  if (from.has_protocol_version()) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion(*from.protocol_version_);
  } else {
    protocol_version_ = NULL;
  }
  if (from.has_registration_summary()) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary(*from.registration_summary_);
  } else {
    registration_summary_ = NULL;
  }
  server_time_ms_ = from.server_time_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerHeader)
}

void ServerHeader::SharedCtor() {
  _cached_size_ = 0;
  client_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&protocol_version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&server_time_ms_) -
      reinterpret_cast<char*>(&protocol_version_)) + sizeof(server_time_ms_));
}

ServerHeader::~ServerHeader() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ServerHeader)
  SharedDtor();
}

void ServerHeader::SharedDtor() {
  client_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) {
    delete protocol_version_;
  }
  if (this != internal_default_instance()) {
    delete registration_summary_;
  }
}

void ServerHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerHeader& ServerHeader::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ServerHeader* ServerHeader::New(::google::protobuf::Arena* arena) const {
  ServerHeader* n = new ServerHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ServerHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerHeader)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_client_token()) {
      GOOGLE_DCHECK(!client_token_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*client_token_.UnsafeRawStringPointer())->clear();
    }
    if (has_message_id()) {
      GOOGLE_DCHECK(!message_id_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*message_id_.UnsafeRawStringPointer())->clear();
    }
    if (has_protocol_version()) {
      GOOGLE_DCHECK(protocol_version_ != NULL);
      protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
    }
    if (has_registration_summary()) {
      GOOGLE_DCHECK(registration_summary_ != NULL);
      registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
    }
  }
  server_time_ms_ = GOOGLE_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ServerHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_protocol_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes client_token = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_client_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_summary()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int64 server_time_ms = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_server_time_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &server_time_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string message_id = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerHeader)
  return false;
#undef DO_
}

void ServerHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerHeader)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->protocol_version_, output);
  }

  // optional bytes client_token = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->client_token(), output);
  }

  // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->registration_summary_, output);
  }

  // optional int64 server_time_ms = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->server_time_ms(), output);
  }

  // optional string message_id = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->message_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerHeader)
}

size_t ServerHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerHeader)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 31u) {
    // optional bytes client_token = 2;
    if (has_client_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->client_token());
    }

    // optional string message_id = 5;
    if (has_message_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message_id());
    }

    // optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
    if (has_protocol_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->protocol_version_);
    }

    // optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
    if (has_registration_summary()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_summary_);
    }

    // optional int64 server_time_ms = 4;
    if (has_server_time_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->server_time_ms());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerHeader::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerHeader*>(&from));
}

void ServerHeader::MergeFrom(const ServerHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerHeader)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_client_token();
      client_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.client_token_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_message_id();
      message_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_protocol_version()->::ipc::invalidation::ProtocolVersion::MergeFrom(from.protocol_version());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_summary()->::ipc::invalidation::RegistrationSummary::MergeFrom(from.registration_summary());
    }
    if (cached_has_bits & 0x00000010u) {
      server_time_ms_ = from.server_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ServerHeader::CopyFrom(const ServerHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerHeader::IsInitialized() const {
  return true;
}

void ServerHeader::Swap(ServerHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ServerHeader::InternalSwap(ServerHeader* other) {
  client_token_.Swap(&other->client_token_);
  message_id_.Swap(&other->message_id_);
  std::swap(protocol_version_, other->protocol_version_);
  std::swap(registration_summary_, other->registration_summary_);
  std::swap(server_time_ms_, other->server_time_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ServerHeader::GetTypeName() const {
  return "ipc.invalidation.ServerHeader";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ServerHeader

// optional .ipc.invalidation.ProtocolVersion protocol_version = 1;
bool ServerHeader::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ServerHeader::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000004u;
}
void ServerHeader::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000004u;
}
void ServerHeader::clear_protocol_version() {
  if (protocol_version_ != NULL) protocol_version_->::ipc::invalidation::ProtocolVersion::Clear();
  clear_has_protocol_version();
}
const ::ipc::invalidation::ProtocolVersion& ServerHeader::protocol_version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.protocol_version)
  return protocol_version_ != NULL ? *protocol_version_
                         : *::ipc::invalidation::ProtocolVersion::internal_default_instance();
}
::ipc::invalidation::ProtocolVersion* ServerHeader::mutable_protocol_version() {
  set_has_protocol_version();
  if (protocol_version_ == NULL) {
    protocol_version_ = new ::ipc::invalidation::ProtocolVersion;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.protocol_version)
  return protocol_version_;
}
::ipc::invalidation::ProtocolVersion* ServerHeader::release_protocol_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.protocol_version)
  clear_has_protocol_version();
  ::ipc::invalidation::ProtocolVersion* temp = protocol_version_;
  protocol_version_ = NULL;
  return temp;
}
void ServerHeader::set_allocated_protocol_version(::ipc::invalidation::ProtocolVersion* protocol_version) {
  delete protocol_version_;
  protocol_version_ = protocol_version;
  if (protocol_version) {
    set_has_protocol_version();
  } else {
    clear_has_protocol_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.protocol_version)
}

// optional bytes client_token = 2;
bool ServerHeader::has_client_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ServerHeader::set_has_client_token() {
  _has_bits_[0] |= 0x00000001u;
}
void ServerHeader::clear_has_client_token() {
  _has_bits_[0] &= ~0x00000001u;
}
void ServerHeader::clear_client_token() {
  client_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_token();
}
const ::std::string& ServerHeader::client_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.client_token)
  return client_token_.GetNoArena();
}
void ServerHeader::set_client_token(const ::std::string& value) {
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.client_token)
}
#if LANG_CXX11
void ServerHeader::set_client_token(::std::string&& value) {
  set_has_client_token();
  client_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ServerHeader.client_token)
}
#endif
void ServerHeader::set_client_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.client_token)
}
void ServerHeader::set_client_token(const void* value, size_t size) {
  set_has_client_token();
  client_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.client_token)
}
::std::string* ServerHeader::mutable_client_token() {
  set_has_client_token();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.client_token)
  return client_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ServerHeader::release_client_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.client_token)
  clear_has_client_token();
  return client_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerHeader::set_allocated_client_token(::std::string* client_token) {
  if (client_token != NULL) {
    set_has_client_token();
  } else {
    clear_has_client_token();
  }
  client_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.client_token)
}

// optional .ipc.invalidation.RegistrationSummary registration_summary = 3;
bool ServerHeader::has_registration_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ServerHeader::set_has_registration_summary() {
  _has_bits_[0] |= 0x00000008u;
}
void ServerHeader::clear_has_registration_summary() {
  _has_bits_[0] &= ~0x00000008u;
}
void ServerHeader::clear_registration_summary() {
  if (registration_summary_ != NULL) registration_summary_->::ipc::invalidation::RegistrationSummary::Clear();
  clear_has_registration_summary();
}
const ::ipc::invalidation::RegistrationSummary& ServerHeader::registration_summary() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.registration_summary)
  return registration_summary_ != NULL ? *registration_summary_
                         : *::ipc::invalidation::RegistrationSummary::internal_default_instance();
}
::ipc::invalidation::RegistrationSummary* ServerHeader::mutable_registration_summary() {
  set_has_registration_summary();
  if (registration_summary_ == NULL) {
    registration_summary_ = new ::ipc::invalidation::RegistrationSummary;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.registration_summary)
  return registration_summary_;
}
::ipc::invalidation::RegistrationSummary* ServerHeader::release_registration_summary() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.registration_summary)
  clear_has_registration_summary();
  ::ipc::invalidation::RegistrationSummary* temp = registration_summary_;
  registration_summary_ = NULL;
  return temp;
}
void ServerHeader::set_allocated_registration_summary(::ipc::invalidation::RegistrationSummary* registration_summary) {
  delete registration_summary_;
  registration_summary_ = registration_summary;
  if (registration_summary) {
    set_has_registration_summary();
  } else {
    clear_has_registration_summary();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.registration_summary)
}

// optional int64 server_time_ms = 4;
bool ServerHeader::has_server_time_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ServerHeader::set_has_server_time_ms() {
  _has_bits_[0] |= 0x00000010u;
}
void ServerHeader::clear_has_server_time_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
void ServerHeader::clear_server_time_ms() {
  server_time_ms_ = GOOGLE_LONGLONG(0);
  clear_has_server_time_ms();
}
::google::protobuf::int64 ServerHeader::server_time_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.server_time_ms)
  return server_time_ms_;
}
void ServerHeader::set_server_time_ms(::google::protobuf::int64 value) {
  set_has_server_time_ms();
  server_time_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.server_time_ms)
}

// optional string message_id = 5;
bool ServerHeader::has_message_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ServerHeader::set_has_message_id() {
  _has_bits_[0] |= 0x00000002u;
}
void ServerHeader::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void ServerHeader::clear_message_id() {
  message_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_id();
}
const ::std::string& ServerHeader::message_id() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerHeader.message_id)
  return message_id_.GetNoArena();
}
void ServerHeader::set_message_id(const ::std::string& value) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ServerHeader.message_id)
}
#if LANG_CXX11
void ServerHeader::set_message_id(::std::string&& value) {
  set_has_message_id();
  message_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ServerHeader.message_id)
}
#endif
void ServerHeader::set_message_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ServerHeader.message_id)
}
void ServerHeader::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  message_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ServerHeader.message_id)
}
::std::string* ServerHeader::mutable_message_id() {
  set_has_message_id();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerHeader.message_id)
  return message_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ServerHeader::release_message_id() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerHeader.message_id)
  clear_has_message_id();
  return message_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ServerHeader::set_allocated_message_id(::std::string* message_id) {
  if (message_id != NULL) {
    set_has_message_id();
  } else {
    clear_has_message_id();
  }
  message_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_id);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerHeader.message_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ServerToClientMessage::kHeaderFieldNumber;
const int ServerToClientMessage::kTokenControlMessageFieldNumber;
const int ServerToClientMessage::kInvalidationMessageFieldNumber;
const int ServerToClientMessage::kRegistrationStatusMessageFieldNumber;
const int ServerToClientMessage::kRegistrationSyncRequestMessageFieldNumber;
const int ServerToClientMessage::kConfigChangeMessageFieldNumber;
const int ServerToClientMessage::kInfoRequestMessageFieldNumber;
const int ServerToClientMessage::kErrorMessageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ServerToClientMessage::ServerToClientMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ServerToClientMessage)
}
ServerToClientMessage::ServerToClientMessage(const ServerToClientMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::ipc::invalidation::ServerHeader(*from.header_);
  } else {
    header_ = NULL;
  }
  if (from.has_token_control_message()) {
    token_control_message_ = new ::ipc::invalidation::TokenControlMessage(*from.token_control_message_);
  } else {
    token_control_message_ = NULL;
  }
  if (from.has_invalidation_message()) {
    invalidation_message_ = new ::ipc::invalidation::InvalidationMessage(*from.invalidation_message_);
  } else {
    invalidation_message_ = NULL;
  }
  if (from.has_registration_status_message()) {
    registration_status_message_ = new ::ipc::invalidation::RegistrationStatusMessage(*from.registration_status_message_);
  } else {
    registration_status_message_ = NULL;
  }
  if (from.has_registration_sync_request_message()) {
    registration_sync_request_message_ = new ::ipc::invalidation::RegistrationSyncRequestMessage(*from.registration_sync_request_message_);
  } else {
    registration_sync_request_message_ = NULL;
  }
  if (from.has_config_change_message()) {
    config_change_message_ = new ::ipc::invalidation::ConfigChangeMessage(*from.config_change_message_);
  } else {
    config_change_message_ = NULL;
  }
  if (from.has_info_request_message()) {
    info_request_message_ = new ::ipc::invalidation::InfoRequestMessage(*from.info_request_message_);
  } else {
    info_request_message_ = NULL;
  }
  if (from.has_error_message()) {
    error_message_ = new ::ipc::invalidation::ErrorMessage(*from.error_message_);
  } else {
    error_message_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ServerToClientMessage)
}

void ServerToClientMessage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&header_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&error_message_) -
      reinterpret_cast<char*>(&header_)) + sizeof(error_message_));
}

ServerToClientMessage::~ServerToClientMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ServerToClientMessage)
  SharedDtor();
}

void ServerToClientMessage::SharedDtor() {
  if (this != internal_default_instance()) {
    delete header_;
  }
  if (this != internal_default_instance()) {
    delete token_control_message_;
  }
  if (this != internal_default_instance()) {
    delete invalidation_message_;
  }
  if (this != internal_default_instance()) {
    delete registration_status_message_;
  }
  if (this != internal_default_instance()) {
    delete registration_sync_request_message_;
  }
  if (this != internal_default_instance()) {
    delete config_change_message_;
  }
  if (this != internal_default_instance()) {
    delete info_request_message_;
  }
  if (this != internal_default_instance()) {
    delete error_message_;
  }
}

void ServerToClientMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ServerToClientMessage& ServerToClientMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ServerToClientMessage* ServerToClientMessage::New(::google::protobuf::Arena* arena) const {
  ServerToClientMessage* n = new ServerToClientMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ServerToClientMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ServerToClientMessage)
  if (_has_bits_[0 / 32] & 255u) {
    if (has_header()) {
      GOOGLE_DCHECK(header_ != NULL);
      header_->::ipc::invalidation::ServerHeader::Clear();
    }
    if (has_token_control_message()) {
      GOOGLE_DCHECK(token_control_message_ != NULL);
      token_control_message_->::ipc::invalidation::TokenControlMessage::Clear();
    }
    if (has_invalidation_message()) {
      GOOGLE_DCHECK(invalidation_message_ != NULL);
      invalidation_message_->::ipc::invalidation::InvalidationMessage::Clear();
    }
    if (has_registration_status_message()) {
      GOOGLE_DCHECK(registration_status_message_ != NULL);
      registration_status_message_->::ipc::invalidation::RegistrationStatusMessage::Clear();
    }
    if (has_registration_sync_request_message()) {
      GOOGLE_DCHECK(registration_sync_request_message_ != NULL);
      registration_sync_request_message_->::ipc::invalidation::RegistrationSyncRequestMessage::Clear();
    }
    if (has_config_change_message()) {
      GOOGLE_DCHECK(config_change_message_ != NULL);
      config_change_message_->::ipc::invalidation::ConfigChangeMessage::Clear();
    }
    if (has_info_request_message()) {
      GOOGLE_DCHECK(info_request_message_ != NULL);
      info_request_message_->::ipc::invalidation::InfoRequestMessage::Clear();
    }
    if (has_error_message()) {
      GOOGLE_DCHECK(error_message_ != NULL);
      error_message_->::ipc::invalidation::ErrorMessage::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ServerToClientMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ServerToClientMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ServerHeader header = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_token_control_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_invalidation_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_status_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration_sync_request_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config_change_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(58u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_info_request_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ErrorMessage error_message = 8;
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(66u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_error_message()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ServerToClientMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ServerToClientMessage)
  return false;
#undef DO_
}

void ServerToClientMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ServerToClientMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ServerHeader header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->header_, output);
  }

  // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->token_control_message_, output);
  }

  // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->invalidation_message_, output);
  }

  // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->registration_status_message_, output);
  }

  // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->registration_sync_request_message_, output);
  }

  // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->config_change_message_, output);
  }

  // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->info_request_message_, output);
  }

  // optional .ipc.invalidation.ErrorMessage error_message = 8;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, *this->error_message_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ServerToClientMessage)
}

size_t ServerToClientMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ServerToClientMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 255u) {
    // optional .ipc.invalidation.ServerHeader header = 1;
    if (has_header()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->header_);
    }

    // optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
    if (has_token_control_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->token_control_message_);
    }

    // optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
    if (has_invalidation_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->invalidation_message_);
    }

    // optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
    if (has_registration_status_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_status_message_);
    }

    // optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
    if (has_registration_sync_request_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_sync_request_message_);
    }

    // optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
    if (has_config_change_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->config_change_message_);
    }

    // optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
    if (has_info_request_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->info_request_message_);
    }

    // optional .ipc.invalidation.ErrorMessage error_message = 8;
    if (has_error_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->error_message_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServerToClientMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ServerToClientMessage*>(&from));
}

void ServerToClientMessage::MergeFrom(const ServerToClientMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ServerToClientMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_header()->::ipc::invalidation::ServerHeader::MergeFrom(from.header());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_token_control_message()->::ipc::invalidation::TokenControlMessage::MergeFrom(from.token_control_message());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_invalidation_message()->::ipc::invalidation::InvalidationMessage::MergeFrom(from.invalidation_message());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_registration_status_message()->::ipc::invalidation::RegistrationStatusMessage::MergeFrom(from.registration_status_message());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_registration_sync_request_message()->::ipc::invalidation::RegistrationSyncRequestMessage::MergeFrom(from.registration_sync_request_message());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_config_change_message()->::ipc::invalidation::ConfigChangeMessage::MergeFrom(from.config_change_message());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_info_request_message()->::ipc::invalidation::InfoRequestMessage::MergeFrom(from.info_request_message());
    }
    if (cached_has_bits & 0x00000080u) {
      mutable_error_message()->::ipc::invalidation::ErrorMessage::MergeFrom(from.error_message());
    }
  }
}

void ServerToClientMessage::CopyFrom(const ServerToClientMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ServerToClientMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServerToClientMessage::IsInitialized() const {
  return true;
}

void ServerToClientMessage::Swap(ServerToClientMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ServerToClientMessage::InternalSwap(ServerToClientMessage* other) {
  std::swap(header_, other->header_);
  std::swap(token_control_message_, other->token_control_message_);
  std::swap(invalidation_message_, other->invalidation_message_);
  std::swap(registration_status_message_, other->registration_status_message_);
  std::swap(registration_sync_request_message_, other->registration_sync_request_message_);
  std::swap(config_change_message_, other->config_change_message_);
  std::swap(info_request_message_, other->info_request_message_);
  std::swap(error_message_, other->error_message_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ServerToClientMessage::GetTypeName() const {
  return "ipc.invalidation.ServerToClientMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ServerToClientMessage

// optional .ipc.invalidation.ServerHeader header = 1;
bool ServerToClientMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ServerToClientMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
void ServerToClientMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
void ServerToClientMessage::clear_header() {
  if (header_ != NULL) header_->::ipc::invalidation::ServerHeader::Clear();
  clear_has_header();
}
const ::ipc::invalidation::ServerHeader& ServerToClientMessage::header() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.header)
  return header_ != NULL ? *header_
                         : *::ipc::invalidation::ServerHeader::internal_default_instance();
}
::ipc::invalidation::ServerHeader* ServerToClientMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::ipc::invalidation::ServerHeader;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.header)
  return header_;
}
::ipc::invalidation::ServerHeader* ServerToClientMessage::release_header() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.header)
  clear_has_header();
  ::ipc::invalidation::ServerHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_header(::ipc::invalidation::ServerHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.header)
}

// optional .ipc.invalidation.TokenControlMessage token_control_message = 2;
bool ServerToClientMessage::has_token_control_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ServerToClientMessage::set_has_token_control_message() {
  _has_bits_[0] |= 0x00000002u;
}
void ServerToClientMessage::clear_has_token_control_message() {
  _has_bits_[0] &= ~0x00000002u;
}
void ServerToClientMessage::clear_token_control_message() {
  if (token_control_message_ != NULL) token_control_message_->::ipc::invalidation::TokenControlMessage::Clear();
  clear_has_token_control_message();
}
const ::ipc::invalidation::TokenControlMessage& ServerToClientMessage::token_control_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.token_control_message)
  return token_control_message_ != NULL ? *token_control_message_
                         : *::ipc::invalidation::TokenControlMessage::internal_default_instance();
}
::ipc::invalidation::TokenControlMessage* ServerToClientMessage::mutable_token_control_message() {
  set_has_token_control_message();
  if (token_control_message_ == NULL) {
    token_control_message_ = new ::ipc::invalidation::TokenControlMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.token_control_message)
  return token_control_message_;
}
::ipc::invalidation::TokenControlMessage* ServerToClientMessage::release_token_control_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.token_control_message)
  clear_has_token_control_message();
  ::ipc::invalidation::TokenControlMessage* temp = token_control_message_;
  token_control_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_token_control_message(::ipc::invalidation::TokenControlMessage* token_control_message) {
  delete token_control_message_;
  token_control_message_ = token_control_message;
  if (token_control_message) {
    set_has_token_control_message();
  } else {
    clear_has_token_control_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.token_control_message)
}

// optional .ipc.invalidation.InvalidationMessage invalidation_message = 3;
bool ServerToClientMessage::has_invalidation_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ServerToClientMessage::set_has_invalidation_message() {
  _has_bits_[0] |= 0x00000004u;
}
void ServerToClientMessage::clear_has_invalidation_message() {
  _has_bits_[0] &= ~0x00000004u;
}
void ServerToClientMessage::clear_invalidation_message() {
  if (invalidation_message_ != NULL) invalidation_message_->::ipc::invalidation::InvalidationMessage::Clear();
  clear_has_invalidation_message();
}
const ::ipc::invalidation::InvalidationMessage& ServerToClientMessage::invalidation_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.invalidation_message)
  return invalidation_message_ != NULL ? *invalidation_message_
                         : *::ipc::invalidation::InvalidationMessage::internal_default_instance();
}
::ipc::invalidation::InvalidationMessage* ServerToClientMessage::mutable_invalidation_message() {
  set_has_invalidation_message();
  if (invalidation_message_ == NULL) {
    invalidation_message_ = new ::ipc::invalidation::InvalidationMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.invalidation_message)
  return invalidation_message_;
}
::ipc::invalidation::InvalidationMessage* ServerToClientMessage::release_invalidation_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.invalidation_message)
  clear_has_invalidation_message();
  ::ipc::invalidation::InvalidationMessage* temp = invalidation_message_;
  invalidation_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_invalidation_message(::ipc::invalidation::InvalidationMessage* invalidation_message) {
  delete invalidation_message_;
  invalidation_message_ = invalidation_message;
  if (invalidation_message) {
    set_has_invalidation_message();
  } else {
    clear_has_invalidation_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.invalidation_message)
}

// optional .ipc.invalidation.RegistrationStatusMessage registration_status_message = 4;
bool ServerToClientMessage::has_registration_status_message() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ServerToClientMessage::set_has_registration_status_message() {
  _has_bits_[0] |= 0x00000008u;
}
void ServerToClientMessage::clear_has_registration_status_message() {
  _has_bits_[0] &= ~0x00000008u;
}
void ServerToClientMessage::clear_registration_status_message() {
  if (registration_status_message_ != NULL) registration_status_message_->::ipc::invalidation::RegistrationStatusMessage::Clear();
  clear_has_registration_status_message();
}
const ::ipc::invalidation::RegistrationStatusMessage& ServerToClientMessage::registration_status_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_status_message)
  return registration_status_message_ != NULL ? *registration_status_message_
                         : *::ipc::invalidation::RegistrationStatusMessage::internal_default_instance();
}
::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::mutable_registration_status_message() {
  set_has_registration_status_message();
  if (registration_status_message_ == NULL) {
    registration_status_message_ = new ::ipc::invalidation::RegistrationStatusMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_status_message)
  return registration_status_message_;
}
::ipc::invalidation::RegistrationStatusMessage* ServerToClientMessage::release_registration_status_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_status_message)
  clear_has_registration_status_message();
  ::ipc::invalidation::RegistrationStatusMessage* temp = registration_status_message_;
  registration_status_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_registration_status_message(::ipc::invalidation::RegistrationStatusMessage* registration_status_message) {
  delete registration_status_message_;
  registration_status_message_ = registration_status_message;
  if (registration_status_message) {
    set_has_registration_status_message();
  } else {
    clear_has_registration_status_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_status_message)
}

// optional .ipc.invalidation.RegistrationSyncRequestMessage registration_sync_request_message = 5;
bool ServerToClientMessage::has_registration_sync_request_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ServerToClientMessage::set_has_registration_sync_request_message() {
  _has_bits_[0] |= 0x00000010u;
}
void ServerToClientMessage::clear_has_registration_sync_request_message() {
  _has_bits_[0] &= ~0x00000010u;
}
void ServerToClientMessage::clear_registration_sync_request_message() {
  if (registration_sync_request_message_ != NULL) registration_sync_request_message_->::ipc::invalidation::RegistrationSyncRequestMessage::Clear();
  clear_has_registration_sync_request_message();
}
const ::ipc::invalidation::RegistrationSyncRequestMessage& ServerToClientMessage::registration_sync_request_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  return registration_sync_request_message_ != NULL ? *registration_sync_request_message_
                         : *::ipc::invalidation::RegistrationSyncRequestMessage::internal_default_instance();
}
::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::mutable_registration_sync_request_message() {
  set_has_registration_sync_request_message();
  if (registration_sync_request_message_ == NULL) {
    registration_sync_request_message_ = new ::ipc::invalidation::RegistrationSyncRequestMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  return registration_sync_request_message_;
}
::ipc::invalidation::RegistrationSyncRequestMessage* ServerToClientMessage::release_registration_sync_request_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
  clear_has_registration_sync_request_message();
  ::ipc::invalidation::RegistrationSyncRequestMessage* temp = registration_sync_request_message_;
  registration_sync_request_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_registration_sync_request_message(::ipc::invalidation::RegistrationSyncRequestMessage* registration_sync_request_message) {
  delete registration_sync_request_message_;
  registration_sync_request_message_ = registration_sync_request_message;
  if (registration_sync_request_message) {
    set_has_registration_sync_request_message();
  } else {
    clear_has_registration_sync_request_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.registration_sync_request_message)
}

// optional .ipc.invalidation.ConfigChangeMessage config_change_message = 6;
bool ServerToClientMessage::has_config_change_message() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ServerToClientMessage::set_has_config_change_message() {
  _has_bits_[0] |= 0x00000020u;
}
void ServerToClientMessage::clear_has_config_change_message() {
  _has_bits_[0] &= ~0x00000020u;
}
void ServerToClientMessage::clear_config_change_message() {
  if (config_change_message_ != NULL) config_change_message_->::ipc::invalidation::ConfigChangeMessage::Clear();
  clear_has_config_change_message();
}
const ::ipc::invalidation::ConfigChangeMessage& ServerToClientMessage::config_change_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.config_change_message)
  return config_change_message_ != NULL ? *config_change_message_
                         : *::ipc::invalidation::ConfigChangeMessage::internal_default_instance();
}
::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::mutable_config_change_message() {
  set_has_config_change_message();
  if (config_change_message_ == NULL) {
    config_change_message_ = new ::ipc::invalidation::ConfigChangeMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.config_change_message)
  return config_change_message_;
}
::ipc::invalidation::ConfigChangeMessage* ServerToClientMessage::release_config_change_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.config_change_message)
  clear_has_config_change_message();
  ::ipc::invalidation::ConfigChangeMessage* temp = config_change_message_;
  config_change_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_config_change_message(::ipc::invalidation::ConfigChangeMessage* config_change_message) {
  delete config_change_message_;
  config_change_message_ = config_change_message;
  if (config_change_message) {
    set_has_config_change_message();
  } else {
    clear_has_config_change_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.config_change_message)
}

// optional .ipc.invalidation.InfoRequestMessage info_request_message = 7;
bool ServerToClientMessage::has_info_request_message() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ServerToClientMessage::set_has_info_request_message() {
  _has_bits_[0] |= 0x00000040u;
}
void ServerToClientMessage::clear_has_info_request_message() {
  _has_bits_[0] &= ~0x00000040u;
}
void ServerToClientMessage::clear_info_request_message() {
  if (info_request_message_ != NULL) info_request_message_->::ipc::invalidation::InfoRequestMessage::Clear();
  clear_has_info_request_message();
}
const ::ipc::invalidation::InfoRequestMessage& ServerToClientMessage::info_request_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.info_request_message)
  return info_request_message_ != NULL ? *info_request_message_
                         : *::ipc::invalidation::InfoRequestMessage::internal_default_instance();
}
::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::mutable_info_request_message() {
  set_has_info_request_message();
  if (info_request_message_ == NULL) {
    info_request_message_ = new ::ipc::invalidation::InfoRequestMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.info_request_message)
  return info_request_message_;
}
::ipc::invalidation::InfoRequestMessage* ServerToClientMessage::release_info_request_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.info_request_message)
  clear_has_info_request_message();
  ::ipc::invalidation::InfoRequestMessage* temp = info_request_message_;
  info_request_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_info_request_message(::ipc::invalidation::InfoRequestMessage* info_request_message) {
  delete info_request_message_;
  info_request_message_ = info_request_message;
  if (info_request_message) {
    set_has_info_request_message();
  } else {
    clear_has_info_request_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.info_request_message)
}

// optional .ipc.invalidation.ErrorMessage error_message = 8;
bool ServerToClientMessage::has_error_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ServerToClientMessage::set_has_error_message() {
  _has_bits_[0] |= 0x00000080u;
}
void ServerToClientMessage::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000080u;
}
void ServerToClientMessage::clear_error_message() {
  if (error_message_ != NULL) error_message_->::ipc::invalidation::ErrorMessage::Clear();
  clear_has_error_message();
}
const ::ipc::invalidation::ErrorMessage& ServerToClientMessage::error_message() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ServerToClientMessage.error_message)
  return error_message_ != NULL ? *error_message_
                         : *::ipc::invalidation::ErrorMessage::internal_default_instance();
}
::ipc::invalidation::ErrorMessage* ServerToClientMessage::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == NULL) {
    error_message_ = new ::ipc::invalidation::ErrorMessage;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ServerToClientMessage.error_message)
  return error_message_;
}
::ipc::invalidation::ErrorMessage* ServerToClientMessage::release_error_message() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ServerToClientMessage.error_message)
  clear_has_error_message();
  ::ipc::invalidation::ErrorMessage* temp = error_message_;
  error_message_ = NULL;
  return temp;
}
void ServerToClientMessage::set_allocated_error_message(::ipc::invalidation::ErrorMessage* error_message) {
  delete error_message_;
  error_message_ = error_message;
  if (error_message) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ServerToClientMessage.error_message)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TokenControlMessage::kNewTokenFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TokenControlMessage::TokenControlMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.TokenControlMessage)
}
TokenControlMessage::TokenControlMessage(const TokenControlMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  new_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_new_token()) {
    new_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_token_);
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.TokenControlMessage)
}

void TokenControlMessage::SharedCtor() {
  _cached_size_ = 0;
  new_token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

TokenControlMessage::~TokenControlMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.TokenControlMessage)
  SharedDtor();
}

void TokenControlMessage::SharedDtor() {
  new_token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TokenControlMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TokenControlMessage& TokenControlMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

TokenControlMessage* TokenControlMessage::New(::google::protobuf::Arena* arena) const {
  TokenControlMessage* n = new TokenControlMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TokenControlMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.TokenControlMessage)
  if (has_new_token()) {
    GOOGLE_DCHECK(!new_token_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*new_token_.UnsafeRawStringPointer())->clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool TokenControlMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.TokenControlMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes new_token = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_new_token()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.TokenControlMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.TokenControlMessage)
  return false;
#undef DO_
}

void TokenControlMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.TokenControlMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes new_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->new_token(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.TokenControlMessage)
}

size_t TokenControlMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.TokenControlMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // optional bytes new_token = 1;
  if (has_new_token()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->new_token());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TokenControlMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TokenControlMessage*>(&from));
}

void TokenControlMessage::MergeFrom(const TokenControlMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.TokenControlMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_new_token()) {
    set_has_new_token();
    new_token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.new_token_);
  }
}

void TokenControlMessage::CopyFrom(const TokenControlMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.TokenControlMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TokenControlMessage::IsInitialized() const {
  return true;
}

void TokenControlMessage::Swap(TokenControlMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TokenControlMessage::InternalSwap(TokenControlMessage* other) {
  new_token_.Swap(&other->new_token_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TokenControlMessage::GetTypeName() const {
  return "ipc.invalidation.TokenControlMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TokenControlMessage

// optional bytes new_token = 1;
bool TokenControlMessage::has_new_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TokenControlMessage::set_has_new_token() {
  _has_bits_[0] |= 0x00000001u;
}
void TokenControlMessage::clear_has_new_token() {
  _has_bits_[0] &= ~0x00000001u;
}
void TokenControlMessage::clear_new_token() {
  new_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_new_token();
}
const ::std::string& TokenControlMessage::new_token() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.TokenControlMessage.new_token)
  return new_token_.GetNoArena();
}
void TokenControlMessage::set_new_token(const ::std::string& value) {
  set_has_new_token();
  new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.TokenControlMessage.new_token)
}
#if LANG_CXX11
void TokenControlMessage::set_new_token(::std::string&& value) {
  set_has_new_token();
  new_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.TokenControlMessage.new_token)
}
#endif
void TokenControlMessage::set_new_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_new_token();
  new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.TokenControlMessage.new_token)
}
void TokenControlMessage::set_new_token(const void* value, size_t size) {
  set_has_new_token();
  new_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.TokenControlMessage.new_token)
}
::std::string* TokenControlMessage::mutable_new_token() {
  set_has_new_token();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.TokenControlMessage.new_token)
  return new_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TokenControlMessage::release_new_token() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.TokenControlMessage.new_token)
  clear_has_new_token();
  return new_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TokenControlMessage::set_allocated_new_token(::std::string* new_token) {
  if (new_token != NULL) {
    set_has_new_token();
  } else {
    clear_has_new_token();
  }
  new_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_token);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.TokenControlMessage.new_token)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationStatus::kRegistrationFieldNumber;
const int RegistrationStatus::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationStatus::RegistrationStatus()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatus)
}
RegistrationStatus::RegistrationStatus(const RegistrationStatus& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_registration()) {
    registration_ = new ::ipc::invalidation::RegistrationP(*from.registration_);
  } else {
    registration_ = NULL;
  }
  if (from.has_status()) {
    status_ = new ::ipc::invalidation::StatusP(*from.status_);
  } else {
    status_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatus)
}

void RegistrationStatus::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&registration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&status_) -
      reinterpret_cast<char*>(&registration_)) + sizeof(status_));
}

RegistrationStatus::~RegistrationStatus() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatus)
  SharedDtor();
}

void RegistrationStatus::SharedDtor() {
  if (this != internal_default_instance()) {
    delete registration_;
  }
  if (this != internal_default_instance()) {
    delete status_;
  }
}

void RegistrationStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationStatus& RegistrationStatus::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationStatus* RegistrationStatus::New(::google::protobuf::Arena* arena) const {
  RegistrationStatus* n = new RegistrationStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatus)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_registration()) {
      GOOGLE_DCHECK(registration_ != NULL);
      registration_->::ipc::invalidation::RegistrationP::Clear();
    }
    if (has_status()) {
      GOOGLE_DCHECK(status_ != NULL);
      status_->::ipc::invalidation::StatusP::Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.RegistrationP registration = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_registration()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.StatusP status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatus)
  return false;
#undef DO_
}

void RegistrationStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatus)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.RegistrationP registration = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->registration_, output);
  }

  // optional .ipc.invalidation.StatusP status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->status_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatus)
}

size_t RegistrationStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatus)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional .ipc.invalidation.RegistrationP registration = 1;
    if (has_registration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->registration_);
    }

    // optional .ipc.invalidation.StatusP status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->status_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationStatus*>(&from));
}

void RegistrationStatus::MergeFrom(const RegistrationStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_registration()->::ipc::invalidation::RegistrationP::MergeFrom(from.registration());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_status()->::ipc::invalidation::StatusP::MergeFrom(from.status());
    }
  }
}

void RegistrationStatus::CopyFrom(const RegistrationStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationStatus::IsInitialized() const {
  return true;
}

void RegistrationStatus::Swap(RegistrationStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationStatus::InternalSwap(RegistrationStatus* other) {
  std::swap(registration_, other->registration_);
  std::swap(status_, other->status_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationStatus::GetTypeName() const {
  return "ipc.invalidation.RegistrationStatus";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationStatus

// optional .ipc.invalidation.RegistrationP registration = 1;
bool RegistrationStatus::has_registration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegistrationStatus::set_has_registration() {
  _has_bits_[0] |= 0x00000001u;
}
void RegistrationStatus::clear_has_registration() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegistrationStatus::clear_registration() {
  if (registration_ != NULL) registration_->::ipc::invalidation::RegistrationP::Clear();
  clear_has_registration();
}
const ::ipc::invalidation::RegistrationP& RegistrationStatus::registration() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.registration)
  return registration_ != NULL ? *registration_
                         : *::ipc::invalidation::RegistrationP::internal_default_instance();
}
::ipc::invalidation::RegistrationP* RegistrationStatus::mutable_registration() {
  set_has_registration();
  if (registration_ == NULL) {
    registration_ = new ::ipc::invalidation::RegistrationP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.registration)
  return registration_;
}
::ipc::invalidation::RegistrationP* RegistrationStatus::release_registration() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.registration)
  clear_has_registration();
  ::ipc::invalidation::RegistrationP* temp = registration_;
  registration_ = NULL;
  return temp;
}
void RegistrationStatus::set_allocated_registration(::ipc::invalidation::RegistrationP* registration) {
  delete registration_;
  registration_ = registration;
  if (registration) {
    set_has_registration();
  } else {
    clear_has_registration();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.registration)
}

// optional .ipc.invalidation.StatusP status = 2;
bool RegistrationStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RegistrationStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
void RegistrationStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
void RegistrationStatus::clear_status() {
  if (status_ != NULL) status_->::ipc::invalidation::StatusP::Clear();
  clear_has_status();
}
const ::ipc::invalidation::StatusP& RegistrationStatus::status() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatus.status)
  return status_ != NULL ? *status_
                         : *::ipc::invalidation::StatusP::internal_default_instance();
}
::ipc::invalidation::StatusP* RegistrationStatus::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::ipc::invalidation::StatusP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatus.status)
  return status_;
}
::ipc::invalidation::StatusP* RegistrationStatus::release_status() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.RegistrationStatus.status)
  clear_has_status();
  ::ipc::invalidation::StatusP* temp = status_;
  status_ = NULL;
  return temp;
}
void RegistrationStatus::set_allocated_status(::ipc::invalidation::StatusP* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.RegistrationStatus.status)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegistrationStatusMessage::kRegistrationStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationStatusMessage::RegistrationStatusMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationStatusMessage)
}
RegistrationStatusMessage::RegistrationStatusMessage(const RegistrationStatusMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      registration_status_(from.registration_status_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationStatusMessage)
}

void RegistrationStatusMessage::SharedCtor() {
  _cached_size_ = 0;
}

RegistrationStatusMessage::~RegistrationStatusMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationStatusMessage)
  SharedDtor();
}

void RegistrationStatusMessage::SharedDtor() {
}

void RegistrationStatusMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationStatusMessage& RegistrationStatusMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationStatusMessage* RegistrationStatusMessage::New(::google::protobuf::Arena* arena) const {
  RegistrationStatusMessage* n = new RegistrationStatusMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationStatusMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationStatusMessage)
  registration_status_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationStatusMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationStatusMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_registration_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationStatusMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationStatusMessage)
  return false;
#undef DO_
}

void RegistrationStatusMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationStatusMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->registration_status_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->registration_status(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationStatusMessage)
}

size_t RegistrationStatusMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationStatusMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->registration_status_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->registration_status(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationStatusMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationStatusMessage*>(&from));
}

void RegistrationStatusMessage::MergeFrom(const RegistrationStatusMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationStatusMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  registration_status_.MergeFrom(from.registration_status_);
}

void RegistrationStatusMessage::CopyFrom(const RegistrationStatusMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationStatusMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationStatusMessage::IsInitialized() const {
  return true;
}

void RegistrationStatusMessage::Swap(RegistrationStatusMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationStatusMessage::InternalSwap(RegistrationStatusMessage* other) {
  registration_status_.InternalSwap(&other->registration_status_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationStatusMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationStatusMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationStatusMessage

// repeated .ipc.invalidation.RegistrationStatus registration_status = 1;
int RegistrationStatusMessage::registration_status_size() const {
  return registration_status_.size();
}
void RegistrationStatusMessage::clear_registration_status() {
  registration_status_.Clear();
}
const ::ipc::invalidation::RegistrationStatus& RegistrationStatusMessage::registration_status(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Get(index);
}
::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::mutable_registration_status(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Mutable(index);
}
::ipc::invalidation::RegistrationStatus* RegistrationStatusMessage::add_registration_status() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >*
RegistrationStatusMessage::mutable_registration_status() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return &registration_status_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RegistrationStatus >&
RegistrationStatusMessage::registration_status() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.RegistrationStatusMessage.registration_status)
  return registration_status_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegistrationSyncRequestMessage::RegistrationSyncRequestMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RegistrationSyncRequestMessage)
}
RegistrationSyncRequestMessage::RegistrationSyncRequestMessage(const RegistrationSyncRequestMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RegistrationSyncRequestMessage)
}

void RegistrationSyncRequestMessage::SharedCtor() {
  _cached_size_ = 0;
}

RegistrationSyncRequestMessage::~RegistrationSyncRequestMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RegistrationSyncRequestMessage)
  SharedDtor();
}

void RegistrationSyncRequestMessage::SharedDtor() {
}

void RegistrationSyncRequestMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegistrationSyncRequestMessage& RegistrationSyncRequestMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RegistrationSyncRequestMessage* RegistrationSyncRequestMessage::New(::google::protobuf::Arena* arena) const {
  RegistrationSyncRequestMessage* n = new RegistrationSyncRequestMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegistrationSyncRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RegistrationSyncRequestMessage)
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RegistrationSyncRequestMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RegistrationSyncRequestMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RegistrationSyncRequestMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RegistrationSyncRequestMessage)
  return false;
#undef DO_
}

void RegistrationSyncRequestMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RegistrationSyncRequestMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RegistrationSyncRequestMessage)
}

size_t RegistrationSyncRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RegistrationSyncRequestMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegistrationSyncRequestMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegistrationSyncRequestMessage*>(&from));
}

void RegistrationSyncRequestMessage::MergeFrom(const RegistrationSyncRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void RegistrationSyncRequestMessage::CopyFrom(const RegistrationSyncRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RegistrationSyncRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegistrationSyncRequestMessage::IsInitialized() const {
  return true;
}

void RegistrationSyncRequestMessage::Swap(RegistrationSyncRequestMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegistrationSyncRequestMessage::InternalSwap(RegistrationSyncRequestMessage* other) {
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegistrationSyncRequestMessage::GetTypeName() const {
  return "ipc.invalidation.RegistrationSyncRequestMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegistrationSyncRequestMessage

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InvalidationMessage::kInvalidationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InvalidationMessage::InvalidationMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InvalidationMessage)
}
InvalidationMessage::InvalidationMessage(const InvalidationMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      invalidation_(from.invalidation_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InvalidationMessage)
}

void InvalidationMessage::SharedCtor() {
  _cached_size_ = 0;
}

InvalidationMessage::~InvalidationMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InvalidationMessage)
  SharedDtor();
}

void InvalidationMessage::SharedDtor() {
}

void InvalidationMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InvalidationMessage& InvalidationMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

InvalidationMessage* InvalidationMessage::New(::google::protobuf::Arena* arena) const {
  InvalidationMessage* n = new InvalidationMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InvalidationMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InvalidationMessage)
  invalidation_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InvalidationMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InvalidationMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.InvalidationP invalidation = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_invalidation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InvalidationMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InvalidationMessage)
  return false;
#undef DO_
}

void InvalidationMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InvalidationMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InvalidationP invalidation = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->invalidation_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->invalidation(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InvalidationMessage)
}

size_t InvalidationMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InvalidationMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.InvalidationP invalidation = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->invalidation_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->invalidation(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InvalidationMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InvalidationMessage*>(&from));
}

void InvalidationMessage::MergeFrom(const InvalidationMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InvalidationMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  invalidation_.MergeFrom(from.invalidation_);
}

void InvalidationMessage::CopyFrom(const InvalidationMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InvalidationMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InvalidationMessage::IsInitialized() const {
  return true;
}

void InvalidationMessage::Swap(InvalidationMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InvalidationMessage::InternalSwap(InvalidationMessage* other) {
  invalidation_.InternalSwap(&other->invalidation_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InvalidationMessage::GetTypeName() const {
  return "ipc.invalidation.InvalidationMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InvalidationMessage

// repeated .ipc.invalidation.InvalidationP invalidation = 1;
int InvalidationMessage::invalidation_size() const {
  return invalidation_.size();
}
void InvalidationMessage::clear_invalidation() {
  invalidation_.Clear();
}
const ::ipc::invalidation::InvalidationP& InvalidationMessage::invalidation(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Get(index);
}
::ipc::invalidation::InvalidationP* InvalidationMessage::mutable_invalidation(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Mutable(index);
}
::ipc::invalidation::InvalidationP* InvalidationMessage::add_invalidation() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::InvalidationP >*
InvalidationMessage::mutable_invalidation() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InvalidationMessage.invalidation)
  return &invalidation_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::InvalidationP >&
InvalidationMessage::invalidation() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InvalidationMessage.invalidation)
  return invalidation_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InfoRequestMessage::kInfoTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InfoRequestMessage::InfoRequestMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.InfoRequestMessage)
}
InfoRequestMessage::InfoRequestMessage(const InfoRequestMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      info_type_(from.info_type_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.InfoRequestMessage)
}

void InfoRequestMessage::SharedCtor() {
  _cached_size_ = 0;
}

InfoRequestMessage::~InfoRequestMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.InfoRequestMessage)
  SharedDtor();
}

void InfoRequestMessage::SharedDtor() {
}

void InfoRequestMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InfoRequestMessage& InfoRequestMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

InfoRequestMessage* InfoRequestMessage::New(::google::protobuf::Arena* arena) const {
  InfoRequestMessage* n = new InfoRequestMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InfoRequestMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.InfoRequestMessage)
  info_type_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool InfoRequestMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.InfoRequestMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value)) {
            add_info_type(static_cast< ::ipc::invalidation::InfoRequestMessage_InfoType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else if (static_cast< ::google::protobuf::uint8>(tag) ==
                   static_cast< ::google::protobuf::uint8>(10u)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::ipc::invalidation::InfoRequestMessage_InfoType_IsValid,
                 &unknown_fields_stream,
                 this->mutable_info_type())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.InfoRequestMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.InfoRequestMessage)
  return false;
#undef DO_
}

void InfoRequestMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.InfoRequestMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
  for (int i = 0, n = this->info_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->info_type(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.InfoRequestMessage)
}

size_t InfoRequestMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.InfoRequestMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->info_type_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->info_type(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InfoRequestMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InfoRequestMessage*>(&from));
}

void InfoRequestMessage::MergeFrom(const InfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.InfoRequestMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  info_type_.MergeFrom(from.info_type_);
}

void InfoRequestMessage::CopyFrom(const InfoRequestMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.InfoRequestMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InfoRequestMessage::IsInitialized() const {
  return true;
}

void InfoRequestMessage::Swap(InfoRequestMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InfoRequestMessage::InternalSwap(InfoRequestMessage* other) {
  info_type_.InternalSwap(&other->info_type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InfoRequestMessage::GetTypeName() const {
  return "ipc.invalidation.InfoRequestMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InfoRequestMessage

// repeated .ipc.invalidation.InfoRequestMessage.InfoType info_type = 1;
int InfoRequestMessage::info_type_size() const {
  return info_type_.size();
}
void InfoRequestMessage::clear_info_type() {
  info_type_.Clear();
}
::ipc::invalidation::InfoRequestMessage_InfoType InfoRequestMessage::info_type(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.InfoRequestMessage.info_type)
  return static_cast< ::ipc::invalidation::InfoRequestMessage_InfoType >(info_type_.Get(index));
}
void InfoRequestMessage::set_info_type(int index, ::ipc::invalidation::InfoRequestMessage_InfoType value) {
  assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
  info_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.InfoRequestMessage.info_type)
}
void InfoRequestMessage::add_info_type(::ipc::invalidation::InfoRequestMessage_InfoType value) {
  assert(::ipc::invalidation::InfoRequestMessage_InfoType_IsValid(value));
  info_type_.Add(value);
  // @@protoc_insertion_point(field_add:ipc.invalidation.InfoRequestMessage.info_type)
}
const ::google::protobuf::RepeatedField<int>&
InfoRequestMessage::info_type() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.InfoRequestMessage.info_type)
  return info_type_;
}
::google::protobuf::RepeatedField<int>*
InfoRequestMessage::mutable_info_type() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.InfoRequestMessage.info_type)
  return &info_type_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RateLimitP::kWindowMsFieldNumber;
const int RateLimitP::kCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RateLimitP::RateLimitP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.RateLimitP)
}
RateLimitP::RateLimitP(const RateLimitP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&window_ms_, &from.window_ms_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.RateLimitP)
}

void RateLimitP::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&window_ms_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
}

RateLimitP::~RateLimitP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.RateLimitP)
  SharedDtor();
}

void RateLimitP::SharedDtor() {
}

void RateLimitP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RateLimitP& RateLimitP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

RateLimitP* RateLimitP::New(::google::protobuf::Arena* arena) const {
  RateLimitP* n = new RateLimitP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RateLimitP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.RateLimitP)
  if (_has_bits_[0 / 32] & 3u) {
    ::memset(&window_ms_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&window_ms_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool RateLimitP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.RateLimitP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 window_ms = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_window_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &window_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 count = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_count();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &count_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.RateLimitP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.RateLimitP)
  return false;
#undef DO_
}

void RateLimitP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.RateLimitP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 window_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->window_ms(), output);
  }

  // optional int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->count(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.RateLimitP)
}

size_t RateLimitP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.RateLimitP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 window_ms = 1;
    if (has_window_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->window_ms());
    }

    // optional int32 count = 2;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->count());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RateLimitP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RateLimitP*>(&from));
}

void RateLimitP::MergeFrom(const RateLimitP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.RateLimitP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      window_ms_ = from.window_ms_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RateLimitP::CopyFrom(const RateLimitP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.RateLimitP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimitP::IsInitialized() const {
  return true;
}

void RateLimitP::Swap(RateLimitP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RateLimitP::InternalSwap(RateLimitP* other) {
  std::swap(window_ms_, other->window_ms_);
  std::swap(count_, other->count_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RateLimitP::GetTypeName() const {
  return "ipc.invalidation.RateLimitP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RateLimitP

// optional int32 window_ms = 1;
bool RateLimitP::has_window_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RateLimitP::set_has_window_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void RateLimitP::clear_has_window_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void RateLimitP::clear_window_ms() {
  window_ms_ = 0;
  clear_has_window_ms();
}
::google::protobuf::int32 RateLimitP::window_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.window_ms)
  return window_ms_;
}
void RateLimitP::set_window_ms(::google::protobuf::int32 value) {
  set_has_window_ms();
  window_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.window_ms)
}

// optional int32 count = 2;
bool RateLimitP::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RateLimitP::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
void RateLimitP::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
void RateLimitP::clear_count() {
  count_ = 0;
  clear_has_count();
}
::google::protobuf::int32 RateLimitP::count() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.RateLimitP.count)
  return count_;
}
void RateLimitP::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.RateLimitP.count)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProtocolHandlerConfigP::kBatchingDelayMsFieldNumber;
const int ProtocolHandlerConfigP::kRateLimitFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProtocolHandlerConfigP::ProtocolHandlerConfigP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ProtocolHandlerConfigP)
}
ProtocolHandlerConfigP::ProtocolHandlerConfigP(const ProtocolHandlerConfigP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      rate_limit_(from.rate_limit_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  batching_delay_ms_ = from.batching_delay_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ProtocolHandlerConfigP)
}

void ProtocolHandlerConfigP::SharedCtor() {
  _cached_size_ = 0;
  batching_delay_ms_ = 500;
}

ProtocolHandlerConfigP::~ProtocolHandlerConfigP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ProtocolHandlerConfigP)
  SharedDtor();
}

void ProtocolHandlerConfigP::SharedDtor() {
}

void ProtocolHandlerConfigP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProtocolHandlerConfigP& ProtocolHandlerConfigP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ProtocolHandlerConfigP* ProtocolHandlerConfigP::New(::google::protobuf::Arena* arena) const {
  ProtocolHandlerConfigP* n = new ProtocolHandlerConfigP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProtocolHandlerConfigP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ProtocolHandlerConfigP)
  rate_limit_.Clear();
  batching_delay_ms_ = 500;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ProtocolHandlerConfigP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ProtocolHandlerConfigP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 batching_delay_ms = 1 [default = 500];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_batching_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &batching_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rate_limit()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ProtocolHandlerConfigP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ProtocolHandlerConfigP)
  return false;
#undef DO_
}

void ProtocolHandlerConfigP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ProtocolHandlerConfigP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 batching_delay_ms = 1 [default = 500];
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->batching_delay_ms(), output);
  }

  // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->rate_limit_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->rate_limit(static_cast<int>(i)), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ProtocolHandlerConfigP)
}

size_t ProtocolHandlerConfigP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ProtocolHandlerConfigP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // repeated .ipc.invalidation.RateLimitP rate_limit = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->rate_limit_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rate_limit(static_cast<int>(i)));
    }
  }

  // optional int32 batching_delay_ms = 1 [default = 500];
  if (has_batching_delay_ms()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->batching_delay_ms());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtocolHandlerConfigP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ProtocolHandlerConfigP*>(&from));
}

void ProtocolHandlerConfigP::MergeFrom(const ProtocolHandlerConfigP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ProtocolHandlerConfigP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  rate_limit_.MergeFrom(from.rate_limit_);
  if (from.has_batching_delay_ms()) {
    set_batching_delay_ms(from.batching_delay_ms());
  }
}

void ProtocolHandlerConfigP::CopyFrom(const ProtocolHandlerConfigP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ProtocolHandlerConfigP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtocolHandlerConfigP::IsInitialized() const {
  return true;
}

void ProtocolHandlerConfigP::Swap(ProtocolHandlerConfigP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProtocolHandlerConfigP::InternalSwap(ProtocolHandlerConfigP* other) {
  rate_limit_.InternalSwap(&other->rate_limit_);
  std::swap(batching_delay_ms_, other->batching_delay_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ProtocolHandlerConfigP::GetTypeName() const {
  return "ipc.invalidation.ProtocolHandlerConfigP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProtocolHandlerConfigP

// optional int32 batching_delay_ms = 1 [default = 500];
bool ProtocolHandlerConfigP::has_batching_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ProtocolHandlerConfigP::set_has_batching_delay_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void ProtocolHandlerConfigP::clear_has_batching_delay_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void ProtocolHandlerConfigP::clear_batching_delay_ms() {
  batching_delay_ms_ = 500;
  clear_has_batching_delay_ms();
}
::google::protobuf::int32 ProtocolHandlerConfigP::batching_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
  return batching_delay_ms_;
}
void ProtocolHandlerConfigP::set_batching_delay_ms(::google::protobuf::int32 value) {
  set_has_batching_delay_ms();
  batching_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ProtocolHandlerConfigP.batching_delay_ms)
}

// repeated .ipc.invalidation.RateLimitP rate_limit = 2;
int ProtocolHandlerConfigP::rate_limit_size() const {
  return rate_limit_.size();
}
void ProtocolHandlerConfigP::clear_rate_limit() {
  rate_limit_.Clear();
}
const ::ipc::invalidation::RateLimitP& ProtocolHandlerConfigP::rate_limit(int index) const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Get(index);
}
::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::mutable_rate_limit(int index) {
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Mutable(index);
}
::ipc::invalidation::RateLimitP* ProtocolHandlerConfigP::add_rate_limit() {
  // @@protoc_insertion_point(field_add:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_.Add();
}
::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RateLimitP >*
ProtocolHandlerConfigP::mutable_rate_limit() {
  // @@protoc_insertion_point(field_mutable_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return &rate_limit_;
}
const ::google::protobuf::RepeatedPtrField< ::ipc::invalidation::RateLimitP >&
ProtocolHandlerConfigP::rate_limit() const {
  // @@protoc_insertion_point(field_list:ipc.invalidation.ProtocolHandlerConfigP.rate_limit)
  return rate_limit_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClientConfigP::kVersionFieldNumber;
const int ClientConfigP::kNetworkTimeoutDelayMsFieldNumber;
const int ClientConfigP::kWriteRetryDelayMsFieldNumber;
const int ClientConfigP::kHeartbeatIntervalMsFieldNumber;
const int ClientConfigP::kPerfCounterDelayMsFieldNumber;
const int ClientConfigP::kMaxExponentialBackoffFactorFieldNumber;
const int ClientConfigP::kSmearPercentFieldNumber;
const int ClientConfigP::kIsTransientFieldNumber;
const int ClientConfigP::kInitialPersistentHeartbeatDelayMsFieldNumber;
const int ClientConfigP::kProtocolHandlerConfigFieldNumber;
const int ClientConfigP::kChannelSupportsOfflineDeliveryFieldNumber;
const int ClientConfigP::kOfflineHeartbeatThresholdMsFieldNumber;
const int ClientConfigP::kAllowSuppressionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClientConfigP::ClientConfigP()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ClientConfigP)
}
ClientConfigP::ClientConfigP(const ClientConfigP& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_version()) {
    version_ = new ::ipc::invalidation::Version(*from.version_);
  } else {
    version_ = NULL;
  }
  if (from.has_protocol_handler_config()) {
    protocol_handler_config_ = new ::ipc::invalidation::ProtocolHandlerConfigP(*from.protocol_handler_config_);
  } else {
    protocol_handler_config_ = NULL;
  }
  ::memcpy(&is_transient_, &from.is_transient_,
    static_cast<size_t>(reinterpret_cast<char*>(&offline_heartbeat_threshold_ms_) -
    reinterpret_cast<char*>(&is_transient_)) + sizeof(offline_heartbeat_threshold_ms_));
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ClientConfigP)
}

void ClientConfigP::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&version_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&channel_supports_offline_delivery_) -
      reinterpret_cast<char*>(&version_)) + sizeof(channel_supports_offline_delivery_));
  allow_suppression_ = true;
  network_timeout_delay_ms_ = 60000;
  write_retry_delay_ms_ = 10000;
  heartbeat_interval_ms_ = 1200000;
  perf_counter_delay_ms_ = 21600000;
  max_exponential_backoff_factor_ = 500;
  smear_percent_ = 20;
  initial_persistent_heartbeat_delay_ms_ = 2000;
  offline_heartbeat_threshold_ms_ = 60000;
}

ClientConfigP::~ClientConfigP() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ClientConfigP)
  SharedDtor();
}

void ClientConfigP::SharedDtor() {
  if (this != internal_default_instance()) {
    delete version_;
  }
  if (this != internal_default_instance()) {
    delete protocol_handler_config_;
  }
}

void ClientConfigP::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClientConfigP& ClientConfigP::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ClientConfigP* ClientConfigP::New(::google::protobuf::Arena* arena) const {
  ClientConfigP* n = new ClientConfigP;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClientConfigP::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ClientConfigP)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_version()) {
      GOOGLE_DCHECK(version_ != NULL);
      version_->::ipc::invalidation::Version::Clear();
    }
    if (has_protocol_handler_config()) {
      GOOGLE_DCHECK(protocol_handler_config_ != NULL);
      protocol_handler_config_->::ipc::invalidation::ProtocolHandlerConfigP::Clear();
    }
  }
  if (_has_bits_[0 / 32] & 252u) {
    ::memset(&is_transient_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&channel_supports_offline_delivery_) -
        reinterpret_cast<char*>(&is_transient_)) + sizeof(channel_supports_offline_delivery_));
    allow_suppression_ = true;
    network_timeout_delay_ms_ = 60000;
    write_retry_delay_ms_ = 10000;
    heartbeat_interval_ms_ = 1200000;
  }
  if (_has_bits_[8 / 32] & 7936u) {
    perf_counter_delay_ms_ = 21600000;
    max_exponential_backoff_factor_ = 500;
    smear_percent_ = 20;
    initial_persistent_heartbeat_delay_ms_ = 2000;
    offline_heartbeat_threshold_ms_ = 60000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ClientConfigP::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ClientConfigP)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.Version version = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_version()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 network_timeout_delay_ms = 2 [default = 60000];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u)) {
          set_has_network_timeout_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &network_timeout_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 write_retry_delay_ms = 3 [default = 10000];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u)) {
          set_has_write_retry_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &write_retry_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u)) {
          set_has_heartbeat_interval_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &heartbeat_interval_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u)) {
          set_has_perf_counter_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &perf_counter_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 max_exponential_backoff_factor = 6 [default = 500];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(48u)) {
          set_has_max_exponential_backoff_factor();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_exponential_backoff_factor_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 smear_percent = 7 [default = 20];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u)) {
          set_has_smear_percent();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &smear_percent_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool is_transient = 8 [default = false];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(64u)) {
          set_has_is_transient();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_transient_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(72u)) {
          set_has_initial_persistent_heartbeat_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &initial_persistent_heartbeat_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(82u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_protocol_handler_config()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool channel_supports_offline_delivery = 11 [default = false];
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(88u)) {
          set_has_channel_supports_offline_delivery();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &channel_supports_offline_delivery_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(96u)) {
          set_has_offline_heartbeat_threshold_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &offline_heartbeat_threshold_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool allow_suppression = 13 [default = true];
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(104u)) {
          set_has_allow_suppression();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_suppression_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ClientConfigP)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ClientConfigP)
  return false;
#undef DO_
}

void ClientConfigP::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ClientConfigP)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.Version version = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->version_, output);
  }

  // optional int32 network_timeout_delay_ms = 2 [default = 60000];
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->network_timeout_delay_ms(), output);
  }

  // optional int32 write_retry_delay_ms = 3 [default = 10000];
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->write_retry_delay_ms(), output);
  }

  // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->heartbeat_interval_ms(), output);
  }

  // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
  if (cached_has_bits & 0x00000100u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->perf_counter_delay_ms(), output);
  }

  // optional int32 max_exponential_backoff_factor = 6 [default = 500];
  if (cached_has_bits & 0x00000200u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->max_exponential_backoff_factor(), output);
  }

  // optional int32 smear_percent = 7 [default = 20];
  if (cached_has_bits & 0x00000400u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->smear_percent(), output);
  }

  // optional bool is_transient = 8 [default = false];
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->is_transient(), output);
  }

  // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
  if (cached_has_bits & 0x00000800u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->initial_persistent_heartbeat_delay_ms(), output);
  }

  // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->protocol_handler_config_, output);
  }

  // optional bool channel_supports_offline_delivery = 11 [default = false];
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->channel_supports_offline_delivery(), output);
  }

  // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
  if (cached_has_bits & 0x00001000u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->offline_heartbeat_threshold_ms(), output);
  }

  // optional bool allow_suppression = 13 [default = true];
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->allow_suppression(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ClientConfigP)
}

size_t ClientConfigP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ClientConfigP)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 255u) {
    // optional .ipc.invalidation.Version version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->version_);
    }

    // optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
    if (has_protocol_handler_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->protocol_handler_config_);
    }

    // optional bool is_transient = 8 [default = false];
    if (has_is_transient()) {
      total_size += 1 + 1;
    }

    // optional bool channel_supports_offline_delivery = 11 [default = false];
    if (has_channel_supports_offline_delivery()) {
      total_size += 1 + 1;
    }

    // optional bool allow_suppression = 13 [default = true];
    if (has_allow_suppression()) {
      total_size += 1 + 1;
    }

    // optional int32 network_timeout_delay_ms = 2 [default = 60000];
    if (has_network_timeout_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->network_timeout_delay_ms());
    }

    // optional int32 write_retry_delay_ms = 3 [default = 10000];
    if (has_write_retry_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->write_retry_delay_ms());
    }

    // optional int32 heartbeat_interval_ms = 4 [default = 1200000];
    if (has_heartbeat_interval_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->heartbeat_interval_ms());
    }

  }
  if (_has_bits_[8 / 32] & 7936u) {
    // optional int32 perf_counter_delay_ms = 5 [default = 21600000];
    if (has_perf_counter_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->perf_counter_delay_ms());
    }

    // optional int32 max_exponential_backoff_factor = 6 [default = 500];
    if (has_max_exponential_backoff_factor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_exponential_backoff_factor());
    }

    // optional int32 smear_percent = 7 [default = 20];
    if (has_smear_percent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->smear_percent());
    }

    // optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
    if (has_initial_persistent_heartbeat_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->initial_persistent_heartbeat_delay_ms());
    }

    // optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
    if (has_offline_heartbeat_threshold_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->offline_heartbeat_threshold_ms());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClientConfigP::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClientConfigP*>(&from));
}

void ClientConfigP::MergeFrom(const ClientConfigP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ClientConfigP)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_version()->::ipc::invalidation::Version::MergeFrom(from.version());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_protocol_handler_config()->::ipc::invalidation::ProtocolHandlerConfigP::MergeFrom(from.protocol_handler_config());
    }
    if (cached_has_bits & 0x00000004u) {
      is_transient_ = from.is_transient_;
    }
    if (cached_has_bits & 0x00000008u) {
      channel_supports_offline_delivery_ = from.channel_supports_offline_delivery_;
    }
    if (cached_has_bits & 0x00000010u) {
      allow_suppression_ = from.allow_suppression_;
    }
    if (cached_has_bits & 0x00000020u) {
      network_timeout_delay_ms_ = from.network_timeout_delay_ms_;
    }
    if (cached_has_bits & 0x00000040u) {
      write_retry_delay_ms_ = from.write_retry_delay_ms_;
    }
    if (cached_has_bits & 0x00000080u) {
      heartbeat_interval_ms_ = from.heartbeat_interval_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 7936u) {
    if (cached_has_bits & 0x00000100u) {
      perf_counter_delay_ms_ = from.perf_counter_delay_ms_;
    }
    if (cached_has_bits & 0x00000200u) {
      max_exponential_backoff_factor_ = from.max_exponential_backoff_factor_;
    }
    if (cached_has_bits & 0x00000400u) {
      smear_percent_ = from.smear_percent_;
    }
    if (cached_has_bits & 0x00000800u) {
      initial_persistent_heartbeat_delay_ms_ = from.initial_persistent_heartbeat_delay_ms_;
    }
    if (cached_has_bits & 0x00001000u) {
      offline_heartbeat_threshold_ms_ = from.offline_heartbeat_threshold_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ClientConfigP::CopyFrom(const ClientConfigP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ClientConfigP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientConfigP::IsInitialized() const {
  return true;
}

void ClientConfigP::Swap(ClientConfigP* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClientConfigP::InternalSwap(ClientConfigP* other) {
  std::swap(version_, other->version_);
  std::swap(protocol_handler_config_, other->protocol_handler_config_);
  std::swap(is_transient_, other->is_transient_);
  std::swap(channel_supports_offline_delivery_, other->channel_supports_offline_delivery_);
  std::swap(allow_suppression_, other->allow_suppression_);
  std::swap(network_timeout_delay_ms_, other->network_timeout_delay_ms_);
  std::swap(write_retry_delay_ms_, other->write_retry_delay_ms_);
  std::swap(heartbeat_interval_ms_, other->heartbeat_interval_ms_);
  std::swap(perf_counter_delay_ms_, other->perf_counter_delay_ms_);
  std::swap(max_exponential_backoff_factor_, other->max_exponential_backoff_factor_);
  std::swap(smear_percent_, other->smear_percent_);
  std::swap(initial_persistent_heartbeat_delay_ms_, other->initial_persistent_heartbeat_delay_ms_);
  std::swap(offline_heartbeat_threshold_ms_, other->offline_heartbeat_threshold_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClientConfigP::GetTypeName() const {
  return "ipc.invalidation.ClientConfigP";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientConfigP

// optional .ipc.invalidation.Version version = 1;
bool ClientConfigP::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClientConfigP::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void ClientConfigP::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClientConfigP::clear_version() {
  if (version_ != NULL) version_->::ipc::invalidation::Version::Clear();
  clear_has_version();
}
const ::ipc::invalidation::Version& ClientConfigP::version() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.version)
  return version_ != NULL ? *version_
                         : *::ipc::invalidation::Version::internal_default_instance();
}
::ipc::invalidation::Version* ClientConfigP::mutable_version() {
  set_has_version();
  if (version_ == NULL) {
    version_ = new ::ipc::invalidation::Version;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.version)
  return version_;
}
::ipc::invalidation::Version* ClientConfigP::release_version() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.version)
  clear_has_version();
  ::ipc::invalidation::Version* temp = version_;
  version_ = NULL;
  return temp;
}
void ClientConfigP::set_allocated_version(::ipc::invalidation::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    set_has_version();
  } else {
    clear_has_version();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.version)
}

// optional int32 network_timeout_delay_ms = 2 [default = 60000];
bool ClientConfigP::has_network_timeout_delay_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ClientConfigP::set_has_network_timeout_delay_ms() {
  _has_bits_[0] |= 0x00000020u;
}
void ClientConfigP::clear_has_network_timeout_delay_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
void ClientConfigP::clear_network_timeout_delay_ms() {
  network_timeout_delay_ms_ = 60000;
  clear_has_network_timeout_delay_ms();
}
::google::protobuf::int32 ClientConfigP::network_timeout_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
  return network_timeout_delay_ms_;
}
void ClientConfigP::set_network_timeout_delay_ms(::google::protobuf::int32 value) {
  set_has_network_timeout_delay_ms();
  network_timeout_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.network_timeout_delay_ms)
}

// optional int32 write_retry_delay_ms = 3 [default = 10000];
bool ClientConfigP::has_write_retry_delay_ms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ClientConfigP::set_has_write_retry_delay_ms() {
  _has_bits_[0] |= 0x00000040u;
}
void ClientConfigP::clear_has_write_retry_delay_ms() {
  _has_bits_[0] &= ~0x00000040u;
}
void ClientConfigP::clear_write_retry_delay_ms() {
  write_retry_delay_ms_ = 10000;
  clear_has_write_retry_delay_ms();
}
::google::protobuf::int32 ClientConfigP::write_retry_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
  return write_retry_delay_ms_;
}
void ClientConfigP::set_write_retry_delay_ms(::google::protobuf::int32 value) {
  set_has_write_retry_delay_ms();
  write_retry_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.write_retry_delay_ms)
}

// optional int32 heartbeat_interval_ms = 4 [default = 1200000];
bool ClientConfigP::has_heartbeat_interval_ms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ClientConfigP::set_has_heartbeat_interval_ms() {
  _has_bits_[0] |= 0x00000080u;
}
void ClientConfigP::clear_has_heartbeat_interval_ms() {
  _has_bits_[0] &= ~0x00000080u;
}
void ClientConfigP::clear_heartbeat_interval_ms() {
  heartbeat_interval_ms_ = 1200000;
  clear_has_heartbeat_interval_ms();
}
::google::protobuf::int32 ClientConfigP::heartbeat_interval_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
  return heartbeat_interval_ms_;
}
void ClientConfigP::set_heartbeat_interval_ms(::google::protobuf::int32 value) {
  set_has_heartbeat_interval_ms();
  heartbeat_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.heartbeat_interval_ms)
}

// optional int32 perf_counter_delay_ms = 5 [default = 21600000];
bool ClientConfigP::has_perf_counter_delay_ms() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ClientConfigP::set_has_perf_counter_delay_ms() {
  _has_bits_[0] |= 0x00000100u;
}
void ClientConfigP::clear_has_perf_counter_delay_ms() {
  _has_bits_[0] &= ~0x00000100u;
}
void ClientConfigP::clear_perf_counter_delay_ms() {
  perf_counter_delay_ms_ = 21600000;
  clear_has_perf_counter_delay_ms();
}
::google::protobuf::int32 ClientConfigP::perf_counter_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
  return perf_counter_delay_ms_;
}
void ClientConfigP::set_perf_counter_delay_ms(::google::protobuf::int32 value) {
  set_has_perf_counter_delay_ms();
  perf_counter_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.perf_counter_delay_ms)
}

// optional int32 max_exponential_backoff_factor = 6 [default = 500];
bool ClientConfigP::has_max_exponential_backoff_factor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ClientConfigP::set_has_max_exponential_backoff_factor() {
  _has_bits_[0] |= 0x00000200u;
}
void ClientConfigP::clear_has_max_exponential_backoff_factor() {
  _has_bits_[0] &= ~0x00000200u;
}
void ClientConfigP::clear_max_exponential_backoff_factor() {
  max_exponential_backoff_factor_ = 500;
  clear_has_max_exponential_backoff_factor();
}
::google::protobuf::int32 ClientConfigP::max_exponential_backoff_factor() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
  return max_exponential_backoff_factor_;
}
void ClientConfigP::set_max_exponential_backoff_factor(::google::protobuf::int32 value) {
  set_has_max_exponential_backoff_factor();
  max_exponential_backoff_factor_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.max_exponential_backoff_factor)
}

// optional int32 smear_percent = 7 [default = 20];
bool ClientConfigP::has_smear_percent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ClientConfigP::set_has_smear_percent() {
  _has_bits_[0] |= 0x00000400u;
}
void ClientConfigP::clear_has_smear_percent() {
  _has_bits_[0] &= ~0x00000400u;
}
void ClientConfigP::clear_smear_percent() {
  smear_percent_ = 20;
  clear_has_smear_percent();
}
::google::protobuf::int32 ClientConfigP::smear_percent() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.smear_percent)
  return smear_percent_;
}
void ClientConfigP::set_smear_percent(::google::protobuf::int32 value) {
  set_has_smear_percent();
  smear_percent_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.smear_percent)
}

// optional bool is_transient = 8 [default = false];
bool ClientConfigP::has_is_transient() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ClientConfigP::set_has_is_transient() {
  _has_bits_[0] |= 0x00000004u;
}
void ClientConfigP::clear_has_is_transient() {
  _has_bits_[0] &= ~0x00000004u;
}
void ClientConfigP::clear_is_transient() {
  is_transient_ = false;
  clear_has_is_transient();
}
bool ClientConfigP::is_transient() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.is_transient)
  return is_transient_;
}
void ClientConfigP::set_is_transient(bool value) {
  set_has_is_transient();
  is_transient_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.is_transient)
}

// optional int32 initial_persistent_heartbeat_delay_ms = 9 [default = 2000];
bool ClientConfigP::has_initial_persistent_heartbeat_delay_ms() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ClientConfigP::set_has_initial_persistent_heartbeat_delay_ms() {
  _has_bits_[0] |= 0x00000800u;
}
void ClientConfigP::clear_has_initial_persistent_heartbeat_delay_ms() {
  _has_bits_[0] &= ~0x00000800u;
}
void ClientConfigP::clear_initial_persistent_heartbeat_delay_ms() {
  initial_persistent_heartbeat_delay_ms_ = 2000;
  clear_has_initial_persistent_heartbeat_delay_ms();
}
::google::protobuf::int32 ClientConfigP::initial_persistent_heartbeat_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
  return initial_persistent_heartbeat_delay_ms_;
}
void ClientConfigP::set_initial_persistent_heartbeat_delay_ms(::google::protobuf::int32 value) {
  set_has_initial_persistent_heartbeat_delay_ms();
  initial_persistent_heartbeat_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.initial_persistent_heartbeat_delay_ms)
}

// optional .ipc.invalidation.ProtocolHandlerConfigP protocol_handler_config = 10;
bool ClientConfigP::has_protocol_handler_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClientConfigP::set_has_protocol_handler_config() {
  _has_bits_[0] |= 0x00000002u;
}
void ClientConfigP::clear_has_protocol_handler_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClientConfigP::clear_protocol_handler_config() {
  if (protocol_handler_config_ != NULL) protocol_handler_config_->::ipc::invalidation::ProtocolHandlerConfigP::Clear();
  clear_has_protocol_handler_config();
}
const ::ipc::invalidation::ProtocolHandlerConfigP& ClientConfigP::protocol_handler_config() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.protocol_handler_config)
  return protocol_handler_config_ != NULL ? *protocol_handler_config_
                         : *::ipc::invalidation::ProtocolHandlerConfigP::internal_default_instance();
}
::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::mutable_protocol_handler_config() {
  set_has_protocol_handler_config();
  if (protocol_handler_config_ == NULL) {
    protocol_handler_config_ = new ::ipc::invalidation::ProtocolHandlerConfigP;
  }
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ClientConfigP.protocol_handler_config)
  return protocol_handler_config_;
}
::ipc::invalidation::ProtocolHandlerConfigP* ClientConfigP::release_protocol_handler_config() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ClientConfigP.protocol_handler_config)
  clear_has_protocol_handler_config();
  ::ipc::invalidation::ProtocolHandlerConfigP* temp = protocol_handler_config_;
  protocol_handler_config_ = NULL;
  return temp;
}
void ClientConfigP::set_allocated_protocol_handler_config(::ipc::invalidation::ProtocolHandlerConfigP* protocol_handler_config) {
  delete protocol_handler_config_;
  protocol_handler_config_ = protocol_handler_config;
  if (protocol_handler_config) {
    set_has_protocol_handler_config();
  } else {
    clear_has_protocol_handler_config();
  }
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ClientConfigP.protocol_handler_config)
}

// optional bool channel_supports_offline_delivery = 11 [default = false];
bool ClientConfigP::has_channel_supports_offline_delivery() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ClientConfigP::set_has_channel_supports_offline_delivery() {
  _has_bits_[0] |= 0x00000008u;
}
void ClientConfigP::clear_has_channel_supports_offline_delivery() {
  _has_bits_[0] &= ~0x00000008u;
}
void ClientConfigP::clear_channel_supports_offline_delivery() {
  channel_supports_offline_delivery_ = false;
  clear_has_channel_supports_offline_delivery();
}
bool ClientConfigP::channel_supports_offline_delivery() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
  return channel_supports_offline_delivery_;
}
void ClientConfigP::set_channel_supports_offline_delivery(bool value) {
  set_has_channel_supports_offline_delivery();
  channel_supports_offline_delivery_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.channel_supports_offline_delivery)
}

// optional int32 offline_heartbeat_threshold_ms = 12 [default = 60000];
bool ClientConfigP::has_offline_heartbeat_threshold_ms() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ClientConfigP::set_has_offline_heartbeat_threshold_ms() {
  _has_bits_[0] |= 0x00001000u;
}
void ClientConfigP::clear_has_offline_heartbeat_threshold_ms() {
  _has_bits_[0] &= ~0x00001000u;
}
void ClientConfigP::clear_offline_heartbeat_threshold_ms() {
  offline_heartbeat_threshold_ms_ = 60000;
  clear_has_offline_heartbeat_threshold_ms();
}
::google::protobuf::int32 ClientConfigP::offline_heartbeat_threshold_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
  return offline_heartbeat_threshold_ms_;
}
void ClientConfigP::set_offline_heartbeat_threshold_ms(::google::protobuf::int32 value) {
  set_has_offline_heartbeat_threshold_ms();
  offline_heartbeat_threshold_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.offline_heartbeat_threshold_ms)
}

// optional bool allow_suppression = 13 [default = true];
bool ClientConfigP::has_allow_suppression() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ClientConfigP::set_has_allow_suppression() {
  _has_bits_[0] |= 0x00000010u;
}
void ClientConfigP::clear_has_allow_suppression() {
  _has_bits_[0] &= ~0x00000010u;
}
void ClientConfigP::clear_allow_suppression() {
  allow_suppression_ = true;
  clear_has_allow_suppression();
}
bool ClientConfigP::allow_suppression() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ClientConfigP.allow_suppression)
  return allow_suppression_;
}
void ClientConfigP::set_allow_suppression(bool value) {
  set_has_allow_suppression();
  allow_suppression_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ClientConfigP.allow_suppression)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConfigChangeMessage::kNextMessageDelayMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConfigChangeMessage::ConfigChangeMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ConfigChangeMessage)
}
ConfigChangeMessage::ConfigChangeMessage(const ConfigChangeMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  next_message_delay_ms_ = from.next_message_delay_ms_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ConfigChangeMessage)
}

void ConfigChangeMessage::SharedCtor() {
  _cached_size_ = 0;
  next_message_delay_ms_ = GOOGLE_LONGLONG(0);
}

ConfigChangeMessage::~ConfigChangeMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ConfigChangeMessage)
  SharedDtor();
}

void ConfigChangeMessage::SharedDtor() {
}

void ConfigChangeMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ConfigChangeMessage& ConfigChangeMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ConfigChangeMessage* ConfigChangeMessage::New(::google::protobuf::Arena* arena) const {
  ConfigChangeMessage* n = new ConfigChangeMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConfigChangeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ConfigChangeMessage)
  next_message_delay_ms_ = GOOGLE_LONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ConfigChangeMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ConfigChangeMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 next_message_delay_ms = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          set_has_next_message_delay_ms();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &next_message_delay_ms_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ConfigChangeMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ConfigChangeMessage)
  return false;
#undef DO_
}

void ConfigChangeMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ConfigChangeMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 next_message_delay_ms = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->next_message_delay_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ConfigChangeMessage)
}

size_t ConfigChangeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ConfigChangeMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  // optional int64 next_message_delay_ms = 1;
  if (has_next_message_delay_ms()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->next_message_delay_ms());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConfigChangeMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ConfigChangeMessage*>(&from));
}

void ConfigChangeMessage::MergeFrom(const ConfigChangeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ConfigChangeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_next_message_delay_ms()) {
    set_next_message_delay_ms(from.next_message_delay_ms());
  }
}

void ConfigChangeMessage::CopyFrom(const ConfigChangeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ConfigChangeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigChangeMessage::IsInitialized() const {
  return true;
}

void ConfigChangeMessage::Swap(ConfigChangeMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConfigChangeMessage::InternalSwap(ConfigChangeMessage* other) {
  std::swap(next_message_delay_ms_, other->next_message_delay_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ConfigChangeMessage::GetTypeName() const {
  return "ipc.invalidation.ConfigChangeMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConfigChangeMessage

// optional int64 next_message_delay_ms = 1;
bool ConfigChangeMessage::has_next_message_delay_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ConfigChangeMessage::set_has_next_message_delay_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void ConfigChangeMessage::clear_has_next_message_delay_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void ConfigChangeMessage::clear_next_message_delay_ms() {
  next_message_delay_ms_ = GOOGLE_LONGLONG(0);
  clear_has_next_message_delay_ms();
}
::google::protobuf::int64 ConfigChangeMessage::next_message_delay_ms() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
  return next_message_delay_ms_;
}
void ConfigChangeMessage::set_next_message_delay_ms(::google::protobuf::int64 value) {
  set_has_next_message_delay_ms();
  next_message_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ConfigChangeMessage.next_message_delay_ms)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ErrorMessage::kCodeFieldNumber;
const int ErrorMessage::kDescriptionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ErrorMessage::ErrorMessage()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    protobuf_client_5fprotocol_2eproto::InitDefaults();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:ipc.invalidation.ErrorMessage)
}
ErrorMessage::ErrorMessage(const ErrorMessage& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_description()) {
    description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
  }
  code_ = from.code_;
  // @@protoc_insertion_point(copy_constructor:ipc.invalidation.ErrorMessage)
}

void ErrorMessage::SharedCtor() {
  _cached_size_ = 0;
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  code_ = 1;
}

ErrorMessage::~ErrorMessage() {
  // @@protoc_insertion_point(destructor:ipc.invalidation.ErrorMessage)
  SharedDtor();
}

void ErrorMessage::SharedDtor() {
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void ErrorMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ErrorMessage& ErrorMessage::default_instance() {
  protobuf_client_5fprotocol_2eproto::InitDefaults();
  return *internal_default_instance();
}

ErrorMessage* ErrorMessage::New(::google::protobuf::Arena* arena) const {
  ErrorMessage* n = new ErrorMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ErrorMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ipc.invalidation.ErrorMessage)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_description()) {
      GOOGLE_DCHECK(!description_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*description_.UnsafeRawStringPointer())->clear();
    }
    code_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ErrorMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(&_internal_metadata_,
          &::google::protobuf::internal::InternalMetadataWithArenaLite::
              mutable_unknown_fields));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:ipc.invalidation.ErrorMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ipc.invalidation.ErrorMessage.Code code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ipc::invalidation::ErrorMessage_Code_IsValid(value)) {
            set_code(static_cast< ::ipc::invalidation::ErrorMessage_Code >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string description = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:ipc.invalidation.ErrorMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:ipc.invalidation.ErrorMessage)
  return false;
#undef DO_
}

void ErrorMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:ipc.invalidation.ErrorMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ipc.invalidation.ErrorMessage.Code code = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->description(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:ipc.invalidation.ErrorMessage)
}

size_t ErrorMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ipc.invalidation.ErrorMessage)
  size_t total_size = 0;

  total_size += unknown_fields().size();

  if (_has_bits_[0 / 32] & 3u) {
    // optional string description = 2;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

    // optional .ipc.invalidation.ErrorMessage.Code code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ErrorMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ErrorMessage*>(&from));
}

void ErrorMessage::MergeFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ipc.invalidation.ErrorMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_description();
      description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
    if (cached_has_bits & 0x00000002u) {
      code_ = from.code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ErrorMessage::CopyFrom(const ErrorMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ipc.invalidation.ErrorMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorMessage::IsInitialized() const {
  return true;
}

void ErrorMessage::Swap(ErrorMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ErrorMessage::InternalSwap(ErrorMessage* other) {
  description_.Swap(&other->description_);
  std::swap(code_, other->code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ErrorMessage::GetTypeName() const {
  return "ipc.invalidation.ErrorMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ErrorMessage

// optional .ipc.invalidation.ErrorMessage.Code code = 1;
bool ErrorMessage::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ErrorMessage::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
void ErrorMessage::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
void ErrorMessage::clear_code() {
  code_ = 1;
  clear_has_code();
}
::ipc::invalidation::ErrorMessage_Code ErrorMessage::code() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.code)
  return static_cast< ::ipc::invalidation::ErrorMessage_Code >(code_);
}
void ErrorMessage::set_code(::ipc::invalidation::ErrorMessage_Code value) {
  assert(::ipc::invalidation::ErrorMessage_Code_IsValid(value));
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.code)
}

// optional string description = 2;
bool ErrorMessage::has_description() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ErrorMessage::set_has_description() {
  _has_bits_[0] |= 0x00000001u;
}
void ErrorMessage::clear_has_description() {
  _has_bits_[0] &= ~0x00000001u;
}
void ErrorMessage::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
const ::std::string& ErrorMessage::description() const {
  // @@protoc_insertion_point(field_get:ipc.invalidation.ErrorMessage.description)
  return description_.GetNoArena();
}
void ErrorMessage::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ipc.invalidation.ErrorMessage.description)
}
#if LANG_CXX11
void ErrorMessage::set_description(::std::string&& value) {
  set_has_description();
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ipc.invalidation.ErrorMessage.description)
}
#endif
void ErrorMessage::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ipc.invalidation.ErrorMessage.description)
}
void ErrorMessage::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ipc.invalidation.ErrorMessage.description)
}
::std::string* ErrorMessage::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:ipc.invalidation.ErrorMessage.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* ErrorMessage::release_description() {
  // @@protoc_insertion_point(field_release:ipc.invalidation.ErrorMessage.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void ErrorMessage::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:ipc.invalidation.ErrorMessage.description)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace invalidation
}  // namespace ipc

// @@protoc_insertion_point(global_scope)
