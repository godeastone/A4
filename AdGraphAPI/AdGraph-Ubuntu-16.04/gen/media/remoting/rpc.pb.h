// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rpc.proto

#ifndef PROTOBUF_rpc_2eproto__INCLUDED
#define PROTOBUF_rpc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003002 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace media {
namespace remoting {
namespace pb {
class AudioDecoderConfig;
class AudioDecoderConfigDefaultTypeInternal;
extern AudioDecoderConfigDefaultTypeInternal _AudioDecoderConfig_default_instance_;
class CdmClientOnSessionExpirationUpdate;
class CdmClientOnSessionExpirationUpdateDefaultTypeInternal;
extern CdmClientOnSessionExpirationUpdateDefaultTypeInternal _CdmClientOnSessionExpirationUpdate_default_instance_;
class CdmClientOnSessionKeysChange;
class CdmClientOnSessionKeysChangeDefaultTypeInternal;
extern CdmClientOnSessionKeysChangeDefaultTypeInternal _CdmClientOnSessionKeysChange_default_instance_;
class CdmClientOnSessionMessage;
class CdmClientOnSessionMessageDefaultTypeInternal;
extern CdmClientOnSessionMessageDefaultTypeInternal _CdmClientOnSessionMessage_default_instance_;
class CdmCloseSession;
class CdmCloseSessionDefaultTypeInternal;
extern CdmCloseSessionDefaultTypeInternal _CdmCloseSession_default_instance_;
class CdmCreateSessionAndGenerateRequest;
class CdmCreateSessionAndGenerateRequestDefaultTypeInternal;
extern CdmCreateSessionAndGenerateRequestDefaultTypeInternal _CdmCreateSessionAndGenerateRequest_default_instance_;
class CdmInitialize;
class CdmInitializeDefaultTypeInternal;
extern CdmInitializeDefaultTypeInternal _CdmInitialize_default_instance_;
class CdmKeyInformation;
class CdmKeyInformationDefaultTypeInternal;
extern CdmKeyInformationDefaultTypeInternal _CdmKeyInformation_default_instance_;
class CdmLoadSession;
class CdmLoadSessionDefaultTypeInternal;
extern CdmLoadSessionDefaultTypeInternal _CdmLoadSession_default_instance_;
class CdmPromise;
class CdmPromiseDefaultTypeInternal;
extern CdmPromiseDefaultTypeInternal _CdmPromise_default_instance_;
class CdmRemoveSession;
class CdmRemoveSessionDefaultTypeInternal;
extern CdmRemoveSessionDefaultTypeInternal _CdmRemoveSession_default_instance_;
class CdmSetServerCertificate;
class CdmSetServerCertificateDefaultTypeInternal;
extern CdmSetServerCertificateDefaultTypeInternal _CdmSetServerCertificate_default_instance_;
class CdmUpdateSession;
class CdmUpdateSessionDefaultTypeInternal;
extern CdmUpdateSessionDefaultTypeInternal _CdmUpdateSession_default_instance_;
class DecoderBuffer;
class DecoderBufferDefaultTypeInternal;
extern DecoderBufferDefaultTypeInternal _DecoderBuffer_default_instance_;
class DecryptConfig;
class DecryptConfigDefaultTypeInternal;
extern DecryptConfigDefaultTypeInternal _DecryptConfig_default_instance_;
class DecryptConfig_SubSample;
class DecryptConfig_SubSampleDefaultTypeInternal;
extern DecryptConfig_SubSampleDefaultTypeInternal _DecryptConfig_SubSample_default_instance_;
class DemuxerStreamInitializeCallback;
class DemuxerStreamInitializeCallbackDefaultTypeInternal;
extern DemuxerStreamInitializeCallbackDefaultTypeInternal _DemuxerStreamInitializeCallback_default_instance_;
class DemuxerStreamReadUntil;
class DemuxerStreamReadUntilDefaultTypeInternal;
extern DemuxerStreamReadUntilDefaultTypeInternal _DemuxerStreamReadUntil_default_instance_;
class DemuxerStreamReadUntilCallback;
class DemuxerStreamReadUntilCallbackDefaultTypeInternal;
extern DemuxerStreamReadUntilCallbackDefaultTypeInternal _DemuxerStreamReadUntilCallback_default_instance_;
class EncryptionScheme;
class EncryptionSchemeDefaultTypeInternal;
extern EncryptionSchemeDefaultTypeInternal _EncryptionScheme_default_instance_;
class PipelineStatistics;
class PipelineStatisticsDefaultTypeInternal;
extern PipelineStatisticsDefaultTypeInternal _PipelineStatistics_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RendererClientOnAudioConfigChange;
class RendererClientOnAudioConfigChangeDefaultTypeInternal;
extern RendererClientOnAudioConfigChangeDefaultTypeInternal _RendererClientOnAudioConfigChange_default_instance_;
class RendererClientOnBufferingStateChange;
class RendererClientOnBufferingStateChangeDefaultTypeInternal;
extern RendererClientOnBufferingStateChangeDefaultTypeInternal _RendererClientOnBufferingStateChange_default_instance_;
class RendererClientOnTimeUpdate;
class RendererClientOnTimeUpdateDefaultTypeInternal;
extern RendererClientOnTimeUpdateDefaultTypeInternal _RendererClientOnTimeUpdate_default_instance_;
class RendererClientOnVideoConfigChange;
class RendererClientOnVideoConfigChangeDefaultTypeInternal;
extern RendererClientOnVideoConfigChangeDefaultTypeInternal _RendererClientOnVideoConfigChange_default_instance_;
class RendererFlushUntil;
class RendererFlushUntilDefaultTypeInternal;
extern RendererFlushUntilDefaultTypeInternal _RendererFlushUntil_default_instance_;
class RendererInitialize;
class RendererInitializeDefaultTypeInternal;
extern RendererInitializeDefaultTypeInternal _RendererInitialize_default_instance_;
class RendererSetCdm;
class RendererSetCdmDefaultTypeInternal;
extern RendererSetCdmDefaultTypeInternal _RendererSetCdm_default_instance_;
class RpcMessage;
class RpcMessageDefaultTypeInternal;
extern RpcMessageDefaultTypeInternal _RpcMessage_default_instance_;
class Size;
class SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class VideoDecoderConfig;
class VideoDecoderConfigDefaultTypeInternal;
extern VideoDecoderConfigDefaultTypeInternal _VideoDecoderConfig_default_instance_;
}  // namespace pb
}  // namespace remoting
}  // namespace media

namespace media {
namespace remoting {
namespace pb {

namespace protobuf_rpc_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_rpc_2eproto

enum EncryptionScheme_CipherMode {
  EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED = 0,
  EncryptionScheme_CipherMode_CIPHER_MODE_AES_CTR = 1,
  EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC = 2
};
bool EncryptionScheme_CipherMode_IsValid(int value);
const EncryptionScheme_CipherMode EncryptionScheme_CipherMode_CipherMode_MIN = EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED;
const EncryptionScheme_CipherMode EncryptionScheme_CipherMode_CipherMode_MAX = EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC;
const int EncryptionScheme_CipherMode_CipherMode_ARRAYSIZE = EncryptionScheme_CipherMode_CipherMode_MAX + 1;

enum AudioDecoderConfig_Codec {
  AudioDecoderConfig_Codec_kUnknownAudioCodec = 0,
  AudioDecoderConfig_Codec_kCodecAAC = 1,
  AudioDecoderConfig_Codec_kCodecMP3 = 2,
  AudioDecoderConfig_Codec_kCodecPCM = 3,
  AudioDecoderConfig_Codec_kCodecVorbis = 4,
  AudioDecoderConfig_Codec_kCodecFLAC = 5,
  AudioDecoderConfig_Codec_kCodecAMR_NB = 6,
  AudioDecoderConfig_Codec_kCodecAMR_WB = 7,
  AudioDecoderConfig_Codec_kCodecPCM_MULAW = 8,
  AudioDecoderConfig_Codec_kCodecGSM_MS = 9,
  AudioDecoderConfig_Codec_kCodecPCM_S16BE = 10,
  AudioDecoderConfig_Codec_kCodecPCM_S24BE = 11,
  AudioDecoderConfig_Codec_kCodecOpus = 12,
  AudioDecoderConfig_Codec_kCodecEAC3 = 13,
  AudioDecoderConfig_Codec_kCodecPCM_ALAW = 14,
  AudioDecoderConfig_Codec_kCodecALAC = 15,
  AudioDecoderConfig_Codec_kCodecAC3 = 16,
  AudioDecoderConfig_Codec_kCodecMpegHAudio = 17
};
bool AudioDecoderConfig_Codec_IsValid(int value);
const AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MIN = AudioDecoderConfig_Codec_kUnknownAudioCodec;
const AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MAX = AudioDecoderConfig_Codec_kCodecMpegHAudio;
const int AudioDecoderConfig_Codec_Codec_ARRAYSIZE = AudioDecoderConfig_Codec_Codec_MAX + 1;

enum AudioDecoderConfig_SampleFormat {
  AudioDecoderConfig_SampleFormat_kUnknownSampleFormat = 0,
  AudioDecoderConfig_SampleFormat_kSampleFormatU8 = 1,
  AudioDecoderConfig_SampleFormat_kSampleFormatS16 = 2,
  AudioDecoderConfig_SampleFormat_kSampleFormatS32 = 3,
  AudioDecoderConfig_SampleFormat_kSampleFormatF32 = 4,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16 = 5,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32 = 6,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32 = 7,
  AudioDecoderConfig_SampleFormat_kSampleFormatS24 = 8,
  AudioDecoderConfig_SampleFormat_kSampleFormatAc3 = 9,
  AudioDecoderConfig_SampleFormat_kSampleFormatEac3 = 10,
  AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio = 11
};
bool AudioDecoderConfig_SampleFormat_IsValid(int value);
const AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MIN = AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
const AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MAX = AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio;
const int AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE = AudioDecoderConfig_SampleFormat_SampleFormat_MAX + 1;

enum AudioDecoderConfig_ChannelLayout {
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE = 0,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED = 1,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO = 2,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO = 3,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1 = 4,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND = 5,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0 = 6,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2 = 7,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD = 8,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0 = 9,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1 = 10,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK = 11,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK = 12,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0 = 13,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1 = 14,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE = 15,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX = 16,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1 = 17,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1 = 18,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1 = 19,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0 = 20,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT = 21,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL = 22,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1 = 23,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK = 24,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT = 25,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT = 26,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK = 27,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL = 28,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE = 29,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC = 30,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE = 31,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM = 32
};
bool AudioDecoderConfig_ChannelLayout_IsValid(int value);
const AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
const AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
const int AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE = AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX + 1;

enum VideoDecoderConfig_Codec {
  VideoDecoderConfig_Codec_kUnknownVideoCodec = 0,
  VideoDecoderConfig_Codec_kCodecH264 = 1,
  VideoDecoderConfig_Codec_kCodecVC1 = 2,
  VideoDecoderConfig_Codec_kCodecMPEG2 = 3,
  VideoDecoderConfig_Codec_kCodecMPEG4 = 4,
  VideoDecoderConfig_Codec_kCodecTheora = 5,
  VideoDecoderConfig_Codec_kCodecVP8 = 6,
  VideoDecoderConfig_Codec_kCodecVP9 = 7,
  VideoDecoderConfig_Codec_kCodecHEVC = 8,
  VideoDecoderConfig_Codec_kCodecDolbyVision = 9,
  VideoDecoderConfig_Codec_kCodecAV1 = 10
};
bool VideoDecoderConfig_Codec_IsValid(int value);
const VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MIN = VideoDecoderConfig_Codec_kUnknownVideoCodec;
const VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MAX = VideoDecoderConfig_Codec_kCodecAV1;
const int VideoDecoderConfig_Codec_Codec_ARRAYSIZE = VideoDecoderConfig_Codec_Codec_MAX + 1;

enum VideoDecoderConfig_Profile {
  VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN = -1,
  VideoDecoderConfig_Profile_H264PROFILE_BASELINE = 0,
  VideoDecoderConfig_Profile_H264PROFILE_MAIN = 1,
  VideoDecoderConfig_Profile_H264PROFILE_EXTENDED = 2,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH = 3,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE = 4,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE = 5,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE = 6,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE = 7,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH = 8,
  VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH = 9,
  VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH = 10,
  VideoDecoderConfig_Profile_VP8PROFILE_ANY = 11,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0 = 12,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1 = 13,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2 = 14,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3 = 15,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN = 16,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10 = 17,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE = 18,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0 = 19,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4 = 20,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5 = 21,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7 = 22,
  VideoDecoderConfig_Profile_THEORAPROFILE_ANY = 23,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE0 = 24
};
bool VideoDecoderConfig_Profile_IsValid(int value);
const VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MIN = VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
const VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MAX = VideoDecoderConfig_Profile_AV1PROFILE_PROFILE0;
const int VideoDecoderConfig_Profile_Profile_ARRAYSIZE = VideoDecoderConfig_Profile_Profile_MAX + 1;

enum VideoDecoderConfig_Format {
  VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN = 0,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420 = 1,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YV12 = 2,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I422 = 3,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420A = 4,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I444 = 5,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV12 = 6,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV21 = 7,
  VideoDecoderConfig_Format_PIXEL_FORMAT_UYVY = 8,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2 = 9,
  VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB = 10,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB = 11,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24 = 12,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32 = 13,
  VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG = 14,
  VideoDecoderConfig_Format_PIXEL_FORMAT_MT21 = 15,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9 = 16,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10 = 17,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9 = 18,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10 = 19,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9 = 20,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10 = 21,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12 = 22,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12 = 23,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12 = 24,
  VideoDecoderConfig_Format_PIXEL_FORMAT_Y8 PROTOBUF_DEPRECATED = 25,
  VideoDecoderConfig_Format_PIXEL_FORMAT_Y16 = 26
};
bool VideoDecoderConfig_Format_IsValid(int value);
const VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MIN = VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
const VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MAX = VideoDecoderConfig_Format_PIXEL_FORMAT_Y16;
const int VideoDecoderConfig_Format_Format_ARRAYSIZE = VideoDecoderConfig_Format_Format_MAX + 1;

enum VideoDecoderConfig_ColorSpace {
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED = 0,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG = 1,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709 = 2,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601 = 3
};
bool VideoDecoderConfig_ColorSpace_IsValid(int value);
const VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MIN = VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
const VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MAX = VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
const int VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE = VideoDecoderConfig_ColorSpace_ColorSpace_MAX + 1;

enum CdmKeyInformation_KeyStatus {
  CdmKeyInformation_KeyStatus_USABLE = 0,
  CdmKeyInformation_KeyStatus_INTERNAL_ERROR = 1,
  CdmKeyInformation_KeyStatus_EXPIRED = 2,
  CdmKeyInformation_KeyStatus_OUTPUT_RESTRICTED = 3,
  CdmKeyInformation_KeyStatus_OUTPUT_DOWNSCALED = 4,
  CdmKeyInformation_KeyStatus_KEY_STATUS_PENDING = 5,
  CdmKeyInformation_KeyStatus_RELEASED = 6
};
bool CdmKeyInformation_KeyStatus_IsValid(int value);
const CdmKeyInformation_KeyStatus CdmKeyInformation_KeyStatus_KeyStatus_MIN = CdmKeyInformation_KeyStatus_USABLE;
const CdmKeyInformation_KeyStatus CdmKeyInformation_KeyStatus_KeyStatus_MAX = CdmKeyInformation_KeyStatus_RELEASED;
const int CdmKeyInformation_KeyStatus_KeyStatus_ARRAYSIZE = CdmKeyInformation_KeyStatus_KeyStatus_MAX + 1;

enum RendererClientOnBufferingStateChange_State {
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING = 0,
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH = 1
};
bool RendererClientOnBufferingStateChange_State_IsValid(int value);
const RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MIN = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
const RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MAX = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
const int RendererClientOnBufferingStateChange_State_State_ARRAYSIZE = RendererClientOnBufferingStateChange_State_State_MAX + 1;

enum DemuxerStreamReadUntilCallback_Status {
  DemuxerStreamReadUntilCallback_Status_kOk = 0,
  DemuxerStreamReadUntilCallback_Status_kAborted = 1,
  DemuxerStreamReadUntilCallback_Status_kConfigChanged = 2,
  DemuxerStreamReadUntilCallback_Status_kError = 3
};
bool DemuxerStreamReadUntilCallback_Status_IsValid(int value);
const DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MIN = DemuxerStreamReadUntilCallback_Status_kOk;
const DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MAX = DemuxerStreamReadUntilCallback_Status_kError;
const int DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE = DemuxerStreamReadUntilCallback_Status_Status_MAX + 1;

enum CdmCreateSessionAndGenerateRequest_EmeInitDataType {
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN = 0,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_WEBM = 1,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_CENC = 2,
  CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS = 3
};
bool CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(int value);
const CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MIN = CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN;
const CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX = CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS;
const int CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_ARRAYSIZE = CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX + 1;

enum RpcMessage_RpcProc {
  RpcMessage_RpcProc_RPC_INTERNAL = 0,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER = 1,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE = 2,
  RpcMessage_RpcProc_RPC_ACQUIRE_CDM = 3,
  RpcMessage_RpcProc_RPC_ACQUIRE_CDM_DONE = 4,
  RpcMessage_RpcProc_RPC_R_INITIALIZE = 1000,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL = 1001,
  RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM = 1002,
  RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE = 1003,
  RpcMessage_RpcProc_RPC_R_SETVOLUME = 1004,
  RpcMessage_RpcProc_RPC_R_SETCDM = 1005,
  RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK = 1100,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK = 1101,
  RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK = 1102,
  RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE = 2000,
  RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE = 2001,
  RpcMessage_RpcProc_RPC_RC_ONENDED = 2002,
  RpcMessage_RpcProc_RPC_RC_ONERROR = 2003,
  RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE = 2004,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE = 2005,
  RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE = 2006,
  RpcMessage_RpcProc_RPC_RC_ONWAITINGFORDECRYPTIONKEY = 2007,
  RpcMessage_RpcProc_RPC_RC_ONDURATIONCHANGE = 2008,
  RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE = 2009,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE = 2010,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE = 3000,
  RpcMessage_RpcProc_RPC_DS_READUNTIL = 3001,
  RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER = 3002,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK = 3100,
  RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK = 3101,
  RpcMessage_RpcProc_RPC_CDM_SETCLIENT = 4000,
  RpcMessage_RpcProc_RPC_CDM_INITIALIZE = 4001,
  RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE = 4002,
  RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST = 4003,
  RpcMessage_RpcProc_RPC_CDM_LOADSESSION = 4004,
  RpcMessage_RpcProc_RPC_CDM_UPDATESESSION = 4005,
  RpcMessage_RpcProc_RPC_CDM_CLOSESESSION = 4006,
  RpcMessage_RpcProc_RPC_CDM_REMOVESESSION = 4007,
  RpcMessage_RpcProc_RPC_CDM_INITIALIZE_CALLBACK = 4100,
  RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE_CALLBACK = 4101,
  RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK = 4102,
  RpcMessage_RpcProc_RPC_CDM_LOADSESSION_CALLBACK = 4103,
  RpcMessage_RpcProc_RPC_CDM_UPDATESESSION_CALLBACK = 4104,
  RpcMessage_RpcProc_RPC_CDM_CLOSESESSION_CALLBACK = 4105,
  RpcMessage_RpcProc_RPC_CDM_REMOVESESSION_CALLBACK = 4106,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONMESSAGE = 5000,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONCLOSED = 5001,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONKEYSCHANGE = 5002,
  RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE = 5003
};
bool RpcMessage_RpcProc_IsValid(int value);
const RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MIN = RpcMessage_RpcProc_RPC_INTERNAL;
const RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MAX = RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE;
const int RpcMessage_RpcProc_RpcProc_ARRAYSIZE = RpcMessage_RpcProc_RpcProc_MAX + 1;

enum EncryptionMode {
  kUnencrypted = 0,
  kCenc = 1,
  kCbcs = 2
};
bool EncryptionMode_IsValid(int value);
const EncryptionMode EncryptionMode_MIN = kUnencrypted;
const EncryptionMode EncryptionMode_MAX = kCbcs;
const int EncryptionMode_ARRAYSIZE = EncryptionMode_MAX + 1;

enum CdmException {
  NOT_SUPPORTED_ERROR = 0,
  INVALID_STATE_ERROR = 1,
  INVALID_ACCESS_ERROR PROTOBUF_DEPRECATED = 2,
  QUOTA_EXCEEDED_ERROR = 3,
  UNKNOWN_ERROR PROTOBUF_DEPRECATED = 4,
  CLIENT_ERROR PROTOBUF_DEPRECATED = 5,
  OUTPUT_ERROR PROTOBUF_DEPRECATED = 6,
  TYPE_ERROR = 7
};
bool CdmException_IsValid(int value);
const CdmException CdmException_MIN = NOT_SUPPORTED_ERROR;
const CdmException CdmException_MAX = TYPE_ERROR;
const int CdmException_ARRAYSIZE = CdmException_MAX + 1;

enum CdmMessageType {
  LICENSE_REQUEST = 0,
  LICENSE_RENEWAL = 1,
  LICENSE_RELEASE = 2,
  INDIVIDUALIZATION_REQUEST = 3
};
bool CdmMessageType_IsValid(int value);
const CdmMessageType CdmMessageType_MIN = LICENSE_REQUEST;
const CdmMessageType CdmMessageType_MAX = INDIVIDUALIZATION_REQUEST;
const int CdmMessageType_ARRAYSIZE = CdmMessageType_MAX + 1;

enum CdmSessionType {
  TEMPORARY_SESSION = 0,
  PERSISTENT_LICENSE_SESSION = 1,
  PERSISTENT_RELEASE_MESSAGE_SESSION = 2
};
bool CdmSessionType_IsValid(int value);
const CdmSessionType CdmSessionType_MIN = TEMPORARY_SESSION;
const CdmSessionType CdmSessionType_MAX = PERSISTENT_RELEASE_MESSAGE_SESSION;
const int CdmSessionType_ARRAYSIZE = CdmSessionType_MAX + 1;

// ===================================================================

class DecoderBuffer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecoderBuffer) */ {
 public:
  DecoderBuffer();
  virtual ~DecoderBuffer();

  DecoderBuffer(const DecoderBuffer& from);

  inline DecoderBuffer& operator=(const DecoderBuffer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecoderBuffer& default_instance();

  static inline const DecoderBuffer* internal_default_instance() {
    return reinterpret_cast<const DecoderBuffer*>(
               &_DecoderBuffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DecoderBuffer* other);

  // implements Message ----------------------------------------------

  inline DecoderBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  DecoderBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DecoderBuffer& from);
  void MergeFrom(const DecoderBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecoderBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes side_data = 8;
  bool has_side_data() const;
  void clear_side_data();
  static const int kSideDataFieldNumber = 8;
  const ::std::string& side_data() const;
  void set_side_data(const ::std::string& value);
  #if LANG_CXX11
  void set_side_data(::std::string&& value);
  #endif
  void set_side_data(const char* value);
  void set_side_data(const void* value, size_t size);
  ::std::string* mutable_side_data();
  ::std::string* release_side_data();
  void set_allocated_side_data(::std::string* side_data);

  // optional .media.remoting.pb.DecryptConfig decrypt_config = 4;
  bool has_decrypt_config() const;
  void clear_decrypt_config();
  static const int kDecryptConfigFieldNumber = 4;
  const ::media::remoting::pb::DecryptConfig& decrypt_config() const;
  ::media::remoting::pb::DecryptConfig* mutable_decrypt_config();
  ::media::remoting::pb::DecryptConfig* release_decrypt_config();
  void set_allocated_decrypt_config(::media::remoting::pb::DecryptConfig* decrypt_config);

  // optional int64 timestamp_usec = 1;
  bool has_timestamp_usec() const;
  void clear_timestamp_usec();
  static const int kTimestampUsecFieldNumber = 1;
  ::google::protobuf::int64 timestamp_usec() const;
  void set_timestamp_usec(::google::protobuf::int64 value);

  // optional int64 duration_usec = 2;
  bool has_duration_usec() const;
  void clear_duration_usec();
  static const int kDurationUsecFieldNumber = 2;
  ::google::protobuf::int64 duration_usec() const;
  void set_duration_usec(::google::protobuf::int64 value);

  // optional int64 front_discard_usec = 5;
  bool has_front_discard_usec() const;
  void clear_front_discard_usec();
  static const int kFrontDiscardUsecFieldNumber = 5;
  ::google::protobuf::int64 front_discard_usec() const;
  void set_front_discard_usec(::google::protobuf::int64 value);

  // optional int64 back_discard_usec = 6;
  bool has_back_discard_usec() const;
  void clear_back_discard_usec();
  static const int kBackDiscardUsecFieldNumber = 6;
  ::google::protobuf::int64 back_discard_usec() const;
  void set_back_discard_usec(::google::protobuf::int64 value);

  // optional int64 splice_timestamp_usec = 7 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_splice_timestamp_usec() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_splice_timestamp_usec();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kSpliceTimestampUsecFieldNumber = 7;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::int64 splice_timestamp_usec() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_splice_timestamp_usec(::google::protobuf::int64 value);

  // optional bool is_key_frame = 3;
  bool has_is_key_frame() const;
  void clear_is_key_frame();
  static const int kIsKeyFrameFieldNumber = 3;
  bool is_key_frame() const;
  void set_is_key_frame(bool value);

  // optional bool is_eos = 9;
  bool has_is_eos() const;
  void clear_is_eos();
  static const int kIsEosFieldNumber = 9;
  bool is_eos() const;
  void set_is_eos(bool value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecoderBuffer)
 private:
  void set_has_timestamp_usec();
  void clear_has_timestamp_usec();
  void set_has_duration_usec();
  void clear_has_duration_usec();
  void set_has_is_key_frame();
  void clear_has_is_key_frame();
  void set_has_decrypt_config();
  void clear_has_decrypt_config();
  void set_has_front_discard_usec();
  void clear_has_front_discard_usec();
  void set_has_back_discard_usec();
  void clear_has_back_discard_usec();
  void set_has_splice_timestamp_usec();
  void clear_has_splice_timestamp_usec();
  void set_has_side_data();
  void clear_has_side_data();
  void set_has_is_eos();
  void clear_has_is_eos();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr side_data_;
  ::media::remoting::pb::DecryptConfig* decrypt_config_;
  ::google::protobuf::int64 timestamp_usec_;
  ::google::protobuf::int64 duration_usec_;
  ::google::protobuf::int64 front_discard_usec_;
  ::google::protobuf::int64 back_discard_usec_;
  ::google::protobuf::int64 splice_timestamp_usec_;
  bool is_key_frame_;
  bool is_eos_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Size : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.Size) */ {
 public:
  Size();
  virtual ~Size();

  Size(const Size& from);

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Size& default_instance();

  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Size* other);

  // implements Message ----------------------------------------------

  inline Size* New() const PROTOBUF_FINAL { return New(NULL); }

  Size* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Size* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.Size)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EncryptionScheme : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.EncryptionScheme) */ {
 public:
  EncryptionScheme();
  virtual ~EncryptionScheme();

  EncryptionScheme(const EncryptionScheme& from);

  inline EncryptionScheme& operator=(const EncryptionScheme& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const EncryptionScheme& default_instance();

  static inline const EncryptionScheme* internal_default_instance() {
    return reinterpret_cast<const EncryptionScheme*>(
               &_EncryptionScheme_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(EncryptionScheme* other);

  // implements Message ----------------------------------------------

  inline EncryptionScheme* New() const PROTOBUF_FINAL { return New(NULL); }

  EncryptionScheme* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const EncryptionScheme& from);
  void MergeFrom(const EncryptionScheme& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EncryptionScheme* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef EncryptionScheme_CipherMode CipherMode;
  static const CipherMode CIPHER_MODE_UNENCRYPTED =
    EncryptionScheme_CipherMode_CIPHER_MODE_UNENCRYPTED;
  static const CipherMode CIPHER_MODE_AES_CTR =
    EncryptionScheme_CipherMode_CIPHER_MODE_AES_CTR;
  static const CipherMode CIPHER_MODE_AES_CBC =
    EncryptionScheme_CipherMode_CIPHER_MODE_AES_CBC;
  static inline bool CipherMode_IsValid(int value) {
    return EncryptionScheme_CipherMode_IsValid(value);
  }
  static const CipherMode CipherMode_MIN =
    EncryptionScheme_CipherMode_CipherMode_MIN;
  static const CipherMode CipherMode_MAX =
    EncryptionScheme_CipherMode_CipherMode_MAX;
  static const int CipherMode_ARRAYSIZE =
    EncryptionScheme_CipherMode_CipherMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.EncryptionScheme.CipherMode mode = 1;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::media::remoting::pb::EncryptionScheme_CipherMode mode() const;
  void set_mode(::media::remoting::pb::EncryptionScheme_CipherMode value);

  // optional uint32 encrypt_blocks = 2;
  bool has_encrypt_blocks() const;
  void clear_encrypt_blocks();
  static const int kEncryptBlocksFieldNumber = 2;
  ::google::protobuf::uint32 encrypt_blocks() const;
  void set_encrypt_blocks(::google::protobuf::uint32 value);

  // optional uint32 skip_blocks = 3;
  bool has_skip_blocks() const;
  void clear_skip_blocks();
  static const int kSkipBlocksFieldNumber = 3;
  ::google::protobuf::uint32 skip_blocks() const;
  void set_skip_blocks(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.EncryptionScheme)
 private:
  void set_has_mode();
  void clear_has_mode();
  void set_has_encrypt_blocks();
  void clear_has_encrypt_blocks();
  void set_has_skip_blocks();
  void clear_has_skip_blocks();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int mode_;
  ::google::protobuf::uint32 encrypt_blocks_;
  ::google::protobuf::uint32 skip_blocks_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AudioDecoderConfig : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.AudioDecoderConfig) */ {
 public:
  AudioDecoderConfig();
  virtual ~AudioDecoderConfig();

  AudioDecoderConfig(const AudioDecoderConfig& from);

  inline AudioDecoderConfig& operator=(const AudioDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AudioDecoderConfig& default_instance();

  static inline const AudioDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const AudioDecoderConfig*>(
               &_AudioDecoderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(AudioDecoderConfig* other);

  // implements Message ----------------------------------------------

  inline AudioDecoderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  AudioDecoderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AudioDecoderConfig& from);
  void MergeFrom(const AudioDecoderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioDecoderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AudioDecoderConfig_Codec Codec;
  static const Codec kUnknownAudioCodec =
    AudioDecoderConfig_Codec_kUnknownAudioCodec;
  static const Codec kCodecAAC =
    AudioDecoderConfig_Codec_kCodecAAC;
  static const Codec kCodecMP3 =
    AudioDecoderConfig_Codec_kCodecMP3;
  static const Codec kCodecPCM =
    AudioDecoderConfig_Codec_kCodecPCM;
  static const Codec kCodecVorbis =
    AudioDecoderConfig_Codec_kCodecVorbis;
  static const Codec kCodecFLAC =
    AudioDecoderConfig_Codec_kCodecFLAC;
  static const Codec kCodecAMR_NB =
    AudioDecoderConfig_Codec_kCodecAMR_NB;
  static const Codec kCodecAMR_WB =
    AudioDecoderConfig_Codec_kCodecAMR_WB;
  static const Codec kCodecPCM_MULAW =
    AudioDecoderConfig_Codec_kCodecPCM_MULAW;
  static const Codec kCodecGSM_MS =
    AudioDecoderConfig_Codec_kCodecGSM_MS;
  static const Codec kCodecPCM_S16BE =
    AudioDecoderConfig_Codec_kCodecPCM_S16BE;
  static const Codec kCodecPCM_S24BE =
    AudioDecoderConfig_Codec_kCodecPCM_S24BE;
  static const Codec kCodecOpus =
    AudioDecoderConfig_Codec_kCodecOpus;
  static const Codec kCodecEAC3 =
    AudioDecoderConfig_Codec_kCodecEAC3;
  static const Codec kCodecPCM_ALAW =
    AudioDecoderConfig_Codec_kCodecPCM_ALAW;
  static const Codec kCodecALAC =
    AudioDecoderConfig_Codec_kCodecALAC;
  static const Codec kCodecAC3 =
    AudioDecoderConfig_Codec_kCodecAC3;
  static const Codec kCodecMpegHAudio =
    AudioDecoderConfig_Codec_kCodecMpegHAudio;
  static inline bool Codec_IsValid(int value) {
    return AudioDecoderConfig_Codec_IsValid(value);
  }
  static const Codec Codec_MIN =
    AudioDecoderConfig_Codec_Codec_MIN;
  static const Codec Codec_MAX =
    AudioDecoderConfig_Codec_Codec_MAX;
  static const int Codec_ARRAYSIZE =
    AudioDecoderConfig_Codec_Codec_ARRAYSIZE;

  typedef AudioDecoderConfig_SampleFormat SampleFormat;
  static const SampleFormat kUnknownSampleFormat =
    AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
  static const SampleFormat kSampleFormatU8 =
    AudioDecoderConfig_SampleFormat_kSampleFormatU8;
  static const SampleFormat kSampleFormatS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS16;
  static const SampleFormat kSampleFormatS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS32;
  static const SampleFormat kSampleFormatF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatF32;
  static const SampleFormat kSampleFormatPlanarS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16;
  static const SampleFormat kSampleFormatPlanarF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32;
  static const SampleFormat kSampleFormatPlanarS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32;
  static const SampleFormat kSampleFormatS24 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS24;
  static const SampleFormat kSampleFormatAc3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatAc3;
  static const SampleFormat kSampleFormatEac3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatEac3;
  static const SampleFormat kSampleFormatMpegHAudio =
    AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio;
  static inline bool SampleFormat_IsValid(int value) {
    return AudioDecoderConfig_SampleFormat_IsValid(value);
  }
  static const SampleFormat SampleFormat_MIN =
    AudioDecoderConfig_SampleFormat_SampleFormat_MIN;
  static const SampleFormat SampleFormat_MAX =
    AudioDecoderConfig_SampleFormat_SampleFormat_MAX;
  static const int SampleFormat_ARRAYSIZE =
    AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE;

  typedef AudioDecoderConfig_ChannelLayout ChannelLayout;
  static const ChannelLayout CHANNEL_LAYOUT_NONE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
  static const ChannelLayout CHANNEL_LAYOUT_UNSUPPORTED =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED;
  static const ChannelLayout CHANNEL_LAYOUT_MONO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO;
  static const ChannelLayout CHANNEL_LAYOUT_STEREO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO;
  static const ChannelLayout CHANNEL_LAYOUT_2_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1;
  static const ChannelLayout CHANNEL_LAYOUT_SURROUND =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND;
  static const ChannelLayout CHANNEL_LAYOUT_4_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0;
  static const ChannelLayout CHANNEL_LAYOUT_2_2 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2;
  static const ChannelLayout CHANNEL_LAYOUT_QUAD =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD;
  static const ChannelLayout CHANNEL_LAYOUT_5_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0;
  static const ChannelLayout CHANNEL_LAYOUT_5_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1;
  static const ChannelLayout CHANNEL_LAYOUT_5_0_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK;
  static const ChannelLayout CHANNEL_LAYOUT_5_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK;
  static const ChannelLayout CHANNEL_LAYOUT_7_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0;
  static const ChannelLayout CHANNEL_LAYOUT_7_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1;
  static const ChannelLayout CHANNEL_LAYOUT_7_1_WIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE;
  static const ChannelLayout CHANNEL_LAYOUT_STEREO_DOWNMIX =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX;
  static const ChannelLayout CHANNEL_LAYOUT_2POINT1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1;
  static const ChannelLayout CHANNEL_LAYOUT_3_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1;
  static const ChannelLayout CHANNEL_LAYOUT_4_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1;
  static const ChannelLayout CHANNEL_LAYOUT_6_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0;
  static const ChannelLayout CHANNEL_LAYOUT_6_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT;
  static const ChannelLayout CHANNEL_LAYOUT_HEXAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL;
  static const ChannelLayout CHANNEL_LAYOUT_6_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1;
  static const ChannelLayout CHANNEL_LAYOUT_6_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK;
  static const ChannelLayout CHANNEL_LAYOUT_6_1_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT;
  static const ChannelLayout CHANNEL_LAYOUT_7_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT;
  static const ChannelLayout CHANNEL_LAYOUT_7_1_WIDE_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK;
  static const ChannelLayout CHANNEL_LAYOUT_OCTAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL;
  static const ChannelLayout CHANNEL_LAYOUT_DISCRETE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE;
  static const ChannelLayout CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC;
  static const ChannelLayout CHANNEL_LAYOUT_4_1_QUAD_SIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE;
  static const ChannelLayout CHANNEL_LAYOUT_BITSTREAM =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
  static inline bool ChannelLayout_IsValid(int value) {
    return AudioDecoderConfig_ChannelLayout_IsValid(value);
  }
  static const ChannelLayout ChannelLayout_MIN =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN;
  static const ChannelLayout ChannelLayout_MAX =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX;
  static const int ChannelLayout_ARRAYSIZE =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes extra_data = 8;
  bool has_extra_data() const;
  void clear_extra_data();
  static const int kExtraDataFieldNumber = 8;
  const ::std::string& extra_data() const;
  void set_extra_data(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_data(::std::string&& value);
  #endif
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  ::std::string* mutable_extra_data();
  ::std::string* release_extra_data();
  void set_allocated_extra_data(::std::string* extra_data);

  // optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
  bool has_encryption_scheme() const;
  void clear_encryption_scheme();
  static const int kEncryptionSchemeFieldNumber = 2;
  const ::media::remoting::pb::EncryptionScheme& encryption_scheme() const;
  ::media::remoting::pb::EncryptionScheme* mutable_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* release_encryption_scheme();
  void set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme);

  // optional .media.remoting.pb.AudioDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 1;
  ::media::remoting::pb::AudioDecoderConfig_Codec codec() const;
  void set_codec(::media::remoting::pb::AudioDecoderConfig_Codec value);

  // optional .media.remoting.pb.AudioDecoderConfig.SampleFormat sample_format = 3;
  bool has_sample_format() const;
  void clear_sample_format();
  static const int kSampleFormatFieldNumber = 3;
  ::media::remoting::pb::AudioDecoderConfig_SampleFormat sample_format() const;
  void set_sample_format(::media::remoting::pb::AudioDecoderConfig_SampleFormat value);

  // optional .media.remoting.pb.AudioDecoderConfig.ChannelLayout channel_layout = 4;
  bool has_channel_layout() const;
  void clear_channel_layout();
  static const int kChannelLayoutFieldNumber = 4;
  ::media::remoting::pb::AudioDecoderConfig_ChannelLayout channel_layout() const;
  void set_channel_layout(::media::remoting::pb::AudioDecoderConfig_ChannelLayout value);

  // optional int32 samples_per_second = 5;
  bool has_samples_per_second() const;
  void clear_samples_per_second();
  static const int kSamplesPerSecondFieldNumber = 5;
  ::google::protobuf::int32 samples_per_second() const;
  void set_samples_per_second(::google::protobuf::int32 value);

  // optional int64 seek_preroll_usec = 6;
  bool has_seek_preroll_usec() const;
  void clear_seek_preroll_usec();
  static const int kSeekPrerollUsecFieldNumber = 6;
  ::google::protobuf::int64 seek_preroll_usec() const;
  void set_seek_preroll_usec(::google::protobuf::int64 value);

  // optional int32 codec_delay = 7;
  bool has_codec_delay() const;
  void clear_codec_delay();
  static const int kCodecDelayFieldNumber = 7;
  ::google::protobuf::int32 codec_delay() const;
  void set_codec_delay(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.AudioDecoderConfig)
 private:
  void set_has_codec();
  void clear_has_codec();
  void set_has_encryption_scheme();
  void clear_has_encryption_scheme();
  void set_has_sample_format();
  void clear_has_sample_format();
  void set_has_channel_layout();
  void clear_has_channel_layout();
  void set_has_samples_per_second();
  void clear_has_samples_per_second();
  void set_has_seek_preroll_usec();
  void clear_has_seek_preroll_usec();
  void set_has_codec_delay();
  void clear_has_codec_delay();
  void set_has_extra_data();
  void clear_has_extra_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_data_;
  ::media::remoting::pb::EncryptionScheme* encryption_scheme_;
  int codec_;
  int sample_format_;
  int channel_layout_;
  ::google::protobuf::int32 samples_per_second_;
  ::google::protobuf::int64 seek_preroll_usec_;
  ::google::protobuf::int32 codec_delay_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Rect& default_instance();

  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(Rect* other);

  // implements Message ----------------------------------------------

  inline Rect* New() const PROTOBUF_FINAL { return New(NULL); }

  Rect* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 width = 3;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 4;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.Rect)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VideoDecoderConfig : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.VideoDecoderConfig) */ {
 public:
  VideoDecoderConfig();
  virtual ~VideoDecoderConfig();

  VideoDecoderConfig(const VideoDecoderConfig& from);

  inline VideoDecoderConfig& operator=(const VideoDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const VideoDecoderConfig& default_instance();

  static inline const VideoDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const VideoDecoderConfig*>(
               &_VideoDecoderConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(VideoDecoderConfig* other);

  // implements Message ----------------------------------------------

  inline VideoDecoderConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  VideoDecoderConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const VideoDecoderConfig& from);
  void MergeFrom(const VideoDecoderConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoDecoderConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef VideoDecoderConfig_Codec Codec;
  static const Codec kUnknownVideoCodec =
    VideoDecoderConfig_Codec_kUnknownVideoCodec;
  static const Codec kCodecH264 =
    VideoDecoderConfig_Codec_kCodecH264;
  static const Codec kCodecVC1 =
    VideoDecoderConfig_Codec_kCodecVC1;
  static const Codec kCodecMPEG2 =
    VideoDecoderConfig_Codec_kCodecMPEG2;
  static const Codec kCodecMPEG4 =
    VideoDecoderConfig_Codec_kCodecMPEG4;
  static const Codec kCodecTheora =
    VideoDecoderConfig_Codec_kCodecTheora;
  static const Codec kCodecVP8 =
    VideoDecoderConfig_Codec_kCodecVP8;
  static const Codec kCodecVP9 =
    VideoDecoderConfig_Codec_kCodecVP9;
  static const Codec kCodecHEVC =
    VideoDecoderConfig_Codec_kCodecHEVC;
  static const Codec kCodecDolbyVision =
    VideoDecoderConfig_Codec_kCodecDolbyVision;
  static const Codec kCodecAV1 =
    VideoDecoderConfig_Codec_kCodecAV1;
  static inline bool Codec_IsValid(int value) {
    return VideoDecoderConfig_Codec_IsValid(value);
  }
  static const Codec Codec_MIN =
    VideoDecoderConfig_Codec_Codec_MIN;
  static const Codec Codec_MAX =
    VideoDecoderConfig_Codec_Codec_MAX;
  static const int Codec_ARRAYSIZE =
    VideoDecoderConfig_Codec_Codec_ARRAYSIZE;

  typedef VideoDecoderConfig_Profile Profile;
  static const Profile VIDEO_CODEC_PROFILE_UNKNOWN =
    VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
  static const Profile H264PROFILE_BASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_BASELINE;
  static const Profile H264PROFILE_MAIN =
    VideoDecoderConfig_Profile_H264PROFILE_MAIN;
  static const Profile H264PROFILE_EXTENDED =
    VideoDecoderConfig_Profile_H264PROFILE_EXTENDED;
  static const Profile H264PROFILE_HIGH =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH;
  static const Profile H264PROFILE_HIGH10PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE;
  static const Profile H264PROFILE_HIGH422PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE;
  static const Profile H264PROFILE_HIGH444PREDICTIVEPROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE;
  static const Profile H264PROFILE_SCALABLEBASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE;
  static const Profile H264PROFILE_SCALABLEHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH;
  static const Profile H264PROFILE_STEREOHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH;
  static const Profile H264PROFILE_MULTIVIEWHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH;
  static const Profile VP8PROFILE_ANY =
    VideoDecoderConfig_Profile_VP8PROFILE_ANY;
  static const Profile VP9PROFILE_PROFILE0 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0;
  static const Profile VP9PROFILE_PROFILE1 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1;
  static const Profile VP9PROFILE_PROFILE2 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2;
  static const Profile VP9PROFILE_PROFILE3 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3;
  static const Profile HEVCPROFILE_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN;
  static const Profile HEVCPROFILE_MAIN10 =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10;
  static const Profile HEVCPROFILE_MAIN_STILL_PICTURE =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE;
  static const Profile DOLBYVISION_PROFILE0 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0;
  static const Profile DOLBYVISION_PROFILE4 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4;
  static const Profile DOLBYVISION_PROFILE5 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5;
  static const Profile DOLBYVISION_PROFILE7 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7;
  static const Profile THEORAPROFILE_ANY =
    VideoDecoderConfig_Profile_THEORAPROFILE_ANY;
  static const Profile AV1PROFILE_PROFILE0 =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE0;
  static inline bool Profile_IsValid(int value) {
    return VideoDecoderConfig_Profile_IsValid(value);
  }
  static const Profile Profile_MIN =
    VideoDecoderConfig_Profile_Profile_MIN;
  static const Profile Profile_MAX =
    VideoDecoderConfig_Profile_Profile_MAX;
  static const int Profile_ARRAYSIZE =
    VideoDecoderConfig_Profile_Profile_ARRAYSIZE;

  typedef VideoDecoderConfig_Format Format;
  static const Format PIXEL_FORMAT_UNKNOWN =
    VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
  static const Format PIXEL_FORMAT_I420 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420;
  static const Format PIXEL_FORMAT_YV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YV12;
  static const Format PIXEL_FORMAT_I422 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I422;
  static const Format PIXEL_FORMAT_I420A =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420A;
  static const Format PIXEL_FORMAT_I444 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I444;
  static const Format PIXEL_FORMAT_NV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV12;
  static const Format PIXEL_FORMAT_NV21 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV21;
  static const Format PIXEL_FORMAT_UYVY =
    VideoDecoderConfig_Format_PIXEL_FORMAT_UYVY;
  static const Format PIXEL_FORMAT_YUY2 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2;
  static const Format PIXEL_FORMAT_ARGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB;
  static const Format PIXEL_FORMAT_XRGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB;
  static const Format PIXEL_FORMAT_RGB24 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24;
  static const Format PIXEL_FORMAT_RGB32 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32;
  static const Format PIXEL_FORMAT_MJPEG =
    VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG;
  static const Format PIXEL_FORMAT_MT21 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_MT21;
  static const Format PIXEL_FORMAT_YUV420P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9;
  static const Format PIXEL_FORMAT_YUV420P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10;
  static const Format PIXEL_FORMAT_YUV422P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9;
  static const Format PIXEL_FORMAT_YUV422P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10;
  static const Format PIXEL_FORMAT_YUV444P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9;
  static const Format PIXEL_FORMAT_YUV444P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10;
  static const Format PIXEL_FORMAT_YUV420P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12;
  static const Format PIXEL_FORMAT_YUV422P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12;
  static const Format PIXEL_FORMAT_YUV444P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const Format PIXEL_FORMAT_Y8 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_Y8;
  static const Format PIXEL_FORMAT_Y16 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_Y16;
  static inline bool Format_IsValid(int value) {
    return VideoDecoderConfig_Format_IsValid(value);
  }
  static const Format Format_MIN =
    VideoDecoderConfig_Format_Format_MIN;
  static const Format Format_MAX =
    VideoDecoderConfig_Format_Format_MAX;
  static const int Format_ARRAYSIZE =
    VideoDecoderConfig_Format_Format_ARRAYSIZE;

  typedef VideoDecoderConfig_ColorSpace ColorSpace;
  static const ColorSpace COLOR_SPACE_UNSPECIFIED =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
  static const ColorSpace COLOR_SPACE_JPEG =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG;
  static const ColorSpace COLOR_SPACE_HD_REC709 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709;
  static const ColorSpace COLOR_SPACE_SD_REC601 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
  static inline bool ColorSpace_IsValid(int value) {
    return VideoDecoderConfig_ColorSpace_IsValid(value);
  }
  static const ColorSpace ColorSpace_MIN =
    VideoDecoderConfig_ColorSpace_ColorSpace_MIN;
  static const ColorSpace ColorSpace_MAX =
    VideoDecoderConfig_ColorSpace_ColorSpace_MAX;
  static const int ColorSpace_ARRAYSIZE =
    VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes extra_data = 9;
  bool has_extra_data() const;
  void clear_extra_data();
  static const int kExtraDataFieldNumber = 9;
  const ::std::string& extra_data() const;
  void set_extra_data(const ::std::string& value);
  #if LANG_CXX11
  void set_extra_data(::std::string&& value);
  #endif
  void set_extra_data(const char* value);
  void set_extra_data(const void* value, size_t size);
  ::std::string* mutable_extra_data();
  ::std::string* release_extra_data();
  void set_allocated_extra_data(::std::string* extra_data);

  // optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
  bool has_encryption_scheme() const;
  void clear_encryption_scheme();
  static const int kEncryptionSchemeFieldNumber = 2;
  const ::media::remoting::pb::EncryptionScheme& encryption_scheme() const;
  ::media::remoting::pb::EncryptionScheme* mutable_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* release_encryption_scheme();
  void set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme);

  // optional .media.remoting.pb.Size coded_size = 6;
  bool has_coded_size() const;
  void clear_coded_size();
  static const int kCodedSizeFieldNumber = 6;
  const ::media::remoting::pb::Size& coded_size() const;
  ::media::remoting::pb::Size* mutable_coded_size();
  ::media::remoting::pb::Size* release_coded_size();
  void set_allocated_coded_size(::media::remoting::pb::Size* coded_size);

  // optional .media.remoting.pb.Rect visible_rect = 7;
  bool has_visible_rect() const;
  void clear_visible_rect();
  static const int kVisibleRectFieldNumber = 7;
  const ::media::remoting::pb::Rect& visible_rect() const;
  ::media::remoting::pb::Rect* mutable_visible_rect();
  ::media::remoting::pb::Rect* release_visible_rect();
  void set_allocated_visible_rect(::media::remoting::pb::Rect* visible_rect);

  // optional .media.remoting.pb.Size natural_size = 8;
  bool has_natural_size() const;
  void clear_natural_size();
  static const int kNaturalSizeFieldNumber = 8;
  const ::media::remoting::pb::Size& natural_size() const;
  ::media::remoting::pb::Size* mutable_natural_size();
  ::media::remoting::pb::Size* release_natural_size();
  void set_allocated_natural_size(::media::remoting::pb::Size* natural_size);

  // optional .media.remoting.pb.VideoDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  void clear_codec();
  static const int kCodecFieldNumber = 1;
  ::media::remoting::pb::VideoDecoderConfig_Codec codec() const;
  void set_codec(::media::remoting::pb::VideoDecoderConfig_Codec value);

  // optional .media.remoting.pb.VideoDecoderConfig.Format format = 4;
  bool has_format() const;
  void clear_format();
  static const int kFormatFieldNumber = 4;
  ::media::remoting::pb::VideoDecoderConfig_Format format() const;
  void set_format(::media::remoting::pb::VideoDecoderConfig_Format value);

  // optional .media.remoting.pb.VideoDecoderConfig.ColorSpace color_space = 5;
  bool has_color_space() const;
  void clear_color_space();
  static const int kColorSpaceFieldNumber = 5;
  ::media::remoting::pb::VideoDecoderConfig_ColorSpace color_space() const;
  void set_color_space(::media::remoting::pb::VideoDecoderConfig_ColorSpace value);

  // optional .media.remoting.pb.VideoDecoderConfig.Profile profile = 3;
  bool has_profile() const;
  void clear_profile();
  static const int kProfileFieldNumber = 3;
  ::media::remoting::pb::VideoDecoderConfig_Profile profile() const;
  void set_profile(::media::remoting::pb::VideoDecoderConfig_Profile value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.VideoDecoderConfig)
 private:
  void set_has_codec();
  void clear_has_codec();
  void set_has_encryption_scheme();
  void clear_has_encryption_scheme();
  void set_has_profile();
  void clear_has_profile();
  void set_has_format();
  void clear_has_format();
  void set_has_color_space();
  void clear_has_color_space();
  void set_has_coded_size();
  void clear_has_coded_size();
  void set_has_visible_rect();
  void clear_has_visible_rect();
  void set_has_natural_size();
  void clear_has_natural_size();
  void set_has_extra_data();
  void clear_has_extra_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr extra_data_;
  ::media::remoting::pb::EncryptionScheme* encryption_scheme_;
  ::media::remoting::pb::Size* coded_size_;
  ::media::remoting::pb::Rect* visible_rect_;
  ::media::remoting::pb::Size* natural_size_;
  int codec_;
  int format_;
  int color_space_;
  int profile_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecryptConfig_SubSample : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecryptConfig.SubSample) */ {
 public:
  DecryptConfig_SubSample();
  virtual ~DecryptConfig_SubSample();

  DecryptConfig_SubSample(const DecryptConfig_SubSample& from);

  inline DecryptConfig_SubSample& operator=(const DecryptConfig_SubSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecryptConfig_SubSample& default_instance();

  static inline const DecryptConfig_SubSample* internal_default_instance() {
    return reinterpret_cast<const DecryptConfig_SubSample*>(
               &_DecryptConfig_SubSample_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DecryptConfig_SubSample* other);

  // implements Message ----------------------------------------------

  inline DecryptConfig_SubSample* New() const PROTOBUF_FINAL { return New(NULL); }

  DecryptConfig_SubSample* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DecryptConfig_SubSample& from);
  void MergeFrom(const DecryptConfig_SubSample& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecryptConfig_SubSample* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clear_bytes = 1;
  bool has_clear_bytes() const;
  void clear_clear_bytes();
  static const int kClearBytesFieldNumber = 1;
  ::google::protobuf::uint32 clear_bytes() const;
  void set_clear_bytes(::google::protobuf::uint32 value);

  // optional uint32 cypher_bytes = 2;
  bool has_cypher_bytes() const;
  void clear_cypher_bytes();
  static const int kCypherBytesFieldNumber = 2;
  ::google::protobuf::uint32 cypher_bytes() const;
  void set_cypher_bytes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecryptConfig.SubSample)
 private:
  void set_has_clear_bytes();
  void clear_has_clear_bytes();
  void set_has_cypher_bytes();
  void clear_has_cypher_bytes();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 clear_bytes_;
  ::google::protobuf::uint32 cypher_bytes_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecryptConfig : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DecryptConfig) */ {
 public:
  DecryptConfig();
  virtual ~DecryptConfig();

  DecryptConfig(const DecryptConfig& from);

  inline DecryptConfig& operator=(const DecryptConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DecryptConfig& default_instance();

  static inline const DecryptConfig* internal_default_instance() {
    return reinterpret_cast<const DecryptConfig*>(
               &_DecryptConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DecryptConfig* other);

  // implements Message ----------------------------------------------

  inline DecryptConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  DecryptConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DecryptConfig& from);
  void MergeFrom(const DecryptConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecryptConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DecryptConfig_SubSample SubSample;

  // accessors -------------------------------------------------------

  // repeated .media.remoting.pb.DecryptConfig.SubSample sub_samples = 3;
  int sub_samples_size() const;
  void clear_sub_samples();
  static const int kSubSamplesFieldNumber = 3;
  const ::media::remoting::pb::DecryptConfig_SubSample& sub_samples(int index) const;
  ::media::remoting::pb::DecryptConfig_SubSample* mutable_sub_samples(int index);
  ::media::remoting::pb::DecryptConfig_SubSample* add_sub_samples();
  ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >*
      mutable_sub_samples();
  const ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >&
      sub_samples() const;

  // optional bytes key_id = 1;
  bool has_key_id() const;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 1;
  const ::std::string& key_id() const;
  void set_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_key_id(::std::string&& value);
  #endif
  void set_key_id(const char* value);
  void set_key_id(const void* value, size_t size);
  ::std::string* mutable_key_id();
  ::std::string* release_key_id();
  void set_allocated_key_id(::std::string* key_id);

  // optional bytes iv = 2;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 2;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional .media.remoting.pb.EncryptionMode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::media::remoting::pb::EncryptionMode mode() const;
  void set_mode(::media::remoting::pb::EncryptionMode value);

  // optional uint32 crypt_byte_block = 5;
  bool has_crypt_byte_block() const;
  void clear_crypt_byte_block();
  static const int kCryptByteBlockFieldNumber = 5;
  ::google::protobuf::uint32 crypt_byte_block() const;
  void set_crypt_byte_block(::google::protobuf::uint32 value);

  // optional uint32 skip_byte_block = 6;
  bool has_skip_byte_block() const;
  void clear_skip_byte_block();
  static const int kSkipByteBlockFieldNumber = 6;
  ::google::protobuf::uint32 skip_byte_block() const;
  void set_skip_byte_block(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DecryptConfig)
 private:
  void set_has_key_id();
  void clear_has_key_id();
  void set_has_iv();
  void clear_has_iv();
  void set_has_mode();
  void clear_has_mode();
  void set_has_crypt_byte_block();
  void clear_has_crypt_byte_block();
  void set_has_skip_byte_block();
  void clear_has_skip_byte_block();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample > sub_samples_;
  ::google::protobuf::internal::ArenaStringPtr key_id_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  int mode_;
  ::google::protobuf::uint32 crypt_byte_block_;
  ::google::protobuf::uint32 skip_byte_block_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PipelineStatistics : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.PipelineStatistics) */ {
 public:
  PipelineStatistics();
  virtual ~PipelineStatistics();

  PipelineStatistics(const PipelineStatistics& from);

  inline PipelineStatistics& operator=(const PipelineStatistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const PipelineStatistics& default_instance();

  static inline const PipelineStatistics* internal_default_instance() {
    return reinterpret_cast<const PipelineStatistics*>(
               &_PipelineStatistics_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(PipelineStatistics* other);

  // implements Message ----------------------------------------------

  inline PipelineStatistics* New() const PROTOBUF_FINAL { return New(NULL); }

  PipelineStatistics* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PipelineStatistics& from);
  void MergeFrom(const PipelineStatistics& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineStatistics* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string audio_decoder_name = 8;
  bool has_audio_decoder_name() const;
  void clear_audio_decoder_name();
  static const int kAudioDecoderNameFieldNumber = 8;
  const ::std::string& audio_decoder_name() const;
  void set_audio_decoder_name(const ::std::string& value);
  #if LANG_CXX11
  void set_audio_decoder_name(::std::string&& value);
  #endif
  void set_audio_decoder_name(const char* value);
  void set_audio_decoder_name(const char* value, size_t size);
  ::std::string* mutable_audio_decoder_name();
  ::std::string* release_audio_decoder_name();
  void set_allocated_audio_decoder_name(::std::string* audio_decoder_name);

  // optional string video_decoder_name = 9;
  bool has_video_decoder_name() const;
  void clear_video_decoder_name();
  static const int kVideoDecoderNameFieldNumber = 9;
  const ::std::string& video_decoder_name() const;
  void set_video_decoder_name(const ::std::string& value);
  #if LANG_CXX11
  void set_video_decoder_name(::std::string&& value);
  #endif
  void set_video_decoder_name(const char* value);
  void set_video_decoder_name(const char* value, size_t size);
  ::std::string* mutable_video_decoder_name();
  ::std::string* release_video_decoder_name();
  void set_allocated_video_decoder_name(::std::string* video_decoder_name);

  // optional uint64 audio_bytes_decoded = 1;
  bool has_audio_bytes_decoded() const;
  void clear_audio_bytes_decoded();
  static const int kAudioBytesDecodedFieldNumber = 1;
  ::google::protobuf::uint64 audio_bytes_decoded() const;
  void set_audio_bytes_decoded(::google::protobuf::uint64 value);

  // optional uint64 video_bytes_decoded = 2;
  bool has_video_bytes_decoded() const;
  void clear_video_bytes_decoded();
  static const int kVideoBytesDecodedFieldNumber = 2;
  ::google::protobuf::uint64 video_bytes_decoded() const;
  void set_video_bytes_decoded(::google::protobuf::uint64 value);

  // optional uint32 video_frames_decoded = 3;
  bool has_video_frames_decoded() const;
  void clear_video_frames_decoded();
  static const int kVideoFramesDecodedFieldNumber = 3;
  ::google::protobuf::uint32 video_frames_decoded() const;
  void set_video_frames_decoded(::google::protobuf::uint32 value);

  // optional uint32 video_frames_dropped = 4;
  bool has_video_frames_dropped() const;
  void clear_video_frames_dropped();
  static const int kVideoFramesDroppedFieldNumber = 4;
  ::google::protobuf::uint32 video_frames_dropped() const;
  void set_video_frames_dropped(::google::protobuf::uint32 value);

  // optional int64 audio_memory_usage = 5;
  bool has_audio_memory_usage() const;
  void clear_audio_memory_usage();
  static const int kAudioMemoryUsageFieldNumber = 5;
  ::google::protobuf::int64 audio_memory_usage() const;
  void set_audio_memory_usage(::google::protobuf::int64 value);

  // optional int64 video_memory_usage = 6;
  bool has_video_memory_usage() const;
  void clear_video_memory_usage();
  static const int kVideoMemoryUsageFieldNumber = 6;
  ::google::protobuf::int64 video_memory_usage() const;
  void set_video_memory_usage(::google::protobuf::int64 value);

  // optional int64 video_frame_duration_average_usec = 7;
  bool has_video_frame_duration_average_usec() const;
  void clear_video_frame_duration_average_usec();
  static const int kVideoFrameDurationAverageUsecFieldNumber = 7;
  ::google::protobuf::int64 video_frame_duration_average_usec() const;
  void set_video_frame_duration_average_usec(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.PipelineStatistics)
 private:
  void set_has_audio_bytes_decoded();
  void clear_has_audio_bytes_decoded();
  void set_has_video_bytes_decoded();
  void clear_has_video_bytes_decoded();
  void set_has_video_frames_decoded();
  void clear_has_video_frames_decoded();
  void set_has_video_frames_dropped();
  void clear_has_video_frames_dropped();
  void set_has_audio_memory_usage();
  void clear_has_audio_memory_usage();
  void set_has_video_memory_usage();
  void clear_has_video_memory_usage();
  void set_has_video_frame_duration_average_usec();
  void clear_has_video_frame_duration_average_usec();
  void set_has_audio_decoder_name();
  void clear_has_audio_decoder_name();
  void set_has_video_decoder_name();
  void clear_has_video_decoder_name();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr audio_decoder_name_;
  ::google::protobuf::internal::ArenaStringPtr video_decoder_name_;
  ::google::protobuf::uint64 audio_bytes_decoded_;
  ::google::protobuf::uint64 video_bytes_decoded_;
  ::google::protobuf::uint32 video_frames_decoded_;
  ::google::protobuf::uint32 video_frames_dropped_;
  ::google::protobuf::int64 audio_memory_usage_;
  ::google::protobuf::int64 video_memory_usage_;
  ::google::protobuf::int64 video_frame_duration_average_usec_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmKeyInformation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmKeyInformation) */ {
 public:
  CdmKeyInformation();
  virtual ~CdmKeyInformation();

  CdmKeyInformation(const CdmKeyInformation& from);

  inline CdmKeyInformation& operator=(const CdmKeyInformation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmKeyInformation& default_instance();

  static inline const CdmKeyInformation* internal_default_instance() {
    return reinterpret_cast<const CdmKeyInformation*>(
               &_CdmKeyInformation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmKeyInformation* other);

  // implements Message ----------------------------------------------

  inline CdmKeyInformation* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmKeyInformation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmKeyInformation& from);
  void MergeFrom(const CdmKeyInformation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmKeyInformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CdmKeyInformation_KeyStatus KeyStatus;
  static const KeyStatus USABLE =
    CdmKeyInformation_KeyStatus_USABLE;
  static const KeyStatus INTERNAL_ERROR =
    CdmKeyInformation_KeyStatus_INTERNAL_ERROR;
  static const KeyStatus EXPIRED =
    CdmKeyInformation_KeyStatus_EXPIRED;
  static const KeyStatus OUTPUT_RESTRICTED =
    CdmKeyInformation_KeyStatus_OUTPUT_RESTRICTED;
  static const KeyStatus OUTPUT_DOWNSCALED =
    CdmKeyInformation_KeyStatus_OUTPUT_DOWNSCALED;
  static const KeyStatus KEY_STATUS_PENDING =
    CdmKeyInformation_KeyStatus_KEY_STATUS_PENDING;
  static const KeyStatus RELEASED =
    CdmKeyInformation_KeyStatus_RELEASED;
  static inline bool KeyStatus_IsValid(int value) {
    return CdmKeyInformation_KeyStatus_IsValid(value);
  }
  static const KeyStatus KeyStatus_MIN =
    CdmKeyInformation_KeyStatus_KeyStatus_MIN;
  static const KeyStatus KeyStatus_MAX =
    CdmKeyInformation_KeyStatus_KeyStatus_MAX;
  static const int KeyStatus_ARRAYSIZE =
    CdmKeyInformation_KeyStatus_KeyStatus_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes key_id = 1;
  bool has_key_id() const;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 1;
  const ::std::string& key_id() const;
  void set_key_id(const ::std::string& value);
  #if LANG_CXX11
  void set_key_id(::std::string&& value);
  #endif
  void set_key_id(const char* value);
  void set_key_id(const void* value, size_t size);
  ::std::string* mutable_key_id();
  ::std::string* release_key_id();
  void set_allocated_key_id(::std::string* key_id);

  // optional .media.remoting.pb.CdmKeyInformation.KeyStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::media::remoting::pb::CdmKeyInformation_KeyStatus status() const;
  void set_status(::media::remoting::pb::CdmKeyInformation_KeyStatus value);

  // optional uint32 system_code = 3;
  bool has_system_code() const;
  void clear_system_code();
  static const int kSystemCodeFieldNumber = 3;
  ::google::protobuf::uint32 system_code() const;
  void set_system_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmKeyInformation)
 private:
  void set_has_key_id();
  void clear_has_key_id();
  void set_has_status();
  void clear_has_status();
  void set_has_system_code();
  void clear_has_system_code();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_id_;
  int status_;
  ::google::protobuf::uint32 system_code_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererInitialize : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererInitialize) */ {
 public:
  RendererInitialize();
  virtual ~RendererInitialize();

  RendererInitialize(const RendererInitialize& from);

  inline RendererInitialize& operator=(const RendererInitialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererInitialize& default_instance();

  static inline const RendererInitialize* internal_default_instance() {
    return reinterpret_cast<const RendererInitialize*>(
               &_RendererInitialize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererInitialize* other);

  // implements Message ----------------------------------------------

  inline RendererInitialize* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererInitialize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererInitialize& from);
  void MergeFrom(const RendererInitialize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererInitialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 client_handle = 1;
  bool has_client_handle() const;
  void clear_client_handle();
  static const int kClientHandleFieldNumber = 1;
  ::google::protobuf::int32 client_handle() const;
  void set_client_handle(::google::protobuf::int32 value);

  // optional int32 audio_demuxer_handle = 2;
  bool has_audio_demuxer_handle() const;
  void clear_audio_demuxer_handle();
  static const int kAudioDemuxerHandleFieldNumber = 2;
  ::google::protobuf::int32 audio_demuxer_handle() const;
  void set_audio_demuxer_handle(::google::protobuf::int32 value);

  // optional int32 video_demuxer_handle = 3;
  bool has_video_demuxer_handle() const;
  void clear_video_demuxer_handle();
  static const int kVideoDemuxerHandleFieldNumber = 3;
  ::google::protobuf::int32 video_demuxer_handle() const;
  void set_video_demuxer_handle(::google::protobuf::int32 value);

  // optional int32 callback_handle = 4;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 4;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererInitialize)
 private:
  void set_has_client_handle();
  void clear_has_client_handle();
  void set_has_audio_demuxer_handle();
  void clear_has_audio_demuxer_handle();
  void set_has_video_demuxer_handle();
  void clear_has_video_demuxer_handle();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 client_handle_;
  ::google::protobuf::int32 audio_demuxer_handle_;
  ::google::protobuf::int32 video_demuxer_handle_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererFlushUntil : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererFlushUntil) */ {
 public:
  RendererFlushUntil();
  virtual ~RendererFlushUntil();

  RendererFlushUntil(const RendererFlushUntil& from);

  inline RendererFlushUntil& operator=(const RendererFlushUntil& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererFlushUntil& default_instance();

  static inline const RendererFlushUntil* internal_default_instance() {
    return reinterpret_cast<const RendererFlushUntil*>(
               &_RendererFlushUntil_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererFlushUntil* other);

  // implements Message ----------------------------------------------

  inline RendererFlushUntil* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererFlushUntil* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererFlushUntil& from);
  void MergeFrom(const RendererFlushUntil& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererFlushUntil* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 audio_count = 1;
  bool has_audio_count() const;
  void clear_audio_count();
  static const int kAudioCountFieldNumber = 1;
  ::google::protobuf::uint32 audio_count() const;
  void set_audio_count(::google::protobuf::uint32 value);

  // optional uint32 video_count = 2;
  bool has_video_count() const;
  void clear_video_count();
  static const int kVideoCountFieldNumber = 2;
  ::google::protobuf::uint32 video_count() const;
  void set_video_count(::google::protobuf::uint32 value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 3;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererFlushUntil)
 private:
  void set_has_audio_count();
  void clear_has_audio_count();
  void set_has_video_count();
  void clear_has_video_count();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 audio_count_;
  ::google::protobuf::uint32 video_count_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererSetCdm : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererSetCdm) */ {
 public:
  RendererSetCdm();
  virtual ~RendererSetCdm();

  RendererSetCdm(const RendererSetCdm& from);

  inline RendererSetCdm& operator=(const RendererSetCdm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererSetCdm& default_instance();

  static inline const RendererSetCdm* internal_default_instance() {
    return reinterpret_cast<const RendererSetCdm*>(
               &_RendererSetCdm_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererSetCdm* other);

  // implements Message ----------------------------------------------

  inline RendererSetCdm* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererSetCdm* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererSetCdm& from);
  void MergeFrom(const RendererSetCdm& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererSetCdm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cdm_id = 1;
  bool has_cdm_id() const;
  void clear_cdm_id();
  static const int kCdmIdFieldNumber = 1;
  ::google::protobuf::int32 cdm_id() const;
  void set_cdm_id(::google::protobuf::int32 value);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 2;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererSetCdm)
 private:
  void set_has_cdm_id();
  void clear_has_cdm_id();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 cdm_id_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererClientOnTimeUpdate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnTimeUpdate) */ {
 public:
  RendererClientOnTimeUpdate();
  virtual ~RendererClientOnTimeUpdate();

  RendererClientOnTimeUpdate(const RendererClientOnTimeUpdate& from);

  inline RendererClientOnTimeUpdate& operator=(const RendererClientOnTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnTimeUpdate& default_instance();

  static inline const RendererClientOnTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnTimeUpdate*>(
               &_RendererClientOnTimeUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererClientOnTimeUpdate* other);

  // implements Message ----------------------------------------------

  inline RendererClientOnTimeUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererClientOnTimeUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererClientOnTimeUpdate& from);
  void MergeFrom(const RendererClientOnTimeUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnTimeUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time_usec = 1;
  bool has_time_usec() const;
  void clear_time_usec();
  static const int kTimeUsecFieldNumber = 1;
  ::google::protobuf::int64 time_usec() const;
  void set_time_usec(::google::protobuf::int64 value);

  // optional int64 max_time_usec = 2;
  bool has_max_time_usec() const;
  void clear_max_time_usec();
  static const int kMaxTimeUsecFieldNumber = 2;
  ::google::protobuf::int64 max_time_usec() const;
  void set_max_time_usec(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnTimeUpdate)
 private:
  void set_has_time_usec();
  void clear_has_time_usec();
  void set_has_max_time_usec();
  void clear_has_max_time_usec();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 time_usec_;
  ::google::protobuf::int64 max_time_usec_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererClientOnBufferingStateChange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnBufferingStateChange) */ {
 public:
  RendererClientOnBufferingStateChange();
  virtual ~RendererClientOnBufferingStateChange();

  RendererClientOnBufferingStateChange(const RendererClientOnBufferingStateChange& from);

  inline RendererClientOnBufferingStateChange& operator=(const RendererClientOnBufferingStateChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnBufferingStateChange& default_instance();

  static inline const RendererClientOnBufferingStateChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnBufferingStateChange*>(
               &_RendererClientOnBufferingStateChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererClientOnBufferingStateChange* other);

  // implements Message ----------------------------------------------

  inline RendererClientOnBufferingStateChange* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererClientOnBufferingStateChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererClientOnBufferingStateChange& from);
  void MergeFrom(const RendererClientOnBufferingStateChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnBufferingStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RendererClientOnBufferingStateChange_State State;
  static const State BUFFERING_HAVE_NOTHING =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
  static const State BUFFERING_HAVE_ENOUGH =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
  static inline bool State_IsValid(int value) {
    return RendererClientOnBufferingStateChange_State_IsValid(value);
  }
  static const State State_MIN =
    RendererClientOnBufferingStateChange_State_State_MIN;
  static const State State_MAX =
    RendererClientOnBufferingStateChange_State_State_MAX;
  static const int State_ARRAYSIZE =
    RendererClientOnBufferingStateChange_State_State_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.RendererClientOnBufferingStateChange.State state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::media::remoting::pb::RendererClientOnBufferingStateChange_State state() const;
  void set_state(::media::remoting::pb::RendererClientOnBufferingStateChange_State value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnBufferingStateChange)
 private:
  void set_has_state();
  void clear_has_state();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int state_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererClientOnAudioConfigChange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnAudioConfigChange) */ {
 public:
  RendererClientOnAudioConfigChange();
  virtual ~RendererClientOnAudioConfigChange();

  RendererClientOnAudioConfigChange(const RendererClientOnAudioConfigChange& from);

  inline RendererClientOnAudioConfigChange& operator=(const RendererClientOnAudioConfigChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnAudioConfigChange& default_instance();

  static inline const RendererClientOnAudioConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnAudioConfigChange*>(
               &_RendererClientOnAudioConfigChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererClientOnAudioConfigChange* other);

  // implements Message ----------------------------------------------

  inline RendererClientOnAudioConfigChange* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererClientOnAudioConfigChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererClientOnAudioConfigChange& from);
  void MergeFrom(const RendererClientOnAudioConfigChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnAudioConfigChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 1;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  static const int kAudioDecoderConfigFieldNumber = 1;
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnAudioConfigChange)
 private:
  void set_has_audio_decoder_config();
  void clear_has_audio_decoder_config();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RendererClientOnVideoConfigChange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RendererClientOnVideoConfigChange) */ {
 public:
  RendererClientOnVideoConfigChange();
  virtual ~RendererClientOnVideoConfigChange();

  RendererClientOnVideoConfigChange(const RendererClientOnVideoConfigChange& from);

  inline RendererClientOnVideoConfigChange& operator=(const RendererClientOnVideoConfigChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RendererClientOnVideoConfigChange& default_instance();

  static inline const RendererClientOnVideoConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnVideoConfigChange*>(
               &_RendererClientOnVideoConfigChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RendererClientOnVideoConfigChange* other);

  // implements Message ----------------------------------------------

  inline RendererClientOnVideoConfigChange* New() const PROTOBUF_FINAL { return New(NULL); }

  RendererClientOnVideoConfigChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RendererClientOnVideoConfigChange& from);
  void MergeFrom(const RendererClientOnVideoConfigChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnVideoConfigChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 1;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  static const int kVideoDecoderConfigFieldNumber = 1;
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.RendererClientOnVideoConfigChange)
 private:
  void set_has_video_decoder_config();
  void clear_has_video_decoder_config();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntil : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamReadUntil) */ {
 public:
  DemuxerStreamReadUntil();
  virtual ~DemuxerStreamReadUntil();

  DemuxerStreamReadUntil(const DemuxerStreamReadUntil& from);

  inline DemuxerStreamReadUntil& operator=(const DemuxerStreamReadUntil& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamReadUntil& default_instance();

  static inline const DemuxerStreamReadUntil* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntil*>(
               &_DemuxerStreamReadUntil_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DemuxerStreamReadUntil* other);

  // implements Message ----------------------------------------------

  inline DemuxerStreamReadUntil* New() const PROTOBUF_FINAL { return New(NULL); }

  DemuxerStreamReadUntil* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DemuxerStreamReadUntil& from);
  void MergeFrom(const DemuxerStreamReadUntil& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntil* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 callback_handle = 1;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 1;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamReadUntil)
 private:
  void set_has_callback_handle();
  void clear_has_callback_handle();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 callback_handle_;
  ::google::protobuf::uint32 count_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DemuxerStreamInitializeCallback : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamInitializeCallback) */ {
 public:
  DemuxerStreamInitializeCallback();
  virtual ~DemuxerStreamInitializeCallback();

  DemuxerStreamInitializeCallback(const DemuxerStreamInitializeCallback& from);

  inline DemuxerStreamInitializeCallback& operator=(const DemuxerStreamInitializeCallback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamInitializeCallback& default_instance();

  static inline const DemuxerStreamInitializeCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamInitializeCallback*>(
               &_DemuxerStreamInitializeCallback_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DemuxerStreamInitializeCallback* other);

  // implements Message ----------------------------------------------

  inline DemuxerStreamInitializeCallback* New() const PROTOBUF_FINAL { return New(NULL); }

  DemuxerStreamInitializeCallback* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DemuxerStreamInitializeCallback& from);
  void MergeFrom(const DemuxerStreamInitializeCallback& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamInitializeCallback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 2;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  static const int kAudioDecoderConfigFieldNumber = 2;
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 3;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  static const int kVideoDecoderConfigFieldNumber = 3;
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // optional int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamInitializeCallback)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_audio_decoder_config();
  void clear_has_audio_decoder_config();
  void set_has_video_decoder_config();
  void clear_has_video_decoder_config();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  ::google::protobuf::int32 type_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntilCallback : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.DemuxerStreamReadUntilCallback) */ {
 public:
  DemuxerStreamReadUntilCallback();
  virtual ~DemuxerStreamReadUntilCallback();

  DemuxerStreamReadUntilCallback(const DemuxerStreamReadUntilCallback& from);

  inline DemuxerStreamReadUntilCallback& operator=(const DemuxerStreamReadUntilCallback& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DemuxerStreamReadUntilCallback& default_instance();

  static inline const DemuxerStreamReadUntilCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntilCallback*>(
               &_DemuxerStreamReadUntilCallback_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(DemuxerStreamReadUntilCallback* other);

  // implements Message ----------------------------------------------

  inline DemuxerStreamReadUntilCallback* New() const PROTOBUF_FINAL { return New(NULL); }

  DemuxerStreamReadUntilCallback* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DemuxerStreamReadUntilCallback& from);
  void MergeFrom(const DemuxerStreamReadUntilCallback& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntilCallback* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DemuxerStreamReadUntilCallback_Status Status;
  static const Status kOk =
    DemuxerStreamReadUntilCallback_Status_kOk;
  static const Status kAborted =
    DemuxerStreamReadUntilCallback_Status_kAborted;
  static const Status kConfigChanged =
    DemuxerStreamReadUntilCallback_Status_kConfigChanged;
  static const Status kError =
    DemuxerStreamReadUntilCallback_Status_kError;
  static inline bool Status_IsValid(int value) {
    return DemuxerStreamReadUntilCallback_Status_IsValid(value);
  }
  static const Status Status_MIN =
    DemuxerStreamReadUntilCallback_Status_Status_MIN;
  static const Status Status_MAX =
    DemuxerStreamReadUntilCallback_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 3;
  bool has_audio_decoder_config() const;
  void clear_audio_decoder_config();
  static const int kAudioDecoderConfigFieldNumber = 3;
  const ::media::remoting::pb::AudioDecoderConfig& audio_decoder_config() const;
  ::media::remoting::pb::AudioDecoderConfig* mutable_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* release_audio_decoder_config();
  void set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config);

  // optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 4;
  bool has_video_decoder_config() const;
  void clear_video_decoder_config();
  static const int kVideoDecoderConfigFieldNumber = 4;
  const ::media::remoting::pb::VideoDecoderConfig& video_decoder_config() const;
  ::media::remoting::pb::VideoDecoderConfig* mutable_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* release_video_decoder_config();
  void set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config);

  // optional .media.remoting.pb.DemuxerStreamReadUntilCallback.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status status() const;
  void set_status(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status value);

  // optional uint32 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint32 count() const;
  void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.DemuxerStreamReadUntilCallback)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_count();
  void clear_has_count();
  void set_has_audio_decoder_config();
  void clear_has_audio_decoder_config();
  void set_has_video_decoder_config();
  void clear_has_video_decoder_config();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::media::remoting::pb::AudioDecoderConfig* audio_decoder_config_;
  ::media::remoting::pb::VideoDecoderConfig* video_decoder_config_;
  int status_;
  ::google::protobuf::uint32 count_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmInitialize : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmInitialize) */ {
 public:
  CdmInitialize();
  virtual ~CdmInitialize();

  CdmInitialize(const CdmInitialize& from);

  inline CdmInitialize& operator=(const CdmInitialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmInitialize& default_instance();

  static inline const CdmInitialize* internal_default_instance() {
    return reinterpret_cast<const CdmInitialize*>(
               &_CdmInitialize_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmInitialize* other);

  // implements Message ----------------------------------------------

  inline CdmInitialize* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmInitialize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmInitialize& from);
  void MergeFrom(const CdmInitialize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmInitialize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key_system = 1;
  bool has_key_system() const;
  void clear_key_system();
  static const int kKeySystemFieldNumber = 1;
  const ::std::string& key_system() const;
  void set_key_system(const ::std::string& value);
  #if LANG_CXX11
  void set_key_system(::std::string&& value);
  #endif
  void set_key_system(const char* value);
  void set_key_system(const char* value, size_t size);
  ::std::string* mutable_key_system();
  ::std::string* release_key_system();
  void set_allocated_key_system(::std::string* key_system);

  // optional string security_origin = 2;
  bool has_security_origin() const;
  void clear_security_origin();
  static const int kSecurityOriginFieldNumber = 2;
  const ::std::string& security_origin() const;
  void set_security_origin(const ::std::string& value);
  #if LANG_CXX11
  void set_security_origin(::std::string&& value);
  #endif
  void set_security_origin(const char* value);
  void set_security_origin(const char* value, size_t size);
  ::std::string* mutable_security_origin();
  ::std::string* release_security_origin();
  void set_allocated_security_origin(::std::string* security_origin);

  // optional bool allow_distinctive_identifier = 3;
  bool has_allow_distinctive_identifier() const;
  void clear_allow_distinctive_identifier();
  static const int kAllowDistinctiveIdentifierFieldNumber = 3;
  bool allow_distinctive_identifier() const;
  void set_allow_distinctive_identifier(bool value);

  // optional bool allow_persistent_state = 4;
  bool has_allow_persistent_state() const;
  void clear_allow_persistent_state();
  static const int kAllowPersistentStateFieldNumber = 4;
  bool allow_persistent_state() const;
  void set_allow_persistent_state(bool value);

  // optional bool use_hw_secure_codecs = 5;
  bool has_use_hw_secure_codecs() const;
  void clear_use_hw_secure_codecs();
  static const int kUseHwSecureCodecsFieldNumber = 5;
  bool use_hw_secure_codecs() const;
  void set_use_hw_secure_codecs(bool value);

  // optional int32 callback_handle = 6;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 6;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmInitialize)
 private:
  void set_has_key_system();
  void clear_has_key_system();
  void set_has_security_origin();
  void clear_has_security_origin();
  void set_has_allow_distinctive_identifier();
  void clear_has_allow_distinctive_identifier();
  void set_has_allow_persistent_state();
  void clear_has_allow_persistent_state();
  void set_has_use_hw_secure_codecs();
  void clear_has_use_hw_secure_codecs();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_system_;
  ::google::protobuf::internal::ArenaStringPtr security_origin_;
  bool allow_distinctive_identifier_;
  bool allow_persistent_state_;
  bool use_hw_secure_codecs_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmSetServerCertificate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmSetServerCertificate) */ {
 public:
  CdmSetServerCertificate();
  virtual ~CdmSetServerCertificate();

  CdmSetServerCertificate(const CdmSetServerCertificate& from);

  inline CdmSetServerCertificate& operator=(const CdmSetServerCertificate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmSetServerCertificate& default_instance();

  static inline const CdmSetServerCertificate* internal_default_instance() {
    return reinterpret_cast<const CdmSetServerCertificate*>(
               &_CdmSetServerCertificate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmSetServerCertificate* other);

  // implements Message ----------------------------------------------

  inline CdmSetServerCertificate* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmSetServerCertificate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmSetServerCertificate& from);
  void MergeFrom(const CdmSetServerCertificate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmSetServerCertificate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes certificate_data = 2;
  bool has_certificate_data() const;
  void clear_certificate_data();
  static const int kCertificateDataFieldNumber = 2;
  const ::std::string& certificate_data() const;
  void set_certificate_data(const ::std::string& value);
  #if LANG_CXX11
  void set_certificate_data(::std::string&& value);
  #endif
  void set_certificate_data(const char* value);
  void set_certificate_data(const void* value, size_t size);
  ::std::string* mutable_certificate_data();
  ::std::string* release_certificate_data();
  void set_allocated_certificate_data(::std::string* certificate_data);

  // optional int32 callback_handle = 1;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 1;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmSetServerCertificate)
 private:
  void set_has_callback_handle();
  void clear_has_callback_handle();
  void set_has_certificate_data();
  void clear_has_certificate_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr certificate_data_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmCreateSessionAndGenerateRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmCreateSessionAndGenerateRequest) */ {
 public:
  CdmCreateSessionAndGenerateRequest();
  virtual ~CdmCreateSessionAndGenerateRequest();

  CdmCreateSessionAndGenerateRequest(const CdmCreateSessionAndGenerateRequest& from);

  inline CdmCreateSessionAndGenerateRequest& operator=(const CdmCreateSessionAndGenerateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmCreateSessionAndGenerateRequest& default_instance();

  static inline const CdmCreateSessionAndGenerateRequest* internal_default_instance() {
    return reinterpret_cast<const CdmCreateSessionAndGenerateRequest*>(
               &_CdmCreateSessionAndGenerateRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmCreateSessionAndGenerateRequest* other);

  // implements Message ----------------------------------------------

  inline CdmCreateSessionAndGenerateRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmCreateSessionAndGenerateRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmCreateSessionAndGenerateRequest& from);
  void MergeFrom(const CdmCreateSessionAndGenerateRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmCreateSessionAndGenerateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CdmCreateSessionAndGenerateRequest_EmeInitDataType EmeInitDataType;
  static const EmeInitDataType UNKNOWN =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_UNKNOWN;
  static const EmeInitDataType WEBM =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_WEBM;
  static const EmeInitDataType CENC =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_CENC;
  static const EmeInitDataType KEYIDS =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_KEYIDS;
  static inline bool EmeInitDataType_IsValid(int value) {
    return CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(value);
  }
  static const EmeInitDataType EmeInitDataType_MIN =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MIN;
  static const EmeInitDataType EmeInitDataType_MAX =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_MAX;
  static const int EmeInitDataType_ARRAYSIZE =
    CdmCreateSessionAndGenerateRequest_EmeInitDataType_EmeInitDataType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional bytes init_data = 4;
  bool has_init_data() const;
  void clear_init_data();
  static const int kInitDataFieldNumber = 4;
  const ::std::string& init_data() const;
  void set_init_data(const ::std::string& value);
  #if LANG_CXX11
  void set_init_data(::std::string&& value);
  #endif
  void set_init_data(const char* value);
  void set_init_data(const void* value, size_t size);
  ::std::string* mutable_init_data();
  ::std::string* release_init_data();
  void set_allocated_init_data(::std::string* init_data);

  // optional .media.remoting.pb.CdmSessionType session_type = 1;
  bool has_session_type() const;
  void clear_session_type();
  static const int kSessionTypeFieldNumber = 1;
  ::media::remoting::pb::CdmSessionType session_type() const;
  void set_session_type(::media::remoting::pb::CdmSessionType value);

  // optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest.EmeInitDataType init_data_type = 2;
  bool has_init_data_type() const;
  void clear_init_data_type();
  static const int kInitDataTypeFieldNumber = 2;
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType init_data_type() const;
  void set_init_data_type(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 3;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmCreateSessionAndGenerateRequest)
 private:
  void set_has_session_type();
  void clear_has_session_type();
  void set_has_init_data_type();
  void clear_has_init_data_type();
  void set_has_callback_handle();
  void clear_has_callback_handle();
  void set_has_init_data();
  void clear_has_init_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr init_data_;
  int session_type_;
  int init_data_type_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmLoadSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmLoadSession) */ {
 public:
  CdmLoadSession();
  virtual ~CdmLoadSession();

  CdmLoadSession(const CdmLoadSession& from);

  inline CdmLoadSession& operator=(const CdmLoadSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmLoadSession& default_instance();

  static inline const CdmLoadSession* internal_default_instance() {
    return reinterpret_cast<const CdmLoadSession*>(
               &_CdmLoadSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmLoadSession* other);

  // implements Message ----------------------------------------------

  inline CdmLoadSession* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmLoadSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmLoadSession& from);
  void MergeFrom(const CdmLoadSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmLoadSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 2;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional .media.remoting.pb.CdmSessionType session_type = 1;
  bool has_session_type() const;
  void clear_session_type();
  static const int kSessionTypeFieldNumber = 1;
  ::media::remoting::pb::CdmSessionType session_type() const;
  void set_session_type(::media::remoting::pb::CdmSessionType value);

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 3;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmLoadSession)
 private:
  void set_has_session_type();
  void clear_has_session_type();
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  int session_type_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmUpdateSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmUpdateSession) */ {
 public:
  CdmUpdateSession();
  virtual ~CdmUpdateSession();

  CdmUpdateSession(const CdmUpdateSession& from);

  inline CdmUpdateSession& operator=(const CdmUpdateSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmUpdateSession& default_instance();

  static inline const CdmUpdateSession* internal_default_instance() {
    return reinterpret_cast<const CdmUpdateSession*>(
               &_CdmUpdateSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmUpdateSession* other);

  // implements Message ----------------------------------------------

  inline CdmUpdateSession* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmUpdateSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmUpdateSession& from);
  void MergeFrom(const CdmUpdateSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmUpdateSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional bytes response = 3;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 3;
  const ::std::string& response() const;
  void set_response(const ::std::string& value);
  #if LANG_CXX11
  void set_response(::std::string&& value);
  #endif
  void set_response(const char* value);
  void set_response(const void* value, size_t size);
  ::std::string* mutable_response();
  ::std::string* release_response();
  void set_allocated_response(::std::string* response);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 2;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmUpdateSession)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_callback_handle();
  void clear_has_callback_handle();
  void set_has_response();
  void clear_has_response();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr response_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmCloseSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmCloseSession) */ {
 public:
  CdmCloseSession();
  virtual ~CdmCloseSession();

  CdmCloseSession(const CdmCloseSession& from);

  inline CdmCloseSession& operator=(const CdmCloseSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmCloseSession& default_instance();

  static inline const CdmCloseSession* internal_default_instance() {
    return reinterpret_cast<const CdmCloseSession*>(
               &_CdmCloseSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmCloseSession* other);

  // implements Message ----------------------------------------------

  inline CdmCloseSession* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmCloseSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmCloseSession& from);
  void MergeFrom(const CdmCloseSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmCloseSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 2;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmCloseSession)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmRemoveSession : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmRemoveSession) */ {
 public:
  CdmRemoveSession();
  virtual ~CdmRemoveSession();

  CdmRemoveSession(const CdmRemoveSession& from);

  inline CdmRemoveSession& operator=(const CdmRemoveSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmRemoveSession& default_instance();

  static inline const CdmRemoveSession* internal_default_instance() {
    return reinterpret_cast<const CdmRemoveSession*>(
               &_CdmRemoveSession_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmRemoveSession* other);

  // implements Message ----------------------------------------------

  inline CdmRemoveSession* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmRemoveSession* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmRemoveSession& from);
  void MergeFrom(const CdmRemoveSession& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmRemoveSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional int32 callback_handle = 2;
  bool has_callback_handle() const;
  void clear_callback_handle();
  static const int kCallbackHandleFieldNumber = 2;
  ::google::protobuf::int32 callback_handle() const;
  void set_callback_handle(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmRemoveSession)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_callback_handle();
  void clear_has_callback_handle();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::int32 callback_handle_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmPromise : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmPromise) */ {
 public:
  CdmPromise();
  virtual ~CdmPromise();

  CdmPromise(const CdmPromise& from);

  inline CdmPromise& operator=(const CdmPromise& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmPromise& default_instance();

  static inline const CdmPromise* internal_default_instance() {
    return reinterpret_cast<const CdmPromise*>(
               &_CdmPromise_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmPromise* other);

  // implements Message ----------------------------------------------

  inline CdmPromise* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmPromise* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmPromise& from);
  void MergeFrom(const CdmPromise& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmPromise* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 3;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 3;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional string error_message = 7;
  bool has_error_message() const;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 7;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // optional int32 cdm_id = 1;
  bool has_cdm_id() const;
  void clear_cdm_id();
  static const int kCdmIdFieldNumber = 1;
  ::google::protobuf::int32 cdm_id() const;
  void set_cdm_id(::google::protobuf::int32 value);

  // optional int32 decryptor_handle = 2;
  bool has_decryptor_handle() const;
  void clear_decryptor_handle();
  static const int kDecryptorHandleFieldNumber = 2;
  ::google::protobuf::int32 decryptor_handle() const;
  void set_decryptor_handle(::google::protobuf::int32 value);

  // optional bool success = 4;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 4;
  bool success() const;
  void set_success(bool value);

  // optional .media.remoting.pb.CdmException exception = 5;
  bool has_exception() const;
  void clear_exception();
  static const int kExceptionFieldNumber = 5;
  ::media::remoting::pb::CdmException exception() const;
  void set_exception(::media::remoting::pb::CdmException value);

  // optional uint32 system_code = 6;
  bool has_system_code() const;
  void clear_system_code();
  static const int kSystemCodeFieldNumber = 6;
  ::google::protobuf::uint32 system_code() const;
  void set_system_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmPromise)
 private:
  void set_has_cdm_id();
  void clear_has_cdm_id();
  void set_has_decryptor_handle();
  void clear_has_decryptor_handle();
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_success();
  void clear_has_success();
  void set_has_exception();
  void clear_has_exception();
  void set_has_system_code();
  void clear_has_system_code();
  void set_has_error_message();
  void clear_has_error_message();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::google::protobuf::int32 cdm_id_;
  ::google::protobuf::int32 decryptor_handle_;
  bool success_;
  int exception_;
  ::google::protobuf::uint32 system_code_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmClientOnSessionMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionMessage) */ {
 public:
  CdmClientOnSessionMessage();
  virtual ~CdmClientOnSessionMessage();

  CdmClientOnSessionMessage(const CdmClientOnSessionMessage& from);

  inline CdmClientOnSessionMessage& operator=(const CdmClientOnSessionMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionMessage& default_instance();

  static inline const CdmClientOnSessionMessage* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionMessage*>(
               &_CdmClientOnSessionMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmClientOnSessionMessage* other);

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmClientOnSessionMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmClientOnSessionMessage& from);
  void MergeFrom(const CdmClientOnSessionMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional bytes message = 3;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const void* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional .media.remoting.pb.CdmMessageType message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  ::media::remoting::pb::CdmMessageType message_type() const;
  void set_message_type(::media::remoting::pb::CdmMessageType value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionMessage)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_message_type();
  void clear_has_message_type();
  void set_has_message();
  void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  int message_type_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmClientOnSessionKeysChange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionKeysChange) */ {
 public:
  CdmClientOnSessionKeysChange();
  virtual ~CdmClientOnSessionKeysChange();

  CdmClientOnSessionKeysChange(const CdmClientOnSessionKeysChange& from);

  inline CdmClientOnSessionKeysChange& operator=(const CdmClientOnSessionKeysChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionKeysChange& default_instance();

  static inline const CdmClientOnSessionKeysChange* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionKeysChange*>(
               &_CdmClientOnSessionKeysChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmClientOnSessionKeysChange* other);

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionKeysChange* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmClientOnSessionKeysChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmClientOnSessionKeysChange& from);
  void MergeFrom(const CdmClientOnSessionKeysChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionKeysChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .media.remoting.pb.CdmKeyInformation key_information = 3;
  int key_information_size() const;
  void clear_key_information();
  static const int kKeyInformationFieldNumber = 3;
  const ::media::remoting::pb::CdmKeyInformation& key_information(int index) const;
  ::media::remoting::pb::CdmKeyInformation* mutable_key_information(int index);
  ::media::remoting::pb::CdmKeyInformation* add_key_information();
  ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >*
      mutable_key_information();
  const ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >&
      key_information() const;

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional bool has_additional_usable_key = 2;
  bool has_has_additional_usable_key() const;
  void clear_has_additional_usable_key();
  static const int kHasAdditionalUsableKeyFieldNumber = 2;
  bool has_additional_usable_key() const;
  void set_has_additional_usable_key(bool value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionKeysChange)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_has_additional_usable_key();
  void clear_has_has_additional_usable_key();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation > key_information_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  bool has_additional_usable_key_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CdmClientOnSessionExpirationUpdate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.CdmClientOnSessionExpirationUpdate) */ {
 public:
  CdmClientOnSessionExpirationUpdate();
  virtual ~CdmClientOnSessionExpirationUpdate();

  CdmClientOnSessionExpirationUpdate(const CdmClientOnSessionExpirationUpdate& from);

  inline CdmClientOnSessionExpirationUpdate& operator=(const CdmClientOnSessionExpirationUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const CdmClientOnSessionExpirationUpdate& default_instance();

  static inline const CdmClientOnSessionExpirationUpdate* internal_default_instance() {
    return reinterpret_cast<const CdmClientOnSessionExpirationUpdate*>(
               &_CdmClientOnSessionExpirationUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(CdmClientOnSessionExpirationUpdate* other);

  // implements Message ----------------------------------------------

  inline CdmClientOnSessionExpirationUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  CdmClientOnSessionExpirationUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const CdmClientOnSessionExpirationUpdate& from);
  void MergeFrom(const CdmClientOnSessionExpirationUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CdmClientOnSessionExpirationUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_id = 1;
  bool has_session_id() const;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // optional double new_expiry_time_sec = 2;
  bool has_new_expiry_time_sec() const;
  void clear_new_expiry_time_sec();
  static const int kNewExpiryTimeSecFieldNumber = 2;
  double new_expiry_time_sec() const;
  void set_new_expiry_time_sec(double value);

  // @@protoc_insertion_point(class_scope:media.remoting.pb.CdmClientOnSessionExpirationUpdate)
 private:
  void set_has_session_id();
  void clear_has_session_id();
  void set_has_new_expiry_time_sec();
  void clear_has_new_expiry_time_sec();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  double new_expiry_time_sec_;
  friend struct protobuf_rpc_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RpcMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:media.remoting.pb.RpcMessage) */ {
 public:
  RpcMessage();
  virtual ~RpcMessage();

  RpcMessage(const RpcMessage& from);

  inline RpcMessage& operator=(const RpcMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const RpcMessage& default_instance();

  enum RpcOneofCase {
    kIntegerValue = 3,
    kInteger64Value = 4,
    kDoubleValue = 5,
    kBooleanValue = 6,
    kStringValue = 7,
    kRendererInitializeRpc = 100,
    kRendererFlushuntilRpc = 101,
    kRendererSetCdmRpc = 102,
    kRendererclientOntimeupdateRpc = 200,
    kRendererclientOnvideonatualsizechangeRpc = 201,
    kRendererclientOnstatisticsupdateRpc = 202,
    kRendererclientOnbufferingstatechangeRpc = 203,
    kRendererclientOnaudioconfigchangeRpc = 204,
    kRendererclientOnvideoconfigchangeRpc = 205,
    kDemuxerstreamReaduntilRpc = 300,
    kDemuxerstreamInitializecbRpc = 400,
    kDemuxerstreamReaduntilcbRpc = 401,
    kCdmInitializeRpc = 500,
    kCdmSetservercertificateRpc = 501,
    kCdmCreatesessionandgeneraterequestRpc = 502,
    kCdmLoadsessionRpc = 503,
    kCdmUpdatesessionRpc = 504,
    kCdmClosesessionRpc = 505,
    kCdmRemovesessionRpc = 506,
    kCdmPromiseRpc = 600,
    kCdmclientOnsessionmessageRpc = 601,
    kCdmclientOnsessionkeychangeRpc = 602,
    kCdmclientOnsessionexpirationupdateRpc = 603,
    RPC_ONEOF_NOT_SET = 0,
  };

  static inline const RpcMessage* internal_default_instance() {
    return reinterpret_cast<const RpcMessage*>(
               &_RpcMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  GOOGLE_ATTRIBUTE_NOINLINE void Swap(RpcMessage* other);

  // implements Message ----------------------------------------------

  inline RpcMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  RpcMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RpcMessage& from);
  void MergeFrom(const RpcMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RpcMessage_RpcProc RpcProc;
  static const RpcProc RPC_INTERNAL =
    RpcMessage_RpcProc_RPC_INTERNAL;
  static const RpcProc RPC_ACQUIRE_RENDERER =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER;
  static const RpcProc RPC_ACQUIRE_RENDERER_DONE =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE;
  static const RpcProc RPC_ACQUIRE_CDM =
    RpcMessage_RpcProc_RPC_ACQUIRE_CDM;
  static const RpcProc RPC_ACQUIRE_CDM_DONE =
    RpcMessage_RpcProc_RPC_ACQUIRE_CDM_DONE;
  static const RpcProc RPC_R_INITIALIZE =
    RpcMessage_RpcProc_RPC_R_INITIALIZE;
  static const RpcProc RPC_R_FLUSHUNTIL =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL;
  static const RpcProc RPC_R_STARTPLAYINGFROM =
    RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM;
  static const RpcProc RPC_R_SETPLAYBACKRATE =
    RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE;
  static const RpcProc RPC_R_SETVOLUME =
    RpcMessage_RpcProc_RPC_R_SETVOLUME;
  static const RpcProc RPC_R_SETCDM =
    RpcMessage_RpcProc_RPC_R_SETCDM;
  static const RpcProc RPC_R_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK;
  static const RpcProc RPC_R_FLUSHUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK;
  static const RpcProc RPC_R_SETCDM_CALLBACK =
    RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK;
  static const RpcProc RPC_RC_ONTIMEUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE;
  static const RpcProc RPC_RC_ONBUFFERINGSTATECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE;
  static const RpcProc RPC_RC_ONENDED =
    RpcMessage_RpcProc_RPC_RC_ONENDED;
  static const RpcProc RPC_RC_ONERROR =
    RpcMessage_RpcProc_RPC_RC_ONERROR;
  static const RpcProc RPC_RC_ONVIDEONATURALSIZECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE;
  static const RpcProc RPC_RC_ONVIDEOOPACITYCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE;
  static const RpcProc RPC_RC_ONSTATISTICSUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE;
  static const RpcProc RPC_RC_ONWAITINGFORDECRYPTIONKEY =
    RpcMessage_RpcProc_RPC_RC_ONWAITINGFORDECRYPTIONKEY;
  static const RpcProc RPC_RC_ONDURATIONCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONDURATIONCHANGE;
  static const RpcProc RPC_RC_ONAUDIOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE;
  static const RpcProc RPC_RC_ONVIDEOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE;
  static const RpcProc RPC_DS_INITIALIZE =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE;
  static const RpcProc RPC_DS_READUNTIL =
    RpcMessage_RpcProc_RPC_DS_READUNTIL;
  static const RpcProc RPC_DS_ENABLEBITSTREAMCONVERTER =
    RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER;
  static const RpcProc RPC_DS_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK;
  static const RpcProc RPC_DS_READUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK;
  static const RpcProc RPC_CDM_SETCLIENT =
    RpcMessage_RpcProc_RPC_CDM_SETCLIENT;
  static const RpcProc RPC_CDM_INITIALIZE =
    RpcMessage_RpcProc_RPC_CDM_INITIALIZE;
  static const RpcProc RPC_CDM_SETSERVERCERTIFICATE =
    RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE;
  static const RpcProc RPC_CDM_CREATESESSIONANDGENERATEREQUEST =
    RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST;
  static const RpcProc RPC_CDM_LOADSESSION =
    RpcMessage_RpcProc_RPC_CDM_LOADSESSION;
  static const RpcProc RPC_CDM_UPDATESESSION =
    RpcMessage_RpcProc_RPC_CDM_UPDATESESSION;
  static const RpcProc RPC_CDM_CLOSESESSION =
    RpcMessage_RpcProc_RPC_CDM_CLOSESESSION;
  static const RpcProc RPC_CDM_REMOVESESSION =
    RpcMessage_RpcProc_RPC_CDM_REMOVESESSION;
  static const RpcProc RPC_CDM_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_INITIALIZE_CALLBACK;
  static const RpcProc RPC_CDM_SETSERVERCERTIFICATE_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_SETSERVERCERTIFICATE_CALLBACK;
  static const RpcProc RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_CREATESESSIONANDGENERATEREQUEST_CALLBACK;
  static const RpcProc RPC_CDM_LOADSESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_LOADSESSION_CALLBACK;
  static const RpcProc RPC_CDM_UPDATESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_UPDATESESSION_CALLBACK;
  static const RpcProc RPC_CDM_CLOSESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_CLOSESESSION_CALLBACK;
  static const RpcProc RPC_CDM_REMOVESESSION_CALLBACK =
    RpcMessage_RpcProc_RPC_CDM_REMOVESESSION_CALLBACK;
  static const RpcProc RPC_CDMC_ONSESSIONMESSAGE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONMESSAGE;
  static const RpcProc RPC_CDMC_ONSESSIONCLOSED =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONCLOSED;
  static const RpcProc RPC_CDMC_ONSESSIONKEYSCHANGE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONKEYSCHANGE;
  static const RpcProc RPC_CDMC_ONSESSIONEXPIRATIONUPDATE =
    RpcMessage_RpcProc_RPC_CDMC_ONSESSIONEXPIRATIONUPDATE;
  static inline bool RpcProc_IsValid(int value) {
    return RpcMessage_RpcProc_IsValid(value);
  }
  static const RpcProc RpcProc_MIN =
    RpcMessage_RpcProc_RpcProc_MIN;
  static const RpcProc RpcProc_MAX =
    RpcMessage_RpcProc_RpcProc_MAX;
  static const int RpcProc_ARRAYSIZE =
    RpcMessage_RpcProc_RpcProc_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 handle = 1;
  bool has_handle() const;
  void clear_handle();
  static const int kHandleFieldNumber = 1;
  ::google::protobuf::int32 handle() const;
  void set_handle(::google::protobuf::int32 value);

  // optional .media.remoting.pb.RpcMessage.RpcProc proc = 2;
  bool has_proc() const;
  void clear_proc();
  static const int kProcFieldNumber = 2;
  ::media::remoting::pb::RpcMessage_RpcProc proc() const;
  void set_proc(::media::remoting::pb::RpcMessage_RpcProc value);

  // optional int32 integer_value = 3;
  bool has_integer_value() const;
  void clear_integer_value();
  static const int kIntegerValueFieldNumber = 3;
  ::google::protobuf::int32 integer_value() const;
  void set_integer_value(::google::protobuf::int32 value);

  // optional int64 integer64_value = 4;
  bool has_integer64_value() const;
  void clear_integer64_value();
  static const int kInteger64ValueFieldNumber = 4;
  ::google::protobuf::int64 integer64_value() const;
  void set_integer64_value(::google::protobuf::int64 value);

  // optional double double_value = 5;
  bool has_double_value() const;
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 5;
  double double_value() const;
  void set_double_value(double value);

  // optional bool boolean_value = 6;
  bool has_boolean_value() const;
  void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 6;
  bool boolean_value() const;
  void set_boolean_value(bool value);

  // optional string string_value = 7;
  bool has_string_value() const;
  void clear_string_value();
  static const int kStringValueFieldNumber = 7;
  const ::std::string& string_value() const;
  void set_string_value(const ::std::string& value);
  #if LANG_CXX11
  void set_string_value(::std::string&& value);
  #endif
  void set_string_value(const char* value);
  void set_string_value(const char* value, size_t size);
  ::std::string* mutable_string_value();
  ::std::string* release_string_value();
  void set_allocated_string_value(::std::string* string_value);

  // optional .media.remoting.pb.RendererInitialize renderer_initialize_rpc = 100;
  bool has_renderer_initialize_rpc() const;
  void clear_renderer_initialize_rpc();
  static const int kRendererInitializeRpcFieldNumber = 100;
  const ::media::remoting::pb::RendererInitialize& renderer_initialize_rpc() const;
  ::media::remoting::pb::RendererInitialize* mutable_renderer_initialize_rpc();
  ::media::remoting::pb::RendererInitialize* release_renderer_initialize_rpc();
  void set_allocated_renderer_initialize_rpc(::media::remoting::pb::RendererInitialize* renderer_initialize_rpc);

  // optional .media.remoting.pb.RendererFlushUntil renderer_flushuntil_rpc = 101;
  bool has_renderer_flushuntil_rpc() const;
  void clear_renderer_flushuntil_rpc();
  static const int kRendererFlushuntilRpcFieldNumber = 101;
  const ::media::remoting::pb::RendererFlushUntil& renderer_flushuntil_rpc() const;
  ::media::remoting::pb::RendererFlushUntil* mutable_renderer_flushuntil_rpc();
  ::media::remoting::pb::RendererFlushUntil* release_renderer_flushuntil_rpc();
  void set_allocated_renderer_flushuntil_rpc(::media::remoting::pb::RendererFlushUntil* renderer_flushuntil_rpc);

  // optional .media.remoting.pb.RendererSetCdm renderer_set_cdm_rpc = 102;
  bool has_renderer_set_cdm_rpc() const;
  void clear_renderer_set_cdm_rpc();
  static const int kRendererSetCdmRpcFieldNumber = 102;
  const ::media::remoting::pb::RendererSetCdm& renderer_set_cdm_rpc() const;
  ::media::remoting::pb::RendererSetCdm* mutable_renderer_set_cdm_rpc();
  ::media::remoting::pb::RendererSetCdm* release_renderer_set_cdm_rpc();
  void set_allocated_renderer_set_cdm_rpc(::media::remoting::pb::RendererSetCdm* renderer_set_cdm_rpc);

  // optional .media.remoting.pb.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
  bool has_rendererclient_ontimeupdate_rpc() const;
  void clear_rendererclient_ontimeupdate_rpc();
  static const int kRendererclientOntimeupdateRpcFieldNumber = 200;
  const ::media::remoting::pb::RendererClientOnTimeUpdate& rendererclient_ontimeupdate_rpc() const;
  ::media::remoting::pb::RendererClientOnTimeUpdate* mutable_rendererclient_ontimeupdate_rpc();
  ::media::remoting::pb::RendererClientOnTimeUpdate* release_rendererclient_ontimeupdate_rpc();
  void set_allocated_rendererclient_ontimeupdate_rpc(::media::remoting::pb::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc);

  // optional .media.remoting.pb.Size rendererclient_onvideonatualsizechange_rpc = 201;
  bool has_rendererclient_onvideonatualsizechange_rpc() const;
  void clear_rendererclient_onvideonatualsizechange_rpc();
  static const int kRendererclientOnvideonatualsizechangeRpcFieldNumber = 201;
  const ::media::remoting::pb::Size& rendererclient_onvideonatualsizechange_rpc() const;
  ::media::remoting::pb::Size* mutable_rendererclient_onvideonatualsizechange_rpc();
  ::media::remoting::pb::Size* release_rendererclient_onvideonatualsizechange_rpc();
  void set_allocated_rendererclient_onvideonatualsizechange_rpc(::media::remoting::pb::Size* rendererclient_onvideonatualsizechange_rpc);

  // optional .media.remoting.pb.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
  bool has_rendererclient_onstatisticsupdate_rpc() const;
  void clear_rendererclient_onstatisticsupdate_rpc();
  static const int kRendererclientOnstatisticsupdateRpcFieldNumber = 202;
  const ::media::remoting::pb::PipelineStatistics& rendererclient_onstatisticsupdate_rpc() const;
  ::media::remoting::pb::PipelineStatistics* mutable_rendererclient_onstatisticsupdate_rpc();
  ::media::remoting::pb::PipelineStatistics* release_rendererclient_onstatisticsupdate_rpc();
  void set_allocated_rendererclient_onstatisticsupdate_rpc(::media::remoting::pb::PipelineStatistics* rendererclient_onstatisticsupdate_rpc);

  // optional .media.remoting.pb.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
  bool has_rendererclient_onbufferingstatechange_rpc() const;
  void clear_rendererclient_onbufferingstatechange_rpc();
  static const int kRendererclientOnbufferingstatechangeRpcFieldNumber = 203;
  const ::media::remoting::pb::RendererClientOnBufferingStateChange& rendererclient_onbufferingstatechange_rpc() const;
  ::media::remoting::pb::RendererClientOnBufferingStateChange* mutable_rendererclient_onbufferingstatechange_rpc();
  ::media::remoting::pb::RendererClientOnBufferingStateChange* release_rendererclient_onbufferingstatechange_rpc();
  void set_allocated_rendererclient_onbufferingstatechange_rpc(::media::remoting::pb::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc);

  // optional .media.remoting.pb.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
  bool has_rendererclient_onaudioconfigchange_rpc() const;
  void clear_rendererclient_onaudioconfigchange_rpc();
  static const int kRendererclientOnaudioconfigchangeRpcFieldNumber = 204;
  const ::media::remoting::pb::RendererClientOnAudioConfigChange& rendererclient_onaudioconfigchange_rpc() const;
  ::media::remoting::pb::RendererClientOnAudioConfigChange* mutable_rendererclient_onaudioconfigchange_rpc();
  ::media::remoting::pb::RendererClientOnAudioConfigChange* release_rendererclient_onaudioconfigchange_rpc();
  void set_allocated_rendererclient_onaudioconfigchange_rpc(::media::remoting::pb::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc);

  // optional .media.remoting.pb.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
  bool has_rendererclient_onvideoconfigchange_rpc() const;
  void clear_rendererclient_onvideoconfigchange_rpc();
  static const int kRendererclientOnvideoconfigchangeRpcFieldNumber = 205;
  const ::media::remoting::pb::RendererClientOnVideoConfigChange& rendererclient_onvideoconfigchange_rpc() const;
  ::media::remoting::pb::RendererClientOnVideoConfigChange* mutable_rendererclient_onvideoconfigchange_rpc();
  ::media::remoting::pb::RendererClientOnVideoConfigChange* release_rendererclient_onvideoconfigchange_rpc();
  void set_allocated_rendererclient_onvideoconfigchange_rpc(::media::remoting::pb::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc);

  // optional .media.remoting.pb.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
  bool has_demuxerstream_readuntil_rpc() const;
  void clear_demuxerstream_readuntil_rpc();
  static const int kDemuxerstreamReaduntilRpcFieldNumber = 300;
  const ::media::remoting::pb::DemuxerStreamReadUntil& demuxerstream_readuntil_rpc() const;
  ::media::remoting::pb::DemuxerStreamReadUntil* mutable_demuxerstream_readuntil_rpc();
  ::media::remoting::pb::DemuxerStreamReadUntil* release_demuxerstream_readuntil_rpc();
  void set_allocated_demuxerstream_readuntil_rpc(::media::remoting::pb::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc);

  // optional .media.remoting.pb.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
  bool has_demuxerstream_initializecb_rpc() const;
  void clear_demuxerstream_initializecb_rpc();
  static const int kDemuxerstreamInitializecbRpcFieldNumber = 400;
  const ::media::remoting::pb::DemuxerStreamInitializeCallback& demuxerstream_initializecb_rpc() const;
  ::media::remoting::pb::DemuxerStreamInitializeCallback* mutable_demuxerstream_initializecb_rpc();
  ::media::remoting::pb::DemuxerStreamInitializeCallback* release_demuxerstream_initializecb_rpc();
  void set_allocated_demuxerstream_initializecb_rpc(::media::remoting::pb::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc);

  // optional .media.remoting.pb.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
  bool has_demuxerstream_readuntilcb_rpc() const;
  void clear_demuxerstream_readuntilcb_rpc();
  static const int kDemuxerstreamReaduntilcbRpcFieldNumber = 401;
  const ::media::remoting::pb::DemuxerStreamReadUntilCallback& demuxerstream_readuntilcb_rpc() const;
  ::media::remoting::pb::DemuxerStreamReadUntilCallback* mutable_demuxerstream_readuntilcb_rpc();
  ::media::remoting::pb::DemuxerStreamReadUntilCallback* release_demuxerstream_readuntilcb_rpc();
  void set_allocated_demuxerstream_readuntilcb_rpc(::media::remoting::pb::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc);

  // optional .media.remoting.pb.CdmInitialize cdm_initialize_rpc = 500;
  bool has_cdm_initialize_rpc() const;
  void clear_cdm_initialize_rpc();
  static const int kCdmInitializeRpcFieldNumber = 500;
  const ::media::remoting::pb::CdmInitialize& cdm_initialize_rpc() const;
  ::media::remoting::pb::CdmInitialize* mutable_cdm_initialize_rpc();
  ::media::remoting::pb::CdmInitialize* release_cdm_initialize_rpc();
  void set_allocated_cdm_initialize_rpc(::media::remoting::pb::CdmInitialize* cdm_initialize_rpc);

  // optional .media.remoting.pb.CdmSetServerCertificate cdm_setservercertificate_rpc = 501;
  bool has_cdm_setservercertificate_rpc() const;
  void clear_cdm_setservercertificate_rpc();
  static const int kCdmSetservercertificateRpcFieldNumber = 501;
  const ::media::remoting::pb::CdmSetServerCertificate& cdm_setservercertificate_rpc() const;
  ::media::remoting::pb::CdmSetServerCertificate* mutable_cdm_setservercertificate_rpc();
  ::media::remoting::pb::CdmSetServerCertificate* release_cdm_setservercertificate_rpc();
  void set_allocated_cdm_setservercertificate_rpc(::media::remoting::pb::CdmSetServerCertificate* cdm_setservercertificate_rpc);

  // optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest cdm_createsessionandgeneraterequest_rpc = 502;
  bool has_cdm_createsessionandgeneraterequest_rpc() const;
  void clear_cdm_createsessionandgeneraterequest_rpc();
  static const int kCdmCreatesessionandgeneraterequestRpcFieldNumber = 502;
  const ::media::remoting::pb::CdmCreateSessionAndGenerateRequest& cdm_createsessionandgeneraterequest_rpc() const;
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* mutable_cdm_createsessionandgeneraterequest_rpc();
  ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* release_cdm_createsessionandgeneraterequest_rpc();
  void set_allocated_cdm_createsessionandgeneraterequest_rpc(::media::remoting::pb::CdmCreateSessionAndGenerateRequest* cdm_createsessionandgeneraterequest_rpc);

  // optional .media.remoting.pb.CdmLoadSession cdm_loadsession_rpc = 503;
  bool has_cdm_loadsession_rpc() const;
  void clear_cdm_loadsession_rpc();
  static const int kCdmLoadsessionRpcFieldNumber = 503;
  const ::media::remoting::pb::CdmLoadSession& cdm_loadsession_rpc() const;
  ::media::remoting::pb::CdmLoadSession* mutable_cdm_loadsession_rpc();
  ::media::remoting::pb::CdmLoadSession* release_cdm_loadsession_rpc();
  void set_allocated_cdm_loadsession_rpc(::media::remoting::pb::CdmLoadSession* cdm_loadsession_rpc);

  // optional .media.remoting.pb.CdmUpdateSession cdm_updatesession_rpc = 504;
  bool has_cdm_updatesession_rpc() const;
  void clear_cdm_updatesession_rpc();
  static const int kCdmUpdatesessionRpcFieldNumber = 504;
  const ::media::remoting::pb::CdmUpdateSession& cdm_updatesession_rpc() const;
  ::media::remoting::pb::CdmUpdateSession* mutable_cdm_updatesession_rpc();
  ::media::remoting::pb::CdmUpdateSession* release_cdm_updatesession_rpc();
  void set_allocated_cdm_updatesession_rpc(::media::remoting::pb::CdmUpdateSession* cdm_updatesession_rpc);

  // optional .media.remoting.pb.CdmCloseSession cdm_closesession_rpc = 505;
  bool has_cdm_closesession_rpc() const;
  void clear_cdm_closesession_rpc();
  static const int kCdmClosesessionRpcFieldNumber = 505;
  const ::media::remoting::pb::CdmCloseSession& cdm_closesession_rpc() const;
  ::media::remoting::pb::CdmCloseSession* mutable_cdm_closesession_rpc();
  ::media::remoting::pb::CdmCloseSession* release_cdm_closesession_rpc();
  void set_allocated_cdm_closesession_rpc(::media::remoting::pb::CdmCloseSession* cdm_closesession_rpc);

  // optional .media.remoting.pb.CdmRemoveSession cdm_removesession_rpc = 506;
  bool has_cdm_removesession_rpc() const;
  void clear_cdm_removesession_rpc();
  static const int kCdmRemovesessionRpcFieldNumber = 506;
  const ::media::remoting::pb::CdmRemoveSession& cdm_removesession_rpc() const;
  ::media::remoting::pb::CdmRemoveSession* mutable_cdm_removesession_rpc();
  ::media::remoting::pb::CdmRemoveSession* release_cdm_removesession_rpc();
  void set_allocated_cdm_removesession_rpc(::media::remoting::pb::CdmRemoveSession* cdm_removesession_rpc);

  // optional .media.remoting.pb.CdmPromise cdm_promise_rpc = 600;
  bool has_cdm_promise_rpc() const;
  void clear_cdm_promise_rpc();
  static const int kCdmPromiseRpcFieldNumber = 600;
  const ::media::remoting::pb::CdmPromise& cdm_promise_rpc() const;
  ::media::remoting::pb::CdmPromise* mutable_cdm_promise_rpc();
  ::media::remoting::pb::CdmPromise* release_cdm_promise_rpc();
  void set_allocated_cdm_promise_rpc(::media::remoting::pb::CdmPromise* cdm_promise_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionMessage cdmclient_onsessionmessage_rpc = 601;
  bool has_cdmclient_onsessionmessage_rpc() const;
  void clear_cdmclient_onsessionmessage_rpc();
  static const int kCdmclientOnsessionmessageRpcFieldNumber = 601;
  const ::media::remoting::pb::CdmClientOnSessionMessage& cdmclient_onsessionmessage_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionMessage* mutable_cdmclient_onsessionmessage_rpc();
  ::media::remoting::pb::CdmClientOnSessionMessage* release_cdmclient_onsessionmessage_rpc();
  void set_allocated_cdmclient_onsessionmessage_rpc(::media::remoting::pb::CdmClientOnSessionMessage* cdmclient_onsessionmessage_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionKeysChange cdmclient_onsessionkeychange_rpc = 602;
  bool has_cdmclient_onsessionkeychange_rpc() const;
  void clear_cdmclient_onsessionkeychange_rpc();
  static const int kCdmclientOnsessionkeychangeRpcFieldNumber = 602;
  const ::media::remoting::pb::CdmClientOnSessionKeysChange& cdmclient_onsessionkeychange_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionKeysChange* mutable_cdmclient_onsessionkeychange_rpc();
  ::media::remoting::pb::CdmClientOnSessionKeysChange* release_cdmclient_onsessionkeychange_rpc();
  void set_allocated_cdmclient_onsessionkeychange_rpc(::media::remoting::pb::CdmClientOnSessionKeysChange* cdmclient_onsessionkeychange_rpc);

  // optional .media.remoting.pb.CdmClientOnSessionExpirationUpdate cdmclient_onsessionexpirationupdate_rpc = 603;
  bool has_cdmclient_onsessionexpirationupdate_rpc() const;
  void clear_cdmclient_onsessionexpirationupdate_rpc();
  static const int kCdmclientOnsessionexpirationupdateRpcFieldNumber = 603;
  const ::media::remoting::pb::CdmClientOnSessionExpirationUpdate& cdmclient_onsessionexpirationupdate_rpc() const;
  ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* mutable_cdmclient_onsessionexpirationupdate_rpc();
  ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* release_cdmclient_onsessionexpirationupdate_rpc();
  void set_allocated_cdmclient_onsessionexpirationupdate_rpc(::media::remoting::pb::CdmClientOnSessionExpirationUpdate* cdmclient_onsessionexpirationupdate_rpc);

  RpcOneofCase rpc_oneof_case() const;
  // @@protoc_insertion_point(class_scope:media.remoting.pb.RpcMessage)
 private:
  void set_has_handle();
  void clear_has_handle();
  void set_has_proc();
  void clear_has_proc();
  void set_has_integer_value();
  void set_has_integer64_value();
  void set_has_double_value();
  void set_has_boolean_value();
  void set_has_string_value();
  void set_has_renderer_initialize_rpc();
  void set_has_renderer_flushuntil_rpc();
  void set_has_renderer_set_cdm_rpc();
  void set_has_rendererclient_ontimeupdate_rpc();
  void set_has_rendererclient_onvideonatualsizechange_rpc();
  void set_has_rendererclient_onstatisticsupdate_rpc();
  void set_has_rendererclient_onbufferingstatechange_rpc();
  void set_has_rendererclient_onaudioconfigchange_rpc();
  void set_has_rendererclient_onvideoconfigchange_rpc();
  void set_has_demuxerstream_readuntil_rpc();
  void set_has_demuxerstream_initializecb_rpc();
  void set_has_demuxerstream_readuntilcb_rpc();
  void set_has_cdm_initialize_rpc();
  void set_has_cdm_setservercertificate_rpc();
  void set_has_cdm_createsessionandgeneraterequest_rpc();
  void set_has_cdm_loadsession_rpc();
  void set_has_cdm_updatesession_rpc();
  void set_has_cdm_closesession_rpc();
  void set_has_cdm_removesession_rpc();
  void set_has_cdm_promise_rpc();
  void set_has_cdmclient_onsessionmessage_rpc();
  void set_has_cdmclient_onsessionkeychange_rpc();
  void set_has_cdmclient_onsessionexpirationupdate_rpc();

  inline bool has_rpc_oneof() const;
  void clear_rpc_oneof();
  inline void clear_has_rpc_oneof();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 handle_;
  int proc_;
  union RpcOneofUnion {
    RpcOneofUnion() {}
    ::google::protobuf::int32 integer_value_;
    ::google::protobuf::int64 integer64_value_;
    double double_value_;
    bool boolean_value_;
    ::google::protobuf::internal::ArenaStringPtr string_value_;
    ::media::remoting::pb::RendererInitialize* renderer_initialize_rpc_;
    ::media::remoting::pb::RendererFlushUntil* renderer_flushuntil_rpc_;
    ::media::remoting::pb::RendererSetCdm* renderer_set_cdm_rpc_;
    ::media::remoting::pb::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc_;
    ::media::remoting::pb::Size* rendererclient_onvideonatualsizechange_rpc_;
    ::media::remoting::pb::PipelineStatistics* rendererclient_onstatisticsupdate_rpc_;
    ::media::remoting::pb::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc_;
    ::media::remoting::pb::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc_;
    ::media::remoting::pb::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc_;
    ::media::remoting::pb::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc_;
    ::media::remoting::pb::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc_;
    ::media::remoting::pb::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc_;
    ::media::remoting::pb::CdmInitialize* cdm_initialize_rpc_;
    ::media::remoting::pb::CdmSetServerCertificate* cdm_setservercertificate_rpc_;
    ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* cdm_createsessionandgeneraterequest_rpc_;
    ::media::remoting::pb::CdmLoadSession* cdm_loadsession_rpc_;
    ::media::remoting::pb::CdmUpdateSession* cdm_updatesession_rpc_;
    ::media::remoting::pb::CdmCloseSession* cdm_closesession_rpc_;
    ::media::remoting::pb::CdmRemoveSession* cdm_removesession_rpc_;
    ::media::remoting::pb::CdmPromise* cdm_promise_rpc_;
    ::media::remoting::pb::CdmClientOnSessionMessage* cdmclient_onsessionmessage_rpc_;
    ::media::remoting::pb::CdmClientOnSessionKeysChange* cdmclient_onsessionkeychange_rpc_;
    ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* cdmclient_onsessionexpirationupdate_rpc_;
  } rpc_oneof_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_rpc_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DecoderBuffer

// optional int64 timestamp_usec = 1;
inline bool DecoderBuffer::has_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecoderBuffer::set_has_timestamp_usec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecoderBuffer::clear_has_timestamp_usec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecoderBuffer::clear_timestamp_usec() {
  timestamp_usec_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_usec();
}
inline ::google::protobuf::int64 DecoderBuffer::timestamp_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.timestamp_usec)
  return timestamp_usec_;
}
inline void DecoderBuffer::set_timestamp_usec(::google::protobuf::int64 value) {
  set_has_timestamp_usec();
  timestamp_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.timestamp_usec)
}

// optional int64 duration_usec = 2;
inline bool DecoderBuffer::has_duration_usec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecoderBuffer::set_has_duration_usec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DecoderBuffer::clear_has_duration_usec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DecoderBuffer::clear_duration_usec() {
  duration_usec_ = GOOGLE_LONGLONG(0);
  clear_has_duration_usec();
}
inline ::google::protobuf::int64 DecoderBuffer::duration_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.duration_usec)
  return duration_usec_;
}
inline void DecoderBuffer::set_duration_usec(::google::protobuf::int64 value) {
  set_has_duration_usec();
  duration_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.duration_usec)
}

// optional bool is_key_frame = 3;
inline bool DecoderBuffer::has_is_key_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DecoderBuffer::set_has_is_key_frame() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DecoderBuffer::clear_has_is_key_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DecoderBuffer::clear_is_key_frame() {
  is_key_frame_ = false;
  clear_has_is_key_frame();
}
inline bool DecoderBuffer::is_key_frame() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.is_key_frame)
  return is_key_frame_;
}
inline void DecoderBuffer::set_is_key_frame(bool value) {
  set_has_is_key_frame();
  is_key_frame_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.is_key_frame)
}

// optional .media.remoting.pb.DecryptConfig decrypt_config = 4;
inline bool DecoderBuffer::has_decrypt_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecoderBuffer::set_has_decrypt_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecoderBuffer::clear_has_decrypt_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecoderBuffer::clear_decrypt_config() {
  if (decrypt_config_ != NULL) decrypt_config_->::media::remoting::pb::DecryptConfig::Clear();
  clear_has_decrypt_config();
}
inline const ::media::remoting::pb::DecryptConfig& DecoderBuffer::decrypt_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.decrypt_config)
  return decrypt_config_ != NULL ? *decrypt_config_
                         : *::media::remoting::pb::DecryptConfig::internal_default_instance();
}
inline ::media::remoting::pb::DecryptConfig* DecoderBuffer::mutable_decrypt_config() {
  set_has_decrypt_config();
  if (decrypt_config_ == NULL) {
    decrypt_config_ = new ::media::remoting::pb::DecryptConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecoderBuffer.decrypt_config)
  return decrypt_config_;
}
inline ::media::remoting::pb::DecryptConfig* DecoderBuffer::release_decrypt_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecoderBuffer.decrypt_config)
  clear_has_decrypt_config();
  ::media::remoting::pb::DecryptConfig* temp = decrypt_config_;
  decrypt_config_ = NULL;
  return temp;
}
inline void DecoderBuffer::set_allocated_decrypt_config(::media::remoting::pb::DecryptConfig* decrypt_config) {
  delete decrypt_config_;
  decrypt_config_ = decrypt_config;
  if (decrypt_config) {
    set_has_decrypt_config();
  } else {
    clear_has_decrypt_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecoderBuffer.decrypt_config)
}

// optional int64 front_discard_usec = 5;
inline bool DecoderBuffer::has_front_discard_usec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecoderBuffer::set_has_front_discard_usec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DecoderBuffer::clear_has_front_discard_usec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DecoderBuffer::clear_front_discard_usec() {
  front_discard_usec_ = GOOGLE_LONGLONG(0);
  clear_has_front_discard_usec();
}
inline ::google::protobuf::int64 DecoderBuffer::front_discard_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.front_discard_usec)
  return front_discard_usec_;
}
inline void DecoderBuffer::set_front_discard_usec(::google::protobuf::int64 value) {
  set_has_front_discard_usec();
  front_discard_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.front_discard_usec)
}

// optional int64 back_discard_usec = 6;
inline bool DecoderBuffer::has_back_discard_usec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DecoderBuffer::set_has_back_discard_usec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DecoderBuffer::clear_has_back_discard_usec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DecoderBuffer::clear_back_discard_usec() {
  back_discard_usec_ = GOOGLE_LONGLONG(0);
  clear_has_back_discard_usec();
}
inline ::google::protobuf::int64 DecoderBuffer::back_discard_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.back_discard_usec)
  return back_discard_usec_;
}
inline void DecoderBuffer::set_back_discard_usec(::google::protobuf::int64 value) {
  set_has_back_discard_usec();
  back_discard_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.back_discard_usec)
}

// optional int64 splice_timestamp_usec = 7 [deprecated = true];
inline bool DecoderBuffer::has_splice_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DecoderBuffer::set_has_splice_timestamp_usec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DecoderBuffer::clear_has_splice_timestamp_usec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DecoderBuffer::clear_splice_timestamp_usec() {
  splice_timestamp_usec_ = GOOGLE_LONGLONG(0);
  clear_has_splice_timestamp_usec();
}
inline ::google::protobuf::int64 DecoderBuffer::splice_timestamp_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.splice_timestamp_usec)
  return splice_timestamp_usec_;
}
inline void DecoderBuffer::set_splice_timestamp_usec(::google::protobuf::int64 value) {
  set_has_splice_timestamp_usec();
  splice_timestamp_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.splice_timestamp_usec)
}

// optional bytes side_data = 8;
inline bool DecoderBuffer::has_side_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoderBuffer::set_has_side_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecoderBuffer::clear_has_side_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecoderBuffer::clear_side_data() {
  side_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_side_data();
}
inline const ::std::string& DecoderBuffer::side_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.side_data)
  return side_data_.GetNoArena();
}
inline void DecoderBuffer::set_side_data(const ::std::string& value) {
  set_has_side_data();
  side_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.side_data)
}
#if LANG_CXX11
inline void DecoderBuffer::set_side_data(::std::string&& value) {
  set_has_side_data();
  side_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecoderBuffer.side_data)
}
#endif
inline void DecoderBuffer::set_side_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_side_data();
  side_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecoderBuffer.side_data)
}
inline void DecoderBuffer::set_side_data(const void* value, size_t size) {
  set_has_side_data();
  side_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecoderBuffer.side_data)
}
inline ::std::string* DecoderBuffer::mutable_side_data() {
  set_has_side_data();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecoderBuffer.side_data)
  return side_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecoderBuffer::release_side_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecoderBuffer.side_data)
  clear_has_side_data();
  return side_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecoderBuffer::set_allocated_side_data(::std::string* side_data) {
  if (side_data != NULL) {
    set_has_side_data();
  } else {
    clear_has_side_data();
  }
  side_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), side_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecoderBuffer.side_data)
}

// optional bool is_eos = 9;
inline bool DecoderBuffer::has_is_eos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DecoderBuffer::set_has_is_eos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DecoderBuffer::clear_has_is_eos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DecoderBuffer::clear_is_eos() {
  is_eos_ = false;
  clear_has_is_eos();
}
inline bool DecoderBuffer::is_eos() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecoderBuffer.is_eos)
  return is_eos_;
}
inline void DecoderBuffer::set_is_eos(bool value) {
  set_has_is_eos();
  is_eos_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecoderBuffer.is_eos)
}

// -------------------------------------------------------------------

// Size

// optional int32 width = 1;
inline bool Size::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Size::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Size::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Size::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Size::width() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Size.width)
  return width_;
}
inline void Size::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Size.width)
}

// optional int32 height = 2;
inline bool Size::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Size::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Size::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Size::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Size::height() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Size.height)
  return height_;
}
inline void Size::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Size.height)
}

// -------------------------------------------------------------------

// EncryptionScheme

// optional .media.remoting.pb.EncryptionScheme.CipherMode mode = 1;
inline bool EncryptionScheme::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptionScheme::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptionScheme::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptionScheme::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::media::remoting::pb::EncryptionScheme_CipherMode EncryptionScheme::mode() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.mode)
  return static_cast< ::media::remoting::pb::EncryptionScheme_CipherMode >(mode_);
}
inline void EncryptionScheme::set_mode(::media::remoting::pb::EncryptionScheme_CipherMode value) {
  assert(::media::remoting::pb::EncryptionScheme_CipherMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.mode)
}

// optional uint32 encrypt_blocks = 2;
inline bool EncryptionScheme::has_encrypt_blocks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptionScheme::set_has_encrypt_blocks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptionScheme::clear_has_encrypt_blocks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptionScheme::clear_encrypt_blocks() {
  encrypt_blocks_ = 0u;
  clear_has_encrypt_blocks();
}
inline ::google::protobuf::uint32 EncryptionScheme::encrypt_blocks() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.encrypt_blocks)
  return encrypt_blocks_;
}
inline void EncryptionScheme::set_encrypt_blocks(::google::protobuf::uint32 value) {
  set_has_encrypt_blocks();
  encrypt_blocks_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.encrypt_blocks)
}

// optional uint32 skip_blocks = 3;
inline bool EncryptionScheme::has_skip_blocks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptionScheme::set_has_skip_blocks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptionScheme::clear_has_skip_blocks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptionScheme::clear_skip_blocks() {
  skip_blocks_ = 0u;
  clear_has_skip_blocks();
}
inline ::google::protobuf::uint32 EncryptionScheme::skip_blocks() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.EncryptionScheme.skip_blocks)
  return skip_blocks_;
}
inline void EncryptionScheme::set_skip_blocks(::google::protobuf::uint32 value) {
  set_has_skip_blocks();
  skip_blocks_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.EncryptionScheme.skip_blocks)
}

// -------------------------------------------------------------------

// AudioDecoderConfig

// optional .media.remoting.pb.AudioDecoderConfig.Codec codec = 1;
inline bool AudioDecoderConfig::has_codec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioDecoderConfig::set_has_codec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioDecoderConfig::clear_has_codec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioDecoderConfig::clear_codec() {
  codec_ = 0;
  clear_has_codec();
}
inline ::media::remoting::pb::AudioDecoderConfig_Codec AudioDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.codec)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_Codec >(codec_);
}
inline void AudioDecoderConfig::set_codec(::media::remoting::pb::AudioDecoderConfig_Codec value) {
  assert(::media::remoting::pb::AudioDecoderConfig_Codec_IsValid(value));
  set_has_codec();
  codec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.codec)
}

// optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
inline bool AudioDecoderConfig::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioDecoderConfig::set_has_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioDecoderConfig::clear_has_encryption_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioDecoderConfig::clear_encryption_scheme() {
  if (encryption_scheme_ != NULL) encryption_scheme_->::media::remoting::pb::EncryptionScheme::Clear();
  clear_has_encryption_scheme();
}
inline const ::media::remoting::pb::EncryptionScheme& AudioDecoderConfig::encryption_scheme() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  return encryption_scheme_ != NULL ? *encryption_scheme_
                         : *::media::remoting::pb::EncryptionScheme::internal_default_instance();
}
inline ::media::remoting::pb::EncryptionScheme* AudioDecoderConfig::mutable_encryption_scheme() {
  set_has_encryption_scheme();
  if (encryption_scheme_ == NULL) {
    encryption_scheme_ = new ::media::remoting::pb::EncryptionScheme;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  return encryption_scheme_;
}
inline ::media::remoting::pb::EncryptionScheme* AudioDecoderConfig::release_encryption_scheme() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
  clear_has_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* temp = encryption_scheme_;
  encryption_scheme_ = NULL;
  return temp;
}
inline void AudioDecoderConfig::set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme) {
  delete encryption_scheme_;
  encryption_scheme_ = encryption_scheme;
  if (encryption_scheme) {
    set_has_encryption_scheme();
  } else {
    clear_has_encryption_scheme();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.AudioDecoderConfig.encryption_scheme)
}

// optional .media.remoting.pb.AudioDecoderConfig.SampleFormat sample_format = 3;
inline bool AudioDecoderConfig::has_sample_format() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioDecoderConfig::set_has_sample_format() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioDecoderConfig::clear_has_sample_format() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioDecoderConfig::clear_sample_format() {
  sample_format_ = 0;
  clear_has_sample_format();
}
inline ::media::remoting::pb::AudioDecoderConfig_SampleFormat AudioDecoderConfig::sample_format() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.sample_format)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_SampleFormat >(sample_format_);
}
inline void AudioDecoderConfig::set_sample_format(::media::remoting::pb::AudioDecoderConfig_SampleFormat value) {
  assert(::media::remoting::pb::AudioDecoderConfig_SampleFormat_IsValid(value));
  set_has_sample_format();
  sample_format_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.sample_format)
}

// optional .media.remoting.pb.AudioDecoderConfig.ChannelLayout channel_layout = 4;
inline bool AudioDecoderConfig::has_channel_layout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioDecoderConfig::set_has_channel_layout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioDecoderConfig::clear_has_channel_layout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioDecoderConfig::clear_channel_layout() {
  channel_layout_ = 0;
  clear_has_channel_layout();
}
inline ::media::remoting::pb::AudioDecoderConfig_ChannelLayout AudioDecoderConfig::channel_layout() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.channel_layout)
  return static_cast< ::media::remoting::pb::AudioDecoderConfig_ChannelLayout >(channel_layout_);
}
inline void AudioDecoderConfig::set_channel_layout(::media::remoting::pb::AudioDecoderConfig_ChannelLayout value) {
  assert(::media::remoting::pb::AudioDecoderConfig_ChannelLayout_IsValid(value));
  set_has_channel_layout();
  channel_layout_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.channel_layout)
}

// optional int32 samples_per_second = 5;
inline bool AudioDecoderConfig::has_samples_per_second() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioDecoderConfig::set_has_samples_per_second() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioDecoderConfig::clear_has_samples_per_second() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioDecoderConfig::clear_samples_per_second() {
  samples_per_second_ = 0;
  clear_has_samples_per_second();
}
inline ::google::protobuf::int32 AudioDecoderConfig::samples_per_second() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.samples_per_second)
  return samples_per_second_;
}
inline void AudioDecoderConfig::set_samples_per_second(::google::protobuf::int32 value) {
  set_has_samples_per_second();
  samples_per_second_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.samples_per_second)
}

// optional int64 seek_preroll_usec = 6;
inline bool AudioDecoderConfig::has_seek_preroll_usec() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioDecoderConfig::set_has_seek_preroll_usec() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioDecoderConfig::clear_has_seek_preroll_usec() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioDecoderConfig::clear_seek_preroll_usec() {
  seek_preroll_usec_ = GOOGLE_LONGLONG(0);
  clear_has_seek_preroll_usec();
}
inline ::google::protobuf::int64 AudioDecoderConfig::seek_preroll_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.seek_preroll_usec)
  return seek_preroll_usec_;
}
inline void AudioDecoderConfig::set_seek_preroll_usec(::google::protobuf::int64 value) {
  set_has_seek_preroll_usec();
  seek_preroll_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.seek_preroll_usec)
}

// optional int32 codec_delay = 7;
inline bool AudioDecoderConfig::has_codec_delay() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioDecoderConfig::set_has_codec_delay() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioDecoderConfig::clear_has_codec_delay() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioDecoderConfig::clear_codec_delay() {
  codec_delay_ = 0;
  clear_has_codec_delay();
}
inline ::google::protobuf::int32 AudioDecoderConfig::codec_delay() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.codec_delay)
  return codec_delay_;
}
inline void AudioDecoderConfig::set_codec_delay(::google::protobuf::int32 value) {
  set_has_codec_delay();
  codec_delay_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.codec_delay)
}

// optional bytes extra_data = 8;
inline bool AudioDecoderConfig::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioDecoderConfig::set_has_extra_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioDecoderConfig::clear_has_extra_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra_data();
}
inline const ::std::string& AudioDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.AudioDecoderConfig.extra_data)
  return extra_data_.GetNoArena();
}
inline void AudioDecoderConfig::set_extra_data(const ::std::string& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.AudioDecoderConfig.extra_data)
}
#if LANG_CXX11
inline void AudioDecoderConfig::set_extra_data(::std::string&& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.AudioDecoderConfig.extra_data)
}
#endif
inline void AudioDecoderConfig::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline void AudioDecoderConfig::set_extra_data(const void* value, size_t size) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.AudioDecoderConfig.extra_data)
}
inline ::std::string* AudioDecoderConfig::mutable_extra_data() {
  set_has_extra_data();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.AudioDecoderConfig.extra_data)
  return extra_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AudioDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.AudioDecoderConfig.extra_data)
  clear_has_extra_data();
  return extra_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AudioDecoderConfig::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data != NULL) {
    set_has_extra_data();
  } else {
    clear_has_extra_data();
  }
  extra_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.AudioDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// Rect

// optional int32 x = 1;
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Rect::x() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.x)
  return x_;
}
inline void Rect::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.x)
}

// optional int32 y = 2;
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Rect::y() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.y)
  return y_;
}
inline void Rect::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.y)
}

// optional int32 width = 3;
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Rect::width() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.width)
  return width_;
}
inline void Rect::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.width)
}

// optional int32 height = 4;
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Rect::height() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.Rect.height)
  return height_;
}
inline void Rect::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.Rect.height)
}

// -------------------------------------------------------------------

// VideoDecoderConfig

// optional .media.remoting.pb.VideoDecoderConfig.Codec codec = 1;
inline bool VideoDecoderConfig::has_codec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoDecoderConfig::set_has_codec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoDecoderConfig::clear_has_codec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoDecoderConfig::clear_codec() {
  codec_ = 0;
  clear_has_codec();
}
inline ::media::remoting::pb::VideoDecoderConfig_Codec VideoDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.codec)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Codec >(codec_);
}
inline void VideoDecoderConfig::set_codec(::media::remoting::pb::VideoDecoderConfig_Codec value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Codec_IsValid(value));
  set_has_codec();
  codec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.codec)
}

// optional .media.remoting.pb.EncryptionScheme encryption_scheme = 2;
inline bool VideoDecoderConfig::has_encryption_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoDecoderConfig::set_has_encryption_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoDecoderConfig::clear_has_encryption_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoDecoderConfig::clear_encryption_scheme() {
  if (encryption_scheme_ != NULL) encryption_scheme_->::media::remoting::pb::EncryptionScheme::Clear();
  clear_has_encryption_scheme();
}
inline const ::media::remoting::pb::EncryptionScheme& VideoDecoderConfig::encryption_scheme() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  return encryption_scheme_ != NULL ? *encryption_scheme_
                         : *::media::remoting::pb::EncryptionScheme::internal_default_instance();
}
inline ::media::remoting::pb::EncryptionScheme* VideoDecoderConfig::mutable_encryption_scheme() {
  set_has_encryption_scheme();
  if (encryption_scheme_ == NULL) {
    encryption_scheme_ = new ::media::remoting::pb::EncryptionScheme;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  return encryption_scheme_;
}
inline ::media::remoting::pb::EncryptionScheme* VideoDecoderConfig::release_encryption_scheme() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
  clear_has_encryption_scheme();
  ::media::remoting::pb::EncryptionScheme* temp = encryption_scheme_;
  encryption_scheme_ = NULL;
  return temp;
}
inline void VideoDecoderConfig::set_allocated_encryption_scheme(::media::remoting::pb::EncryptionScheme* encryption_scheme) {
  delete encryption_scheme_;
  encryption_scheme_ = encryption_scheme;
  if (encryption_scheme) {
    set_has_encryption_scheme();
  } else {
    clear_has_encryption_scheme();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.encryption_scheme)
}

// optional .media.remoting.pb.VideoDecoderConfig.Profile profile = 3;
inline bool VideoDecoderConfig::has_profile() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VideoDecoderConfig::set_has_profile() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VideoDecoderConfig::clear_has_profile() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VideoDecoderConfig::clear_profile() {
  profile_ = -1;
  clear_has_profile();
}
inline ::media::remoting::pb::VideoDecoderConfig_Profile VideoDecoderConfig::profile() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.profile)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Profile >(profile_);
}
inline void VideoDecoderConfig::set_profile(::media::remoting::pb::VideoDecoderConfig_Profile value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Profile_IsValid(value));
  set_has_profile();
  profile_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.profile)
}

// optional .media.remoting.pb.VideoDecoderConfig.Format format = 4;
inline bool VideoDecoderConfig::has_format() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoDecoderConfig::set_has_format() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VideoDecoderConfig::clear_has_format() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VideoDecoderConfig::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::media::remoting::pb::VideoDecoderConfig_Format VideoDecoderConfig::format() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.format)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_Format >(format_);
}
inline void VideoDecoderConfig::set_format(::media::remoting::pb::VideoDecoderConfig_Format value) {
  assert(::media::remoting::pb::VideoDecoderConfig_Format_IsValid(value));
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.format)
}

// optional .media.remoting.pb.VideoDecoderConfig.ColorSpace color_space = 5;
inline bool VideoDecoderConfig::has_color_space() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VideoDecoderConfig::set_has_color_space() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VideoDecoderConfig::clear_has_color_space() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VideoDecoderConfig::clear_color_space() {
  color_space_ = 0;
  clear_has_color_space();
}
inline ::media::remoting::pb::VideoDecoderConfig_ColorSpace VideoDecoderConfig::color_space() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.color_space)
  return static_cast< ::media::remoting::pb::VideoDecoderConfig_ColorSpace >(color_space_);
}
inline void VideoDecoderConfig::set_color_space(::media::remoting::pb::VideoDecoderConfig_ColorSpace value) {
  assert(::media::remoting::pb::VideoDecoderConfig_ColorSpace_IsValid(value));
  set_has_color_space();
  color_space_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.color_space)
}

// optional .media.remoting.pb.Size coded_size = 6;
inline bool VideoDecoderConfig::has_coded_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoDecoderConfig::set_has_coded_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoDecoderConfig::clear_has_coded_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoDecoderConfig::clear_coded_size() {
  if (coded_size_ != NULL) coded_size_->::media::remoting::pb::Size::Clear();
  clear_has_coded_size();
}
inline const ::media::remoting::pb::Size& VideoDecoderConfig::coded_size() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.coded_size)
  return coded_size_ != NULL ? *coded_size_
                         : *::media::remoting::pb::Size::internal_default_instance();
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::mutable_coded_size() {
  set_has_coded_size();
  if (coded_size_ == NULL) {
    coded_size_ = new ::media::remoting::pb::Size;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.coded_size)
  return coded_size_;
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::release_coded_size() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.coded_size)
  clear_has_coded_size();
  ::media::remoting::pb::Size* temp = coded_size_;
  coded_size_ = NULL;
  return temp;
}
inline void VideoDecoderConfig::set_allocated_coded_size(::media::remoting::pb::Size* coded_size) {
  delete coded_size_;
  coded_size_ = coded_size;
  if (coded_size) {
    set_has_coded_size();
  } else {
    clear_has_coded_size();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.coded_size)
}

// optional .media.remoting.pb.Rect visible_rect = 7;
inline bool VideoDecoderConfig::has_visible_rect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoDecoderConfig::set_has_visible_rect() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoDecoderConfig::clear_has_visible_rect() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoDecoderConfig::clear_visible_rect() {
  if (visible_rect_ != NULL) visible_rect_->::media::remoting::pb::Rect::Clear();
  clear_has_visible_rect();
}
inline const ::media::remoting::pb::Rect& VideoDecoderConfig::visible_rect() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.visible_rect)
  return visible_rect_ != NULL ? *visible_rect_
                         : *::media::remoting::pb::Rect::internal_default_instance();
}
inline ::media::remoting::pb::Rect* VideoDecoderConfig::mutable_visible_rect() {
  set_has_visible_rect();
  if (visible_rect_ == NULL) {
    visible_rect_ = new ::media::remoting::pb::Rect;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.visible_rect)
  return visible_rect_;
}
inline ::media::remoting::pb::Rect* VideoDecoderConfig::release_visible_rect() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.visible_rect)
  clear_has_visible_rect();
  ::media::remoting::pb::Rect* temp = visible_rect_;
  visible_rect_ = NULL;
  return temp;
}
inline void VideoDecoderConfig::set_allocated_visible_rect(::media::remoting::pb::Rect* visible_rect) {
  delete visible_rect_;
  visible_rect_ = visible_rect;
  if (visible_rect) {
    set_has_visible_rect();
  } else {
    clear_has_visible_rect();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.visible_rect)
}

// optional .media.remoting.pb.Size natural_size = 8;
inline bool VideoDecoderConfig::has_natural_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoDecoderConfig::set_has_natural_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoDecoderConfig::clear_has_natural_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoDecoderConfig::clear_natural_size() {
  if (natural_size_ != NULL) natural_size_->::media::remoting::pb::Size::Clear();
  clear_has_natural_size();
}
inline const ::media::remoting::pb::Size& VideoDecoderConfig::natural_size() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.natural_size)
  return natural_size_ != NULL ? *natural_size_
                         : *::media::remoting::pb::Size::internal_default_instance();
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::mutable_natural_size() {
  set_has_natural_size();
  if (natural_size_ == NULL) {
    natural_size_ = new ::media::remoting::pb::Size;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.natural_size)
  return natural_size_;
}
inline ::media::remoting::pb::Size* VideoDecoderConfig::release_natural_size() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.natural_size)
  clear_has_natural_size();
  ::media::remoting::pb::Size* temp = natural_size_;
  natural_size_ = NULL;
  return temp;
}
inline void VideoDecoderConfig::set_allocated_natural_size(::media::remoting::pb::Size* natural_size) {
  delete natural_size_;
  natural_size_ = natural_size;
  if (natural_size) {
    set_has_natural_size();
  } else {
    clear_has_natural_size();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.natural_size)
}

// optional bytes extra_data = 9;
inline bool VideoDecoderConfig::has_extra_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoDecoderConfig::set_has_extra_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoDecoderConfig::clear_has_extra_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extra_data();
}
inline const ::std::string& VideoDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.VideoDecoderConfig.extra_data)
  return extra_data_.GetNoArena();
}
inline void VideoDecoderConfig::set_extra_data(const ::std::string& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.VideoDecoderConfig.extra_data)
}
#if LANG_CXX11
inline void VideoDecoderConfig::set_extra_data(::std::string&& value) {
  set_has_extra_data();
  extra_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.VideoDecoderConfig.extra_data)
}
#endif
inline void VideoDecoderConfig::set_extra_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline void VideoDecoderConfig::set_extra_data(const void* value, size_t size) {
  set_has_extra_data();
  extra_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.VideoDecoderConfig.extra_data)
}
inline ::std::string* VideoDecoderConfig::mutable_extra_data() {
  set_has_extra_data();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.VideoDecoderConfig.extra_data)
  return extra_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VideoDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.VideoDecoderConfig.extra_data)
  clear_has_extra_data();
  return extra_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VideoDecoderConfig::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data != NULL) {
    set_has_extra_data();
  } else {
    clear_has_extra_data();
  }
  extra_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extra_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.VideoDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// DecryptConfig_SubSample

// optional uint32 clear_bytes = 1;
inline bool DecryptConfig_SubSample::has_clear_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptConfig_SubSample::set_has_clear_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecryptConfig_SubSample::clear_has_clear_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecryptConfig_SubSample::clear_clear_bytes() {
  clear_bytes_ = 0u;
  clear_has_clear_bytes();
}
inline ::google::protobuf::uint32 DecryptConfig_SubSample::clear_bytes() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.SubSample.clear_bytes)
  return clear_bytes_;
}
inline void DecryptConfig_SubSample::set_clear_bytes(::google::protobuf::uint32 value) {
  set_has_clear_bytes();
  clear_bytes_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.SubSample.clear_bytes)
}

// optional uint32 cypher_bytes = 2;
inline bool DecryptConfig_SubSample::has_cypher_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptConfig_SubSample::set_has_cypher_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecryptConfig_SubSample::clear_has_cypher_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecryptConfig_SubSample::clear_cypher_bytes() {
  cypher_bytes_ = 0u;
  clear_has_cypher_bytes();
}
inline ::google::protobuf::uint32 DecryptConfig_SubSample::cypher_bytes() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.SubSample.cypher_bytes)
  return cypher_bytes_;
}
inline void DecryptConfig_SubSample::set_cypher_bytes(::google::protobuf::uint32 value) {
  set_has_cypher_bytes();
  cypher_bytes_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.SubSample.cypher_bytes)
}

// -------------------------------------------------------------------

// DecryptConfig

// optional bytes key_id = 1;
inline bool DecryptConfig::has_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecryptConfig::set_has_key_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecryptConfig::clear_has_key_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecryptConfig::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_id();
}
inline const ::std::string& DecryptConfig::key_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.key_id)
  return key_id_.GetNoArena();
}
inline void DecryptConfig::set_key_id(const ::std::string& value) {
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.key_id)
}
#if LANG_CXX11
inline void DecryptConfig::set_key_id(::std::string&& value) {
  set_has_key_id();
  key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecryptConfig.key_id)
}
#endif
inline void DecryptConfig::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecryptConfig.key_id)
}
inline void DecryptConfig::set_key_id(const void* value, size_t size) {
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecryptConfig.key_id)
}
inline ::std::string* DecryptConfig::mutable_key_id() {
  set_has_key_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.key_id)
  return key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptConfig::release_key_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecryptConfig.key_id)
  clear_has_key_id();
  return key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptConfig::set_allocated_key_id(::std::string* key_id) {
  if (key_id != NULL) {
    set_has_key_id();
  } else {
    clear_has_key_id();
  }
  key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecryptConfig.key_id)
}

// optional bytes iv = 2;
inline bool DecryptConfig::has_iv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptConfig::set_has_iv() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecryptConfig::clear_has_iv() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecryptConfig::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_iv();
}
inline const ::std::string& DecryptConfig::iv() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.iv)
  return iv_.GetNoArena();
}
inline void DecryptConfig::set_iv(const ::std::string& value) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.iv)
}
#if LANG_CXX11
inline void DecryptConfig::set_iv(::std::string&& value) {
  set_has_iv();
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.DecryptConfig.iv)
}
#endif
inline void DecryptConfig::set_iv(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.DecryptConfig.iv)
}
inline void DecryptConfig::set_iv(const void* value, size_t size) {
  set_has_iv();
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.DecryptConfig.iv)
}
inline ::std::string* DecryptConfig::mutable_iv() {
  set_has_iv();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecryptConfig::release_iv() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DecryptConfig.iv)
  clear_has_iv();
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecryptConfig::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    set_has_iv();
  } else {
    clear_has_iv();
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DecryptConfig.iv)
}

// repeated .media.remoting.pb.DecryptConfig.SubSample sub_samples = 3;
inline int DecryptConfig::sub_samples_size() const {
  return sub_samples_.size();
}
inline void DecryptConfig::clear_sub_samples() {
  sub_samples_.Clear();
}
inline const ::media::remoting::pb::DecryptConfig_SubSample& DecryptConfig::sub_samples(int index) const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Get(index);
}
inline ::media::remoting::pb::DecryptConfig_SubSample* DecryptConfig::mutable_sub_samples(int index) {
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Mutable(index);
}
inline ::media::remoting::pb::DecryptConfig_SubSample* DecryptConfig::add_sub_samples() {
  // @@protoc_insertion_point(field_add:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >*
DecryptConfig::mutable_sub_samples() {
  // @@protoc_insertion_point(field_mutable_list:media.remoting.pb.DecryptConfig.sub_samples)
  return &sub_samples_;
}
inline const ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::DecryptConfig_SubSample >&
DecryptConfig::sub_samples() const {
  // @@protoc_insertion_point(field_list:media.remoting.pb.DecryptConfig.sub_samples)
  return sub_samples_;
}

// optional .media.remoting.pb.EncryptionMode mode = 4;
inline bool DecryptConfig::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecryptConfig::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecryptConfig::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecryptConfig::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::media::remoting::pb::EncryptionMode DecryptConfig::mode() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.mode)
  return static_cast< ::media::remoting::pb::EncryptionMode >(mode_);
}
inline void DecryptConfig::set_mode(::media::remoting::pb::EncryptionMode value) {
  assert(::media::remoting::pb::EncryptionMode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.mode)
}

// optional uint32 crypt_byte_block = 5;
inline bool DecryptConfig::has_crypt_byte_block() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DecryptConfig::set_has_crypt_byte_block() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DecryptConfig::clear_has_crypt_byte_block() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DecryptConfig::clear_crypt_byte_block() {
  crypt_byte_block_ = 0u;
  clear_has_crypt_byte_block();
}
inline ::google::protobuf::uint32 DecryptConfig::crypt_byte_block() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.crypt_byte_block)
  return crypt_byte_block_;
}
inline void DecryptConfig::set_crypt_byte_block(::google::protobuf::uint32 value) {
  set_has_crypt_byte_block();
  crypt_byte_block_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.crypt_byte_block)
}

// optional uint32 skip_byte_block = 6;
inline bool DecryptConfig::has_skip_byte_block() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecryptConfig::set_has_skip_byte_block() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DecryptConfig::clear_has_skip_byte_block() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DecryptConfig::clear_skip_byte_block() {
  skip_byte_block_ = 0u;
  clear_has_skip_byte_block();
}
inline ::google::protobuf::uint32 DecryptConfig::skip_byte_block() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DecryptConfig.skip_byte_block)
  return skip_byte_block_;
}
inline void DecryptConfig::set_skip_byte_block(::google::protobuf::uint32 value) {
  set_has_skip_byte_block();
  skip_byte_block_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DecryptConfig.skip_byte_block)
}

// -------------------------------------------------------------------

// PipelineStatistics

// optional uint64 audio_bytes_decoded = 1;
inline bool PipelineStatistics::has_audio_bytes_decoded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PipelineStatistics::set_has_audio_bytes_decoded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PipelineStatistics::clear_has_audio_bytes_decoded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PipelineStatistics::clear_audio_bytes_decoded() {
  audio_bytes_decoded_ = GOOGLE_ULONGLONG(0);
  clear_has_audio_bytes_decoded();
}
inline ::google::protobuf::uint64 PipelineStatistics::audio_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_bytes_decoded)
  return audio_bytes_decoded_;
}
inline void PipelineStatistics::set_audio_bytes_decoded(::google::protobuf::uint64 value) {
  set_has_audio_bytes_decoded();
  audio_bytes_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.audio_bytes_decoded)
}

// optional uint64 video_bytes_decoded = 2;
inline bool PipelineStatistics::has_video_bytes_decoded() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PipelineStatistics::set_has_video_bytes_decoded() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PipelineStatistics::clear_has_video_bytes_decoded() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PipelineStatistics::clear_video_bytes_decoded() {
  video_bytes_decoded_ = GOOGLE_ULONGLONG(0);
  clear_has_video_bytes_decoded();
}
inline ::google::protobuf::uint64 PipelineStatistics::video_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_bytes_decoded)
  return video_bytes_decoded_;
}
inline void PipelineStatistics::set_video_bytes_decoded(::google::protobuf::uint64 value) {
  set_has_video_bytes_decoded();
  video_bytes_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_bytes_decoded)
}

// optional uint32 video_frames_decoded = 3;
inline bool PipelineStatistics::has_video_frames_decoded() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PipelineStatistics::set_has_video_frames_decoded() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PipelineStatistics::clear_has_video_frames_decoded() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PipelineStatistics::clear_video_frames_decoded() {
  video_frames_decoded_ = 0u;
  clear_has_video_frames_decoded();
}
inline ::google::protobuf::uint32 PipelineStatistics::video_frames_decoded() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frames_decoded)
  return video_frames_decoded_;
}
inline void PipelineStatistics::set_video_frames_decoded(::google::protobuf::uint32 value) {
  set_has_video_frames_decoded();
  video_frames_decoded_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frames_decoded)
}

// optional uint32 video_frames_dropped = 4;
inline bool PipelineStatistics::has_video_frames_dropped() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PipelineStatistics::set_has_video_frames_dropped() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PipelineStatistics::clear_has_video_frames_dropped() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PipelineStatistics::clear_video_frames_dropped() {
  video_frames_dropped_ = 0u;
  clear_has_video_frames_dropped();
}
inline ::google::protobuf::uint32 PipelineStatistics::video_frames_dropped() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frames_dropped)
  return video_frames_dropped_;
}
inline void PipelineStatistics::set_video_frames_dropped(::google::protobuf::uint32 value) {
  set_has_video_frames_dropped();
  video_frames_dropped_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frames_dropped)
}

// optional int64 audio_memory_usage = 5;
inline bool PipelineStatistics::has_audio_memory_usage() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PipelineStatistics::set_has_audio_memory_usage() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PipelineStatistics::clear_has_audio_memory_usage() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PipelineStatistics::clear_audio_memory_usage() {
  audio_memory_usage_ = GOOGLE_LONGLONG(0);
  clear_has_audio_memory_usage();
}
inline ::google::protobuf::int64 PipelineStatistics::audio_memory_usage() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_memory_usage)
  return audio_memory_usage_;
}
inline void PipelineStatistics::set_audio_memory_usage(::google::protobuf::int64 value) {
  set_has_audio_memory_usage();
  audio_memory_usage_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.audio_memory_usage)
}

// optional int64 video_memory_usage = 6;
inline bool PipelineStatistics::has_video_memory_usage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PipelineStatistics::set_has_video_memory_usage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PipelineStatistics::clear_has_video_memory_usage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PipelineStatistics::clear_video_memory_usage() {
  video_memory_usage_ = GOOGLE_LONGLONG(0);
  clear_has_video_memory_usage();
}
inline ::google::protobuf::int64 PipelineStatistics::video_memory_usage() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_memory_usage)
  return video_memory_usage_;
}
inline void PipelineStatistics::set_video_memory_usage(::google::protobuf::int64 value) {
  set_has_video_memory_usage();
  video_memory_usage_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_memory_usage)
}

// optional int64 video_frame_duration_average_usec = 7;
inline bool PipelineStatistics::has_video_frame_duration_average_usec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PipelineStatistics::set_has_video_frame_duration_average_usec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PipelineStatistics::clear_has_video_frame_duration_average_usec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PipelineStatistics::clear_video_frame_duration_average_usec() {
  video_frame_duration_average_usec_ = GOOGLE_LONGLONG(0);
  clear_has_video_frame_duration_average_usec();
}
inline ::google::protobuf::int64 PipelineStatistics::video_frame_duration_average_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_frame_duration_average_usec)
  return video_frame_duration_average_usec_;
}
inline void PipelineStatistics::set_video_frame_duration_average_usec(::google::protobuf::int64 value) {
  set_has_video_frame_duration_average_usec();
  video_frame_duration_average_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_frame_duration_average_usec)
}

// optional string audio_decoder_name = 8;
inline bool PipelineStatistics::has_audio_decoder_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PipelineStatistics::set_has_audio_decoder_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PipelineStatistics::clear_has_audio_decoder_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PipelineStatistics::clear_audio_decoder_name() {
  audio_decoder_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_audio_decoder_name();
}
inline const ::std::string& PipelineStatistics::audio_decoder_name() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.audio_decoder_name)
  return audio_decoder_name_.GetNoArena();
}
inline void PipelineStatistics::set_audio_decoder_name(const ::std::string& value) {
  set_has_audio_decoder_name();
  audio_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.audio_decoder_name)
}
#if LANG_CXX11
inline void PipelineStatistics::set_audio_decoder_name(::std::string&& value) {
  set_has_audio_decoder_name();
  audio_decoder_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.PipelineStatistics.audio_decoder_name)
}
#endif
inline void PipelineStatistics::set_audio_decoder_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_audio_decoder_name();
  audio_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.PipelineStatistics.audio_decoder_name)
}
inline void PipelineStatistics::set_audio_decoder_name(const char* value, size_t size) {
  set_has_audio_decoder_name();
  audio_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.PipelineStatistics.audio_decoder_name)
}
inline ::std::string* PipelineStatistics::mutable_audio_decoder_name() {
  set_has_audio_decoder_name();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.PipelineStatistics.audio_decoder_name)
  return audio_decoder_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PipelineStatistics::release_audio_decoder_name() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.PipelineStatistics.audio_decoder_name)
  clear_has_audio_decoder_name();
  return audio_decoder_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PipelineStatistics::set_allocated_audio_decoder_name(::std::string* audio_decoder_name) {
  if (audio_decoder_name != NULL) {
    set_has_audio_decoder_name();
  } else {
    clear_has_audio_decoder_name();
  }
  audio_decoder_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), audio_decoder_name);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.PipelineStatistics.audio_decoder_name)
}

// optional string video_decoder_name = 9;
inline bool PipelineStatistics::has_video_decoder_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PipelineStatistics::set_has_video_decoder_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PipelineStatistics::clear_has_video_decoder_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PipelineStatistics::clear_video_decoder_name() {
  video_decoder_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_video_decoder_name();
}
inline const ::std::string& PipelineStatistics::video_decoder_name() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.PipelineStatistics.video_decoder_name)
  return video_decoder_name_.GetNoArena();
}
inline void PipelineStatistics::set_video_decoder_name(const ::std::string& value) {
  set_has_video_decoder_name();
  video_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.PipelineStatistics.video_decoder_name)
}
#if LANG_CXX11
inline void PipelineStatistics::set_video_decoder_name(::std::string&& value) {
  set_has_video_decoder_name();
  video_decoder_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.PipelineStatistics.video_decoder_name)
}
#endif
inline void PipelineStatistics::set_video_decoder_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_video_decoder_name();
  video_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.PipelineStatistics.video_decoder_name)
}
inline void PipelineStatistics::set_video_decoder_name(const char* value, size_t size) {
  set_has_video_decoder_name();
  video_decoder_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.PipelineStatistics.video_decoder_name)
}
inline ::std::string* PipelineStatistics::mutable_video_decoder_name() {
  set_has_video_decoder_name();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.PipelineStatistics.video_decoder_name)
  return video_decoder_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PipelineStatistics::release_video_decoder_name() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.PipelineStatistics.video_decoder_name)
  clear_has_video_decoder_name();
  return video_decoder_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PipelineStatistics::set_allocated_video_decoder_name(::std::string* video_decoder_name) {
  if (video_decoder_name != NULL) {
    set_has_video_decoder_name();
  } else {
    clear_has_video_decoder_name();
  }
  video_decoder_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), video_decoder_name);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.PipelineStatistics.video_decoder_name)
}

// -------------------------------------------------------------------

// CdmKeyInformation

// optional bytes key_id = 1;
inline bool CdmKeyInformation::has_key_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmKeyInformation::set_has_key_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmKeyInformation::clear_has_key_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmKeyInformation::clear_key_id() {
  key_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_id();
}
inline const ::std::string& CdmKeyInformation::key_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.key_id)
  return key_id_.GetNoArena();
}
inline void CdmKeyInformation::set_key_id(const ::std::string& value) {
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.key_id)
}
#if LANG_CXX11
inline void CdmKeyInformation::set_key_id(::std::string&& value) {
  set_has_key_id();
  key_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmKeyInformation.key_id)
}
#endif
inline void CdmKeyInformation::set_key_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmKeyInformation.key_id)
}
inline void CdmKeyInformation::set_key_id(const void* value, size_t size) {
  set_has_key_id();
  key_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmKeyInformation.key_id)
}
inline ::std::string* CdmKeyInformation::mutable_key_id() {
  set_has_key_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmKeyInformation.key_id)
  return key_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmKeyInformation::release_key_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmKeyInformation.key_id)
  clear_has_key_id();
  return key_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmKeyInformation::set_allocated_key_id(::std::string* key_id) {
  if (key_id != NULL) {
    set_has_key_id();
  } else {
    clear_has_key_id();
  }
  key_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmKeyInformation.key_id)
}

// optional .media.remoting.pb.CdmKeyInformation.KeyStatus status = 2;
inline bool CdmKeyInformation::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmKeyInformation::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmKeyInformation::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmKeyInformation::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::media::remoting::pb::CdmKeyInformation_KeyStatus CdmKeyInformation::status() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.status)
  return static_cast< ::media::remoting::pb::CdmKeyInformation_KeyStatus >(status_);
}
inline void CdmKeyInformation::set_status(::media::remoting::pb::CdmKeyInformation_KeyStatus value) {
  assert(::media::remoting::pb::CdmKeyInformation_KeyStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.status)
}

// optional uint32 system_code = 3;
inline bool CdmKeyInformation::has_system_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmKeyInformation::set_has_system_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmKeyInformation::clear_has_system_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmKeyInformation::clear_system_code() {
  system_code_ = 0u;
  clear_has_system_code();
}
inline ::google::protobuf::uint32 CdmKeyInformation::system_code() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmKeyInformation.system_code)
  return system_code_;
}
inline void CdmKeyInformation::set_system_code(::google::protobuf::uint32 value) {
  set_has_system_code();
  system_code_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmKeyInformation.system_code)
}

// -------------------------------------------------------------------

// RendererInitialize

// optional int32 client_handle = 1;
inline bool RendererInitialize::has_client_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererInitialize::set_has_client_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererInitialize::clear_has_client_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererInitialize::clear_client_handle() {
  client_handle_ = 0;
  clear_has_client_handle();
}
inline ::google::protobuf::int32 RendererInitialize::client_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.client_handle)
  return client_handle_;
}
inline void RendererInitialize::set_client_handle(::google::protobuf::int32 value) {
  set_has_client_handle();
  client_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.client_handle)
}

// optional int32 audio_demuxer_handle = 2;
inline bool RendererInitialize::has_audio_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererInitialize::set_has_audio_demuxer_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RendererInitialize::clear_has_audio_demuxer_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RendererInitialize::clear_audio_demuxer_handle() {
  audio_demuxer_handle_ = 0;
  clear_has_audio_demuxer_handle();
}
inline ::google::protobuf::int32 RendererInitialize::audio_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.audio_demuxer_handle)
  return audio_demuxer_handle_;
}
inline void RendererInitialize::set_audio_demuxer_handle(::google::protobuf::int32 value) {
  set_has_audio_demuxer_handle();
  audio_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.audio_demuxer_handle)
}

// optional int32 video_demuxer_handle = 3;
inline bool RendererInitialize::has_video_demuxer_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RendererInitialize::set_has_video_demuxer_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RendererInitialize::clear_has_video_demuxer_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RendererInitialize::clear_video_demuxer_handle() {
  video_demuxer_handle_ = 0;
  clear_has_video_demuxer_handle();
}
inline ::google::protobuf::int32 RendererInitialize::video_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.video_demuxer_handle)
  return video_demuxer_handle_;
}
inline void RendererInitialize::set_video_demuxer_handle(::google::protobuf::int32 value) {
  set_has_video_demuxer_handle();
  video_demuxer_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.video_demuxer_handle)
}

// optional int32 callback_handle = 4;
inline bool RendererInitialize::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RendererInitialize::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RendererInitialize::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RendererInitialize::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 RendererInitialize::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererInitialize.callback_handle)
  return callback_handle_;
}
inline void RendererInitialize::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererInitialize.callback_handle)
}

// -------------------------------------------------------------------

// RendererFlushUntil

// optional uint32 audio_count = 1;
inline bool RendererFlushUntil::has_audio_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererFlushUntil::set_has_audio_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererFlushUntil::clear_has_audio_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererFlushUntil::clear_audio_count() {
  audio_count_ = 0u;
  clear_has_audio_count();
}
inline ::google::protobuf::uint32 RendererFlushUntil::audio_count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.audio_count)
  return audio_count_;
}
inline void RendererFlushUntil::set_audio_count(::google::protobuf::uint32 value) {
  set_has_audio_count();
  audio_count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.audio_count)
}

// optional uint32 video_count = 2;
inline bool RendererFlushUntil::has_video_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererFlushUntil::set_has_video_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RendererFlushUntil::clear_has_video_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RendererFlushUntil::clear_video_count() {
  video_count_ = 0u;
  clear_has_video_count();
}
inline ::google::protobuf::uint32 RendererFlushUntil::video_count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.video_count)
  return video_count_;
}
inline void RendererFlushUntil::set_video_count(::google::protobuf::uint32 value) {
  set_has_video_count();
  video_count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.video_count)
}

// optional int32 callback_handle = 3;
inline bool RendererFlushUntil::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RendererFlushUntil::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RendererFlushUntil::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RendererFlushUntil::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 RendererFlushUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererFlushUntil.callback_handle)
  return callback_handle_;
}
inline void RendererFlushUntil::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererFlushUntil.callback_handle)
}

// -------------------------------------------------------------------

// RendererSetCdm

// optional int32 cdm_id = 1;
inline bool RendererSetCdm::has_cdm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererSetCdm::set_has_cdm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererSetCdm::clear_has_cdm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererSetCdm::clear_cdm_id() {
  cdm_id_ = 0;
  clear_has_cdm_id();
}
inline ::google::protobuf::int32 RendererSetCdm::cdm_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererSetCdm.cdm_id)
  return cdm_id_;
}
inline void RendererSetCdm::set_cdm_id(::google::protobuf::int32 value) {
  set_has_cdm_id();
  cdm_id_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererSetCdm.cdm_id)
}

// optional int32 callback_handle = 2;
inline bool RendererSetCdm::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererSetCdm::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RendererSetCdm::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RendererSetCdm::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 RendererSetCdm::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererSetCdm.callback_handle)
  return callback_handle_;
}
inline void RendererSetCdm::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererSetCdm.callback_handle)
}

// -------------------------------------------------------------------

// RendererClientOnTimeUpdate

// optional int64 time_usec = 1;
inline bool RendererClientOnTimeUpdate::has_time_usec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnTimeUpdate::set_has_time_usec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererClientOnTimeUpdate::clear_has_time_usec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererClientOnTimeUpdate::clear_time_usec() {
  time_usec_ = GOOGLE_LONGLONG(0);
  clear_has_time_usec();
}
inline ::google::protobuf::int64 RendererClientOnTimeUpdate::time_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnTimeUpdate.time_usec)
  return time_usec_;
}
inline void RendererClientOnTimeUpdate::set_time_usec(::google::protobuf::int64 value) {
  set_has_time_usec();
  time_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnTimeUpdate.time_usec)
}

// optional int64 max_time_usec = 2;
inline bool RendererClientOnTimeUpdate::has_max_time_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RendererClientOnTimeUpdate::set_has_max_time_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RendererClientOnTimeUpdate::clear_has_max_time_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RendererClientOnTimeUpdate::clear_max_time_usec() {
  max_time_usec_ = GOOGLE_LONGLONG(0);
  clear_has_max_time_usec();
}
inline ::google::protobuf::int64 RendererClientOnTimeUpdate::max_time_usec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnTimeUpdate.max_time_usec)
  return max_time_usec_;
}
inline void RendererClientOnTimeUpdate::set_max_time_usec(::google::protobuf::int64 value) {
  set_has_max_time_usec();
  max_time_usec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnTimeUpdate.max_time_usec)
}

// -------------------------------------------------------------------

// RendererClientOnBufferingStateChange

// optional .media.remoting.pb.RendererClientOnBufferingStateChange.State state = 1;
inline bool RendererClientOnBufferingStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnBufferingStateChange::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererClientOnBufferingStateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererClientOnBufferingStateChange::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::state() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnBufferingStateChange.state)
  return static_cast< ::media::remoting::pb::RendererClientOnBufferingStateChange_State >(state_);
}
inline void RendererClientOnBufferingStateChange::set_state(::media::remoting::pb::RendererClientOnBufferingStateChange_State value) {
  assert(::media::remoting::pb::RendererClientOnBufferingStateChange_State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RendererClientOnBufferingStateChange.state)
}

// -------------------------------------------------------------------

// RendererClientOnAudioConfigChange

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 1;
inline bool RendererClientOnAudioConfigChange::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnAudioConfigChange::set_has_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererClientOnAudioConfigChange::clear_has_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererClientOnAudioConfigChange::clear_audio_decoder_config() {
  if (audio_decoder_config_ != NULL) audio_decoder_config_->::media::remoting::pb::AudioDecoderConfig::Clear();
  clear_has_audio_decoder_config();
}
inline const ::media::remoting::pb::AudioDecoderConfig& RendererClientOnAudioConfigChange::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  return audio_decoder_config_ != NULL ? *audio_decoder_config_
                         : *::media::remoting::pb::AudioDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::AudioDecoderConfig* RendererClientOnAudioConfigChange::mutable_audio_decoder_config() {
  set_has_audio_decoder_config();
  if (audio_decoder_config_ == NULL) {
    audio_decoder_config_ = new ::media::remoting::pb::AudioDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  return audio_decoder_config_;
}
inline ::media::remoting::pb::AudioDecoderConfig* RendererClientOnAudioConfigChange::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
  clear_has_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = NULL;
  return temp;
}
inline void RendererClientOnAudioConfigChange::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  delete audio_decoder_config_;
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    set_has_audio_decoder_config();
  } else {
    clear_has_audio_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RendererClientOnAudioConfigChange.audio_decoder_config)
}

// -------------------------------------------------------------------

// RendererClientOnVideoConfigChange

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 1;
inline bool RendererClientOnVideoConfigChange::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RendererClientOnVideoConfigChange::set_has_video_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RendererClientOnVideoConfigChange::clear_has_video_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RendererClientOnVideoConfigChange::clear_video_decoder_config() {
  if (video_decoder_config_ != NULL) video_decoder_config_->::media::remoting::pb::VideoDecoderConfig::Clear();
  clear_has_video_decoder_config();
}
inline const ::media::remoting::pb::VideoDecoderConfig& RendererClientOnVideoConfigChange::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  return video_decoder_config_ != NULL ? *video_decoder_config_
                         : *::media::remoting::pb::VideoDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::VideoDecoderConfig* RendererClientOnVideoConfigChange::mutable_video_decoder_config() {
  set_has_video_decoder_config();
  if (video_decoder_config_ == NULL) {
    video_decoder_config_ = new ::media::remoting::pb::VideoDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  return video_decoder_config_;
}
inline ::media::remoting::pb::VideoDecoderConfig* RendererClientOnVideoConfigChange::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
  clear_has_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = NULL;
  return temp;
}
inline void RendererClientOnVideoConfigChange::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  delete video_decoder_config_;
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    set_has_video_decoder_config();
  } else {
    clear_has_video_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RendererClientOnVideoConfigChange.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntil

// optional int32 callback_handle = 1;
inline bool DemuxerStreamReadUntil::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamReadUntil::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DemuxerStreamReadUntil::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DemuxerStreamReadUntil::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 DemuxerStreamReadUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntil.callback_handle)
  return callback_handle_;
}
inline void DemuxerStreamReadUntil::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntil.callback_handle)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntil::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamReadUntil::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DemuxerStreamReadUntil::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DemuxerStreamReadUntil::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 DemuxerStreamReadUntil::count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntil.count)
  return count_;
}
inline void DemuxerStreamReadUntil::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntil.count)
}

// -------------------------------------------------------------------

// DemuxerStreamInitializeCallback

// optional int32 type = 1;
inline bool DemuxerStreamInitializeCallback::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DemuxerStreamInitializeCallback::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DemuxerStreamInitializeCallback::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DemuxerStreamInitializeCallback::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 DemuxerStreamInitializeCallback::type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.type)
  return type_;
}
inline void DemuxerStreamInitializeCallback::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamInitializeCallback.type)
}

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 2;
inline bool DemuxerStreamInitializeCallback::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamInitializeCallback::set_has_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DemuxerStreamInitializeCallback::clear_has_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DemuxerStreamInitializeCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != NULL) audio_decoder_config_->::media::remoting::pb::AudioDecoderConfig::Clear();
  clear_has_audio_decoder_config();
}
inline const ::media::remoting::pb::AudioDecoderConfig& DemuxerStreamInitializeCallback::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  return audio_decoder_config_ != NULL ? *audio_decoder_config_
                         : *::media::remoting::pb::AudioDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamInitializeCallback::mutable_audio_decoder_config() {
  set_has_audio_decoder_config();
  if (audio_decoder_config_ == NULL) {
    audio_decoder_config_ = new ::media::remoting::pb::AudioDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  return audio_decoder_config_;
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamInitializeCallback::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
  clear_has_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = NULL;
  return temp;
}
inline void DemuxerStreamInitializeCallback::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  delete audio_decoder_config_;
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    set_has_audio_decoder_config();
  } else {
    clear_has_audio_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamInitializeCallback.audio_decoder_config)
}

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 3;
inline bool DemuxerStreamInitializeCallback::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamInitializeCallback::set_has_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DemuxerStreamInitializeCallback::clear_has_video_decoder_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DemuxerStreamInitializeCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != NULL) video_decoder_config_->::media::remoting::pb::VideoDecoderConfig::Clear();
  clear_has_video_decoder_config();
}
inline const ::media::remoting::pb::VideoDecoderConfig& DemuxerStreamInitializeCallback::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  return video_decoder_config_ != NULL ? *video_decoder_config_
                         : *::media::remoting::pb::VideoDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamInitializeCallback::mutable_video_decoder_config() {
  set_has_video_decoder_config();
  if (video_decoder_config_ == NULL) {
    video_decoder_config_ = new ::media::remoting::pb::VideoDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  return video_decoder_config_;
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamInitializeCallback::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
  clear_has_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = NULL;
  return temp;
}
inline void DemuxerStreamInitializeCallback::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  delete video_decoder_config_;
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    set_has_video_decoder_config();
  } else {
    clear_has_video_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamInitializeCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntilCallback

// optional .media.remoting.pb.DemuxerStreamReadUntilCallback.Status status = 1;
inline bool DemuxerStreamReadUntilCallback::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DemuxerStreamReadUntilCallback::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DemuxerStreamReadUntilCallback::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DemuxerStreamReadUntilCallback::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::status() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.status)
  return static_cast< ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status >(status_);
}
inline void DemuxerStreamReadUntilCallback::set_status(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status value) {
  assert(::media::remoting::pb::DemuxerStreamReadUntilCallback_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntilCallback.status)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntilCallback::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DemuxerStreamReadUntilCallback::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DemuxerStreamReadUntilCallback::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DemuxerStreamReadUntilCallback::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 DemuxerStreamReadUntilCallback::count() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.count)
  return count_;
}
inline void DemuxerStreamReadUntilCallback::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.DemuxerStreamReadUntilCallback.count)
}

// optional .media.remoting.pb.AudioDecoderConfig audio_decoder_config = 3;
inline bool DemuxerStreamReadUntilCallback::has_audio_decoder_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DemuxerStreamReadUntilCallback::set_has_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DemuxerStreamReadUntilCallback::clear_has_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DemuxerStreamReadUntilCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != NULL) audio_decoder_config_->::media::remoting::pb::AudioDecoderConfig::Clear();
  clear_has_audio_decoder_config();
}
inline const ::media::remoting::pb::AudioDecoderConfig& DemuxerStreamReadUntilCallback::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return audio_decoder_config_ != NULL ? *audio_decoder_config_
                         : *::media::remoting::pb::AudioDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamReadUntilCallback::mutable_audio_decoder_config() {
  set_has_audio_decoder_config();
  if (audio_decoder_config_ == NULL) {
    audio_decoder_config_ = new ::media::remoting::pb::AudioDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return audio_decoder_config_;
}
inline ::media::remoting::pb::AudioDecoderConfig* DemuxerStreamReadUntilCallback::release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
  clear_has_audio_decoder_config();
  ::media::remoting::pb::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = NULL;
  return temp;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_audio_decoder_config(::media::remoting::pb::AudioDecoderConfig* audio_decoder_config) {
  delete audio_decoder_config_;
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    set_has_audio_decoder_config();
  } else {
    clear_has_audio_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamReadUntilCallback.audio_decoder_config)
}

// optional .media.remoting.pb.VideoDecoderConfig video_decoder_config = 4;
inline bool DemuxerStreamReadUntilCallback::has_video_decoder_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DemuxerStreamReadUntilCallback::set_has_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DemuxerStreamReadUntilCallback::clear_has_video_decoder_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DemuxerStreamReadUntilCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != NULL) video_decoder_config_->::media::remoting::pb::VideoDecoderConfig::Clear();
  clear_has_video_decoder_config();
}
inline const ::media::remoting::pb::VideoDecoderConfig& DemuxerStreamReadUntilCallback::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  return video_decoder_config_ != NULL ? *video_decoder_config_
                         : *::media::remoting::pb::VideoDecoderConfig::internal_default_instance();
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamReadUntilCallback::mutable_video_decoder_config() {
  set_has_video_decoder_config();
  if (video_decoder_config_ == NULL) {
    video_decoder_config_ = new ::media::remoting::pb::VideoDecoderConfig;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  return video_decoder_config_;
}
inline ::media::remoting::pb::VideoDecoderConfig* DemuxerStreamReadUntilCallback::release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
  clear_has_video_decoder_config();
  ::media::remoting::pb::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = NULL;
  return temp;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_video_decoder_config(::media::remoting::pb::VideoDecoderConfig* video_decoder_config) {
  delete video_decoder_config_;
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    set_has_video_decoder_config();
  } else {
    clear_has_video_decoder_config();
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.DemuxerStreamReadUntilCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// CdmInitialize

// optional string key_system = 1;
inline bool CdmInitialize::has_key_system() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmInitialize::set_has_key_system() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmInitialize::clear_has_key_system() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmInitialize::clear_key_system() {
  key_system_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key_system();
}
inline const ::std::string& CdmInitialize::key_system() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.key_system)
  return key_system_.GetNoArena();
}
inline void CdmInitialize::set_key_system(const ::std::string& value) {
  set_has_key_system();
  key_system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.key_system)
}
#if LANG_CXX11
inline void CdmInitialize::set_key_system(::std::string&& value) {
  set_has_key_system();
  key_system_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmInitialize.key_system)
}
#endif
inline void CdmInitialize::set_key_system(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key_system();
  key_system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmInitialize.key_system)
}
inline void CdmInitialize::set_key_system(const char* value, size_t size) {
  set_has_key_system();
  key_system_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmInitialize.key_system)
}
inline ::std::string* CdmInitialize::mutable_key_system() {
  set_has_key_system();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmInitialize.key_system)
  return key_system_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmInitialize::release_key_system() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmInitialize.key_system)
  clear_has_key_system();
  return key_system_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmInitialize::set_allocated_key_system(::std::string* key_system) {
  if (key_system != NULL) {
    set_has_key_system();
  } else {
    clear_has_key_system();
  }
  key_system_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key_system);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmInitialize.key_system)
}

// optional string security_origin = 2;
inline bool CdmInitialize::has_security_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmInitialize::set_has_security_origin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmInitialize::clear_has_security_origin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmInitialize::clear_security_origin() {
  security_origin_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_security_origin();
}
inline const ::std::string& CdmInitialize::security_origin() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.security_origin)
  return security_origin_.GetNoArena();
}
inline void CdmInitialize::set_security_origin(const ::std::string& value) {
  set_has_security_origin();
  security_origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.security_origin)
}
#if LANG_CXX11
inline void CdmInitialize::set_security_origin(::std::string&& value) {
  set_has_security_origin();
  security_origin_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmInitialize.security_origin)
}
#endif
inline void CdmInitialize::set_security_origin(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_security_origin();
  security_origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmInitialize.security_origin)
}
inline void CdmInitialize::set_security_origin(const char* value, size_t size) {
  set_has_security_origin();
  security_origin_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmInitialize.security_origin)
}
inline ::std::string* CdmInitialize::mutable_security_origin() {
  set_has_security_origin();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmInitialize.security_origin)
  return security_origin_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmInitialize::release_security_origin() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmInitialize.security_origin)
  clear_has_security_origin();
  return security_origin_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmInitialize::set_allocated_security_origin(::std::string* security_origin) {
  if (security_origin != NULL) {
    set_has_security_origin();
  } else {
    clear_has_security_origin();
  }
  security_origin_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), security_origin);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmInitialize.security_origin)
}

// optional bool allow_distinctive_identifier = 3;
inline bool CdmInitialize::has_allow_distinctive_identifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmInitialize::set_has_allow_distinctive_identifier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmInitialize::clear_has_allow_distinctive_identifier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmInitialize::clear_allow_distinctive_identifier() {
  allow_distinctive_identifier_ = false;
  clear_has_allow_distinctive_identifier();
}
inline bool CdmInitialize::allow_distinctive_identifier() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.allow_distinctive_identifier)
  return allow_distinctive_identifier_;
}
inline void CdmInitialize::set_allow_distinctive_identifier(bool value) {
  set_has_allow_distinctive_identifier();
  allow_distinctive_identifier_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.allow_distinctive_identifier)
}

// optional bool allow_persistent_state = 4;
inline bool CdmInitialize::has_allow_persistent_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmInitialize::set_has_allow_persistent_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CdmInitialize::clear_has_allow_persistent_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CdmInitialize::clear_allow_persistent_state() {
  allow_persistent_state_ = false;
  clear_has_allow_persistent_state();
}
inline bool CdmInitialize::allow_persistent_state() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.allow_persistent_state)
  return allow_persistent_state_;
}
inline void CdmInitialize::set_allow_persistent_state(bool value) {
  set_has_allow_persistent_state();
  allow_persistent_state_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.allow_persistent_state)
}

// optional bool use_hw_secure_codecs = 5;
inline bool CdmInitialize::has_use_hw_secure_codecs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CdmInitialize::set_has_use_hw_secure_codecs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CdmInitialize::clear_has_use_hw_secure_codecs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CdmInitialize::clear_use_hw_secure_codecs() {
  use_hw_secure_codecs_ = false;
  clear_has_use_hw_secure_codecs();
}
inline bool CdmInitialize::use_hw_secure_codecs() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.use_hw_secure_codecs)
  return use_hw_secure_codecs_;
}
inline void CdmInitialize::set_use_hw_secure_codecs(bool value) {
  set_has_use_hw_secure_codecs();
  use_hw_secure_codecs_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.use_hw_secure_codecs)
}

// optional int32 callback_handle = 6;
inline bool CdmInitialize::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CdmInitialize::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CdmInitialize::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CdmInitialize::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmInitialize::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmInitialize.callback_handle)
  return callback_handle_;
}
inline void CdmInitialize::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmInitialize.callback_handle)
}

// -------------------------------------------------------------------

// CdmSetServerCertificate

// optional int32 callback_handle = 1;
inline bool CdmSetServerCertificate::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmSetServerCertificate::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmSetServerCertificate::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmSetServerCertificate::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmSetServerCertificate::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmSetServerCertificate.callback_handle)
  return callback_handle_;
}
inline void CdmSetServerCertificate::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmSetServerCertificate.callback_handle)
}

// optional bytes certificate_data = 2;
inline bool CdmSetServerCertificate::has_certificate_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmSetServerCertificate::set_has_certificate_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmSetServerCertificate::clear_has_certificate_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmSetServerCertificate::clear_certificate_data() {
  certificate_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_certificate_data();
}
inline const ::std::string& CdmSetServerCertificate::certificate_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  return certificate_data_.GetNoArena();
}
inline void CdmSetServerCertificate::set_certificate_data(const ::std::string& value) {
  set_has_certificate_data();
  certificate_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
#if LANG_CXX11
inline void CdmSetServerCertificate::set_certificate_data(::std::string&& value) {
  set_has_certificate_data();
  certificate_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
#endif
inline void CdmSetServerCertificate::set_certificate_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_certificate_data();
  certificate_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline void CdmSetServerCertificate::set_certificate_data(const void* value, size_t size) {
  set_has_certificate_data();
  certificate_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}
inline ::std::string* CdmSetServerCertificate::mutable_certificate_data() {
  set_has_certificate_data();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  return certificate_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmSetServerCertificate::release_certificate_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmSetServerCertificate.certificate_data)
  clear_has_certificate_data();
  return certificate_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmSetServerCertificate::set_allocated_certificate_data(::std::string* certificate_data) {
  if (certificate_data != NULL) {
    set_has_certificate_data();
  } else {
    clear_has_certificate_data();
  }
  certificate_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), certificate_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmSetServerCertificate.certificate_data)
}

// -------------------------------------------------------------------

// CdmCreateSessionAndGenerateRequest

// optional .media.remoting.pb.CdmSessionType session_type = 1;
inline bool CdmCreateSessionAndGenerateRequest::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_session_type() {
  session_type_ = 0;
  clear_has_session_type();
}
inline ::media::remoting::pb::CdmSessionType CdmCreateSessionAndGenerateRequest::session_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.session_type)
  return static_cast< ::media::remoting::pb::CdmSessionType >(session_type_);
}
inline void CdmCreateSessionAndGenerateRequest::set_session_type(::media::remoting::pb::CdmSessionType value) {
  assert(::media::remoting::pb::CdmSessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.session_type)
}

// optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest.EmeInitDataType init_data_type = 2;
inline bool CdmCreateSessionAndGenerateRequest::has_init_data_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::set_has_init_data_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_has_init_data_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_init_data_type() {
  init_data_type_ = 0;
  clear_has_init_data_type();
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType CdmCreateSessionAndGenerateRequest::init_data_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data_type)
  return static_cast< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType >(init_data_type_);
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data_type(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType value) {
  assert(::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType_IsValid(value));
  set_has_init_data_type();
  init_data_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data_type)
}

// optional int32 callback_handle = 3;
inline bool CdmCreateSessionAndGenerateRequest::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmCreateSessionAndGenerateRequest::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.callback_handle)
  return callback_handle_;
}
inline void CdmCreateSessionAndGenerateRequest::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.callback_handle)
}

// optional bytes init_data = 4;
inline bool CdmCreateSessionAndGenerateRequest::has_init_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmCreateSessionAndGenerateRequest::set_has_init_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_has_init_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmCreateSessionAndGenerateRequest::clear_init_data() {
  init_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_init_data();
}
inline const ::std::string& CdmCreateSessionAndGenerateRequest::init_data() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  return init_data_.GetNoArena();
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const ::std::string& value) {
  set_has_init_data();
  init_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
#if LANG_CXX11
inline void CdmCreateSessionAndGenerateRequest::set_init_data(::std::string&& value) {
  set_has_init_data();
  init_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
#endif
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_init_data();
  init_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline void CdmCreateSessionAndGenerateRequest::set_init_data(const void* value, size_t size) {
  set_has_init_data();
  init_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}
inline ::std::string* CdmCreateSessionAndGenerateRequest::mutable_init_data() {
  set_has_init_data();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  return init_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmCreateSessionAndGenerateRequest::release_init_data() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
  clear_has_init_data();
  return init_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmCreateSessionAndGenerateRequest::set_allocated_init_data(::std::string* init_data) {
  if (init_data != NULL) {
    set_has_init_data();
  } else {
    clear_has_init_data();
  }
  init_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), init_data);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmCreateSessionAndGenerateRequest.init_data)
}

// -------------------------------------------------------------------

// CdmLoadSession

// optional .media.remoting.pb.CdmSessionType session_type = 1;
inline bool CdmLoadSession::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmLoadSession::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmLoadSession::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmLoadSession::clear_session_type() {
  session_type_ = 0;
  clear_has_session_type();
}
inline ::media::remoting::pb::CdmSessionType CdmLoadSession::session_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.session_type)
  return static_cast< ::media::remoting::pb::CdmSessionType >(session_type_);
}
inline void CdmLoadSession::set_session_type(::media::remoting::pb::CdmSessionType value) {
  assert(::media::remoting::pb::CdmSessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.session_type)
}

// optional string session_id = 2;
inline bool CdmLoadSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmLoadSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmLoadSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmLoadSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmLoadSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmLoadSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.session_id)
}
#if LANG_CXX11
inline void CdmLoadSession::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmLoadSession.session_id)
}
#endif
inline void CdmLoadSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmLoadSession.session_id)
}
inline void CdmLoadSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmLoadSession.session_id)
}
inline ::std::string* CdmLoadSession::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmLoadSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmLoadSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmLoadSession.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmLoadSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmLoadSession.session_id)
}

// optional int32 callback_handle = 3;
inline bool CdmLoadSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmLoadSession::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmLoadSession::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmLoadSession::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmLoadSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmLoadSession.callback_handle)
  return callback_handle_;
}
inline void CdmLoadSession::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmLoadSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmUpdateSession

// optional string session_id = 1;
inline bool CdmUpdateSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmUpdateSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmUpdateSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmUpdateSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmUpdateSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmUpdateSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.session_id)
}
#if LANG_CXX11
inline void CdmUpdateSession::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmUpdateSession.session_id)
}
#endif
inline void CdmUpdateSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmUpdateSession.session_id)
}
inline void CdmUpdateSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmUpdateSession.session_id)
}
inline ::std::string* CdmUpdateSession::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmUpdateSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmUpdateSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmUpdateSession.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmUpdateSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmUpdateSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmUpdateSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmUpdateSession::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmUpdateSession::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmUpdateSession::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmUpdateSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.callback_handle)
  return callback_handle_;
}
inline void CdmUpdateSession::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.callback_handle)
}

// optional bytes response = 3;
inline bool CdmUpdateSession::has_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmUpdateSession::set_has_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmUpdateSession::clear_has_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmUpdateSession::clear_response() {
  response_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_response();
}
inline const ::std::string& CdmUpdateSession::response() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmUpdateSession.response)
  return response_.GetNoArena();
}
inline void CdmUpdateSession::set_response(const ::std::string& value) {
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmUpdateSession.response)
}
#if LANG_CXX11
inline void CdmUpdateSession::set_response(::std::string&& value) {
  set_has_response();
  response_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmUpdateSession.response)
}
#endif
inline void CdmUpdateSession::set_response(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmUpdateSession.response)
}
inline void CdmUpdateSession::set_response(const void* value, size_t size) {
  set_has_response();
  response_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmUpdateSession.response)
}
inline ::std::string* CdmUpdateSession::mutable_response() {
  set_has_response();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmUpdateSession.response)
  return response_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmUpdateSession::release_response() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmUpdateSession.response)
  clear_has_response();
  return response_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmUpdateSession::set_allocated_response(::std::string* response) {
  if (response != NULL) {
    set_has_response();
  } else {
    clear_has_response();
  }
  response_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmUpdateSession.response)
}

// -------------------------------------------------------------------

// CdmCloseSession

// optional string session_id = 1;
inline bool CdmCloseSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmCloseSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmCloseSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmCloseSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmCloseSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCloseSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmCloseSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCloseSession.session_id)
}
#if LANG_CXX11
inline void CdmCloseSession::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmCloseSession.session_id)
}
#endif
inline void CdmCloseSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmCloseSession.session_id)
}
inline void CdmCloseSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmCloseSession.session_id)
}
inline ::std::string* CdmCloseSession::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmCloseSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmCloseSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmCloseSession.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmCloseSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmCloseSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmCloseSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmCloseSession::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmCloseSession::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmCloseSession::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmCloseSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmCloseSession.callback_handle)
  return callback_handle_;
}
inline void CdmCloseSession::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmCloseSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmRemoveSession

// optional string session_id = 1;
inline bool CdmRemoveSession::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmRemoveSession::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmRemoveSession::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmRemoveSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmRemoveSession::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmRemoveSession.session_id)
  return session_id_.GetNoArena();
}
inline void CdmRemoveSession::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmRemoveSession.session_id)
}
#if LANG_CXX11
inline void CdmRemoveSession::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmRemoveSession.session_id)
}
#endif
inline void CdmRemoveSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmRemoveSession.session_id)
}
inline void CdmRemoveSession::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmRemoveSession.session_id)
}
inline ::std::string* CdmRemoveSession::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmRemoveSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmRemoveSession::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmRemoveSession.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmRemoveSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmRemoveSession.session_id)
}

// optional int32 callback_handle = 2;
inline bool CdmRemoveSession::has_callback_handle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmRemoveSession::set_has_callback_handle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmRemoveSession::clear_has_callback_handle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmRemoveSession::clear_callback_handle() {
  callback_handle_ = 0;
  clear_has_callback_handle();
}
inline ::google::protobuf::int32 CdmRemoveSession::callback_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmRemoveSession.callback_handle)
  return callback_handle_;
}
inline void CdmRemoveSession::set_callback_handle(::google::protobuf::int32 value) {
  set_has_callback_handle();
  callback_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmRemoveSession.callback_handle)
}

// -------------------------------------------------------------------

// CdmPromise

// optional int32 cdm_id = 1;
inline bool CdmPromise::has_cdm_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmPromise::set_has_cdm_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmPromise::clear_has_cdm_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmPromise::clear_cdm_id() {
  cdm_id_ = 0;
  clear_has_cdm_id();
}
inline ::google::protobuf::int32 CdmPromise::cdm_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.cdm_id)
  return cdm_id_;
}
inline void CdmPromise::set_cdm_id(::google::protobuf::int32 value) {
  set_has_cdm_id();
  cdm_id_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.cdm_id)
}

// optional int32 decryptor_handle = 2;
inline bool CdmPromise::has_decryptor_handle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CdmPromise::set_has_decryptor_handle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CdmPromise::clear_has_decryptor_handle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CdmPromise::clear_decryptor_handle() {
  decryptor_handle_ = 0;
  clear_has_decryptor_handle();
}
inline ::google::protobuf::int32 CdmPromise::decryptor_handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.decryptor_handle)
  return decryptor_handle_;
}
inline void CdmPromise::set_decryptor_handle(::google::protobuf::int32 value) {
  set_has_decryptor_handle();
  decryptor_handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.decryptor_handle)
}

// optional string session_id = 3;
inline bool CdmPromise::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmPromise::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmPromise::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmPromise::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmPromise::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.session_id)
  return session_id_.GetNoArena();
}
inline void CdmPromise::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.session_id)
}
#if LANG_CXX11
inline void CdmPromise::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmPromise.session_id)
}
#endif
inline void CdmPromise::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmPromise.session_id)
}
inline void CdmPromise::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmPromise.session_id)
}
inline ::std::string* CdmPromise::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmPromise.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmPromise::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmPromise.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmPromise::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmPromise.session_id)
}

// optional bool success = 4;
inline bool CdmPromise::has_success() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CdmPromise::set_has_success() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CdmPromise::clear_has_success() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CdmPromise::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool CdmPromise::success() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.success)
  return success_;
}
inline void CdmPromise::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.success)
}

// optional .media.remoting.pb.CdmException exception = 5;
inline bool CdmPromise::has_exception() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CdmPromise::set_has_exception() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CdmPromise::clear_has_exception() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CdmPromise::clear_exception() {
  exception_ = 0;
  clear_has_exception();
}
inline ::media::remoting::pb::CdmException CdmPromise::exception() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.exception)
  return static_cast< ::media::remoting::pb::CdmException >(exception_);
}
inline void CdmPromise::set_exception(::media::remoting::pb::CdmException value) {
  assert(::media::remoting::pb::CdmException_IsValid(value));
  set_has_exception();
  exception_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.exception)
}

// optional uint32 system_code = 6;
inline bool CdmPromise::has_system_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CdmPromise::set_has_system_code() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CdmPromise::clear_has_system_code() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CdmPromise::clear_system_code() {
  system_code_ = 0u;
  clear_has_system_code();
}
inline ::google::protobuf::uint32 CdmPromise::system_code() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.system_code)
  return system_code_;
}
inline void CdmPromise::set_system_code(::google::protobuf::uint32 value) {
  set_has_system_code();
  system_code_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.system_code)
}

// optional string error_message = 7;
inline bool CdmPromise::has_error_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmPromise::set_has_error_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmPromise::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmPromise::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error_message();
}
inline const ::std::string& CdmPromise::error_message() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmPromise.error_message)
  return error_message_.GetNoArena();
}
inline void CdmPromise::set_error_message(const ::std::string& value) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmPromise.error_message)
}
#if LANG_CXX11
inline void CdmPromise::set_error_message(::std::string&& value) {
  set_has_error_message();
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmPromise.error_message)
}
#endif
inline void CdmPromise::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmPromise.error_message)
}
inline void CdmPromise::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmPromise.error_message)
}
inline ::std::string* CdmPromise::mutable_error_message() {
  set_has_error_message();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmPromise.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmPromise::release_error_message() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmPromise.error_message)
  clear_has_error_message();
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmPromise::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    set_has_error_message();
  } else {
    clear_has_error_message();
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmPromise.error_message)
}

// -------------------------------------------------------------------

// CdmClientOnSessionMessage

// optional string session_id = 1;
inline bool CdmClientOnSessionMessage::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionMessage::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmClientOnSessionMessage::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmClientOnSessionMessage::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmClientOnSessionMessage::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionMessage::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
#if LANG_CXX11
inline void CdmClientOnSessionMessage::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
#endif
inline void CdmClientOnSessionMessage::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline void CdmClientOnSessionMessage::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}
inline ::std::string* CdmClientOnSessionMessage::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmClientOnSessionMessage::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionMessage.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionMessage::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionMessage.session_id)
}

// optional .media.remoting.pb.CdmMessageType message_type = 2;
inline bool CdmClientOnSessionMessage::has_message_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CdmClientOnSessionMessage::set_has_message_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CdmClientOnSessionMessage::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CdmClientOnSessionMessage::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::media::remoting::pb::CdmMessageType CdmClientOnSessionMessage::message_type() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.message_type)
  return static_cast< ::media::remoting::pb::CdmMessageType >(message_type_);
}
inline void CdmClientOnSessionMessage::set_message_type(::media::remoting::pb::CdmMessageType value) {
  assert(::media::remoting::pb::CdmMessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.message_type)
}

// optional bytes message = 3;
inline bool CdmClientOnSessionMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmClientOnSessionMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmClientOnSessionMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& CdmClientOnSessionMessage::message() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionMessage.message)
  return message_.GetNoArena();
}
inline void CdmClientOnSessionMessage::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionMessage.message)
}
#if LANG_CXX11
inline void CdmClientOnSessionMessage::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionMessage.message)
}
#endif
inline void CdmClientOnSessionMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline void CdmClientOnSessionMessage::set_message(const void* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionMessage.message)
}
inline ::std::string* CdmClientOnSessionMessage::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmClientOnSessionMessage::release_message() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionMessage.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionMessage::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionMessage.message)
}

// -------------------------------------------------------------------

// CdmClientOnSessionKeysChange

// optional string session_id = 1;
inline bool CdmClientOnSessionKeysChange::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionKeysChange::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmClientOnSessionKeysChange::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmClientOnSessionKeysChange::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmClientOnSessionKeysChange::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionKeysChange::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
#if LANG_CXX11
inline void CdmClientOnSessionKeysChange::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
#endif
inline void CdmClientOnSessionKeysChange::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline void CdmClientOnSessionKeysChange::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}
inline ::std::string* CdmClientOnSessionKeysChange::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmClientOnSessionKeysChange::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionKeysChange::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionKeysChange.session_id)
}

// optional bool has_additional_usable_key = 2;
inline bool CdmClientOnSessionKeysChange::has_has_additional_usable_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionKeysChange::set_has_has_additional_usable_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmClientOnSessionKeysChange::clear_has_has_additional_usable_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmClientOnSessionKeysChange::clear_has_additional_usable_key() {
  has_additional_usable_key_ = false;
  clear_has_has_additional_usable_key();
}
inline bool CdmClientOnSessionKeysChange::has_additional_usable_key() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.has_additional_usable_key)
  return has_additional_usable_key_;
}
inline void CdmClientOnSessionKeysChange::set_has_additional_usable_key(bool value) {
  set_has_has_additional_usable_key();
  has_additional_usable_key_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionKeysChange.has_additional_usable_key)
}

// repeated .media.remoting.pb.CdmKeyInformation key_information = 3;
inline int CdmClientOnSessionKeysChange::key_information_size() const {
  return key_information_.size();
}
inline void CdmClientOnSessionKeysChange::clear_key_information() {
  key_information_.Clear();
}
inline const ::media::remoting::pb::CdmKeyInformation& CdmClientOnSessionKeysChange::key_information(int index) const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Get(index);
}
inline ::media::remoting::pb::CdmKeyInformation* CdmClientOnSessionKeysChange::mutable_key_information(int index) {
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Mutable(index);
}
inline ::media::remoting::pb::CdmKeyInformation* CdmClientOnSessionKeysChange::add_key_information() {
  // @@protoc_insertion_point(field_add:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >*
CdmClientOnSessionKeysChange::mutable_key_information() {
  // @@protoc_insertion_point(field_mutable_list:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return &key_information_;
}
inline const ::google::protobuf::RepeatedPtrField< ::media::remoting::pb::CdmKeyInformation >&
CdmClientOnSessionKeysChange::key_information() const {
  // @@protoc_insertion_point(field_list:media.remoting.pb.CdmClientOnSessionKeysChange.key_information)
  return key_information_;
}

// -------------------------------------------------------------------

// CdmClientOnSessionExpirationUpdate

// optional string session_id = 1;
inline bool CdmClientOnSessionExpirationUpdate::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CdmClientOnSessionExpirationUpdate::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CdmClientOnSessionExpirationUpdate::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CdmClientOnSessionExpirationUpdate::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_session_id();
}
inline const ::std::string& CdmClientOnSessionExpirationUpdate::session_id() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  return session_id_.GetNoArena();
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const ::std::string& value) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
#if LANG_CXX11
inline void CdmClientOnSessionExpirationUpdate::set_session_id(::std::string&& value) {
  set_has_session_id();
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
#endif
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline void CdmClientOnSessionExpirationUpdate::set_session_id(const char* value, size_t size) {
  set_has_session_id();
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}
inline ::std::string* CdmClientOnSessionExpirationUpdate::mutable_session_id() {
  set_has_session_id();
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CdmClientOnSessionExpirationUpdate::release_session_id() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
  clear_has_session_id();
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CdmClientOnSessionExpirationUpdate::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    set_has_session_id();
  } else {
    clear_has_session_id();
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.CdmClientOnSessionExpirationUpdate.session_id)
}

// optional double new_expiry_time_sec = 2;
inline bool CdmClientOnSessionExpirationUpdate::has_new_expiry_time_sec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CdmClientOnSessionExpirationUpdate::set_has_new_expiry_time_sec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CdmClientOnSessionExpirationUpdate::clear_has_new_expiry_time_sec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CdmClientOnSessionExpirationUpdate::clear_new_expiry_time_sec() {
  new_expiry_time_sec_ = 0;
  clear_has_new_expiry_time_sec();
}
inline double CdmClientOnSessionExpirationUpdate::new_expiry_time_sec() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.CdmClientOnSessionExpirationUpdate.new_expiry_time_sec)
  return new_expiry_time_sec_;
}
inline void CdmClientOnSessionExpirationUpdate::set_new_expiry_time_sec(double value) {
  set_has_new_expiry_time_sec();
  new_expiry_time_sec_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.CdmClientOnSessionExpirationUpdate.new_expiry_time_sec)
}

// -------------------------------------------------------------------

// RpcMessage

// optional int32 handle = 1;
inline bool RpcMessage::has_handle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpcMessage::set_has_handle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpcMessage::clear_has_handle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpcMessage::clear_handle() {
  handle_ = 0;
  clear_has_handle();
}
inline ::google::protobuf::int32 RpcMessage::handle() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.handle)
  return handle_;
}
inline void RpcMessage::set_handle(::google::protobuf::int32 value) {
  set_has_handle();
  handle_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.handle)
}

// optional .media.remoting.pb.RpcMessage.RpcProc proc = 2;
inline bool RpcMessage::has_proc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpcMessage::set_has_proc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpcMessage::clear_has_proc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpcMessage::clear_proc() {
  proc_ = 0;
  clear_has_proc();
}
inline ::media::remoting::pb::RpcMessage_RpcProc RpcMessage::proc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.proc)
  return static_cast< ::media::remoting::pb::RpcMessage_RpcProc >(proc_);
}
inline void RpcMessage::set_proc(::media::remoting::pb::RpcMessage_RpcProc value) {
  assert(::media::remoting::pb::RpcMessage_RpcProc_IsValid(value));
  set_has_proc();
  proc_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.proc)
}

// optional int32 integer_value = 3;
inline bool RpcMessage::has_integer_value() const {
  return rpc_oneof_case() == kIntegerValue;
}
inline void RpcMessage::set_has_integer_value() {
  _oneof_case_[0] = kIntegerValue;
}
inline void RpcMessage::clear_integer_value() {
  if (has_integer_value()) {
    rpc_oneof_.integer_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline ::google::protobuf::int32 RpcMessage::integer_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.integer_value)
  if (has_integer_value()) {
    return rpc_oneof_.integer_value_;
  }
  return 0;
}
inline void RpcMessage::set_integer_value(::google::protobuf::int32 value) {
  if (!has_integer_value()) {
    clear_rpc_oneof();
    set_has_integer_value();
  }
  rpc_oneof_.integer_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.integer_value)
}

// optional int64 integer64_value = 4;
inline bool RpcMessage::has_integer64_value() const {
  return rpc_oneof_case() == kInteger64Value;
}
inline void RpcMessage::set_has_integer64_value() {
  _oneof_case_[0] = kInteger64Value;
}
inline void RpcMessage::clear_integer64_value() {
  if (has_integer64_value()) {
    rpc_oneof_.integer64_value_ = GOOGLE_LONGLONG(0);
    clear_has_rpc_oneof();
  }
}
inline ::google::protobuf::int64 RpcMessage::integer64_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.integer64_value)
  if (has_integer64_value()) {
    return rpc_oneof_.integer64_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void RpcMessage::set_integer64_value(::google::protobuf::int64 value) {
  if (!has_integer64_value()) {
    clear_rpc_oneof();
    set_has_integer64_value();
  }
  rpc_oneof_.integer64_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.integer64_value)
}

// optional double double_value = 5;
inline bool RpcMessage::has_double_value() const {
  return rpc_oneof_case() == kDoubleValue;
}
inline void RpcMessage::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void RpcMessage::clear_double_value() {
  if (has_double_value()) {
    rpc_oneof_.double_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline double RpcMessage::double_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.double_value)
  if (has_double_value()) {
    return rpc_oneof_.double_value_;
  }
  return 0;
}
inline void RpcMessage::set_double_value(double value) {
  if (!has_double_value()) {
    clear_rpc_oneof();
    set_has_double_value();
  }
  rpc_oneof_.double_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.double_value)
}

// optional bool boolean_value = 6;
inline bool RpcMessage::has_boolean_value() const {
  return rpc_oneof_case() == kBooleanValue;
}
inline void RpcMessage::set_has_boolean_value() {
  _oneof_case_[0] = kBooleanValue;
}
inline void RpcMessage::clear_boolean_value() {
  if (has_boolean_value()) {
    rpc_oneof_.boolean_value_ = false;
    clear_has_rpc_oneof();
  }
}
inline bool RpcMessage::boolean_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.boolean_value)
  if (has_boolean_value()) {
    return rpc_oneof_.boolean_value_;
  }
  return false;
}
inline void RpcMessage::set_boolean_value(bool value) {
  if (!has_boolean_value()) {
    clear_rpc_oneof();
    set_has_boolean_value();
  }
  rpc_oneof_.boolean_value_ = value;
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.boolean_value)
}

// optional string string_value = 7;
inline bool RpcMessage::has_string_value() const {
  return rpc_oneof_case() == kStringValue;
}
inline void RpcMessage::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void RpcMessage::clear_string_value() {
  if (has_string_value()) {
    rpc_oneof_.string_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_rpc_oneof();
  }
}
inline const ::std::string& RpcMessage::string_value() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.string_value)
  if (has_string_value()) {
    return rpc_oneof_.string_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void RpcMessage::set_string_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
}
#if LANG_CXX11
inline void RpcMessage::set_string_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:media.remoting.pb.RpcMessage.string_value)
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:media.remoting.pb.RpcMessage.string_value)
}
#endif
inline void RpcMessage::set_string_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:media.remoting.pb.RpcMessage.string_value)
}
inline void RpcMessage::set_string_value(const char* value, size_t size) {
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  rpc_oneof_.string_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:media.remoting.pb.RpcMessage.string_value)
}
inline ::std::string* RpcMessage::mutable_string_value() {
  if (!has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.string_value)
  return rpc_oneof_.string_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RpcMessage::release_string_value() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.string_value)
  if (has_string_value()) {
    clear_has_rpc_oneof();
    return rpc_oneof_.string_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_string_value(::std::string* string_value) {
  if (!has_string_value()) {
    rpc_oneof_.string_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_rpc_oneof();
  if (string_value != NULL) {
    set_has_string_value();
    rpc_oneof_.string_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        string_value);
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.string_value)
}

// optional .media.remoting.pb.RendererInitialize renderer_initialize_rpc = 100;
inline bool RpcMessage::has_renderer_initialize_rpc() const {
  return rpc_oneof_case() == kRendererInitializeRpc;
}
inline void RpcMessage::set_has_renderer_initialize_rpc() {
  _oneof_case_[0] = kRendererInitializeRpc;
}
inline void RpcMessage::clear_renderer_initialize_rpc() {
  if (has_renderer_initialize_rpc()) {
    delete rpc_oneof_.renderer_initialize_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererInitialize& RpcMessage::renderer_initialize_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  return has_renderer_initialize_rpc()
      ? *rpc_oneof_.renderer_initialize_rpc_
      : ::media::remoting::pb::RendererInitialize::default_instance();
}
inline ::media::remoting::pb::RendererInitialize* RpcMessage::mutable_renderer_initialize_rpc() {
  if (!has_renderer_initialize_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = new ::media::remoting::pb::RendererInitialize;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  return rpc_oneof_.renderer_initialize_rpc_;
}
inline ::media::remoting::pb::RendererInitialize* RpcMessage::release_renderer_initialize_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
  if (has_renderer_initialize_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererInitialize* temp = rpc_oneof_.renderer_initialize_rpc_;
    rpc_oneof_.renderer_initialize_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_renderer_initialize_rpc(::media::remoting::pb::RendererInitialize* renderer_initialize_rpc) {
  clear_rpc_oneof();
  if (renderer_initialize_rpc) {
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = renderer_initialize_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.renderer_initialize_rpc)
}

// optional .media.remoting.pb.RendererFlushUntil renderer_flushuntil_rpc = 101;
inline bool RpcMessage::has_renderer_flushuntil_rpc() const {
  return rpc_oneof_case() == kRendererFlushuntilRpc;
}
inline void RpcMessage::set_has_renderer_flushuntil_rpc() {
  _oneof_case_[0] = kRendererFlushuntilRpc;
}
inline void RpcMessage::clear_renderer_flushuntil_rpc() {
  if (has_renderer_flushuntil_rpc()) {
    delete rpc_oneof_.renderer_flushuntil_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererFlushUntil& RpcMessage::renderer_flushuntil_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  return has_renderer_flushuntil_rpc()
      ? *rpc_oneof_.renderer_flushuntil_rpc_
      : ::media::remoting::pb::RendererFlushUntil::default_instance();
}
inline ::media::remoting::pb::RendererFlushUntil* RpcMessage::mutable_renderer_flushuntil_rpc() {
  if (!has_renderer_flushuntil_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = new ::media::remoting::pb::RendererFlushUntil;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  return rpc_oneof_.renderer_flushuntil_rpc_;
}
inline ::media::remoting::pb::RendererFlushUntil* RpcMessage::release_renderer_flushuntil_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
  if (has_renderer_flushuntil_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererFlushUntil* temp = rpc_oneof_.renderer_flushuntil_rpc_;
    rpc_oneof_.renderer_flushuntil_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_renderer_flushuntil_rpc(::media::remoting::pb::RendererFlushUntil* renderer_flushuntil_rpc) {
  clear_rpc_oneof();
  if (renderer_flushuntil_rpc) {
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = renderer_flushuntil_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.renderer_flushuntil_rpc)
}

// optional .media.remoting.pb.RendererSetCdm renderer_set_cdm_rpc = 102;
inline bool RpcMessage::has_renderer_set_cdm_rpc() const {
  return rpc_oneof_case() == kRendererSetCdmRpc;
}
inline void RpcMessage::set_has_renderer_set_cdm_rpc() {
  _oneof_case_[0] = kRendererSetCdmRpc;
}
inline void RpcMessage::clear_renderer_set_cdm_rpc() {
  if (has_renderer_set_cdm_rpc()) {
    delete rpc_oneof_.renderer_set_cdm_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererSetCdm& RpcMessage::renderer_set_cdm_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  return has_renderer_set_cdm_rpc()
      ? *rpc_oneof_.renderer_set_cdm_rpc_
      : ::media::remoting::pb::RendererSetCdm::default_instance();
}
inline ::media::remoting::pb::RendererSetCdm* RpcMessage::mutable_renderer_set_cdm_rpc() {
  if (!has_renderer_set_cdm_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_set_cdm_rpc();
    rpc_oneof_.renderer_set_cdm_rpc_ = new ::media::remoting::pb::RendererSetCdm;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  return rpc_oneof_.renderer_set_cdm_rpc_;
}
inline ::media::remoting::pb::RendererSetCdm* RpcMessage::release_renderer_set_cdm_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
  if (has_renderer_set_cdm_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererSetCdm* temp = rpc_oneof_.renderer_set_cdm_rpc_;
    rpc_oneof_.renderer_set_cdm_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_renderer_set_cdm_rpc(::media::remoting::pb::RendererSetCdm* renderer_set_cdm_rpc) {
  clear_rpc_oneof();
  if (renderer_set_cdm_rpc) {
    set_has_renderer_set_cdm_rpc();
    rpc_oneof_.renderer_set_cdm_rpc_ = renderer_set_cdm_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.renderer_set_cdm_rpc)
}

// optional .media.remoting.pb.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
inline bool RpcMessage::has_rendererclient_ontimeupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOntimeupdateRpc;
}
inline void RpcMessage::set_has_rendererclient_ontimeupdate_rpc() {
  _oneof_case_[0] = kRendererclientOntimeupdateRpc;
}
inline void RpcMessage::clear_rendererclient_ontimeupdate_rpc() {
  if (has_rendererclient_ontimeupdate_rpc()) {
    delete rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererClientOnTimeUpdate& RpcMessage::rendererclient_ontimeupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  return has_rendererclient_ontimeupdate_rpc()
      ? *rpc_oneof_.rendererclient_ontimeupdate_rpc_
      : ::media::remoting::pb::RendererClientOnTimeUpdate::default_instance();
}
inline ::media::remoting::pb::RendererClientOnTimeUpdate* RpcMessage::mutable_rendererclient_ontimeupdate_rpc() {
  if (!has_rendererclient_ontimeupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = new ::media::remoting::pb::RendererClientOnTimeUpdate;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  return rpc_oneof_.rendererclient_ontimeupdate_rpc_;
}
inline ::media::remoting::pb::RendererClientOnTimeUpdate* RpcMessage::release_rendererclient_ontimeupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
  if (has_rendererclient_ontimeupdate_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererClientOnTimeUpdate* temp = rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_ontimeupdate_rpc(::media::remoting::pb::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc) {
  clear_rpc_oneof();
  if (rendererclient_ontimeupdate_rpc) {
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = rendererclient_ontimeupdate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_ontimeupdate_rpc)
}

// optional .media.remoting.pb.Size rendererclient_onvideonatualsizechange_rpc = 201;
inline bool RpcMessage::has_rendererclient_onvideonatualsizechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideonatualsizechangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onvideonatualsizechange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideonatualsizechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideonatualsizechange_rpc() {
  if (has_rendererclient_onvideonatualsizechange_rpc()) {
    delete rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::Size& RpcMessage::rendererclient_onvideonatualsizechange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return has_rendererclient_onvideonatualsizechange_rpc()
      ? *rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_
      : ::media::remoting::pb::Size::default_instance();
}
inline ::media::remoting::pb::Size* RpcMessage::mutable_rendererclient_onvideonatualsizechange_rpc() {
  if (!has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = new ::media::remoting::pb::Size;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
}
inline ::media::remoting::pb::Size* RpcMessage::release_rendererclient_onvideonatualsizechange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  if (has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::Size* temp = rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_onvideonatualsizechange_rpc(::media::remoting::pb::Size* rendererclient_onvideonatualsizechange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onvideonatualsizechange_rpc) {
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = rendererclient_onvideonatualsizechange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
}

// optional .media.remoting.pb.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
inline bool RpcMessage::has_rendererclient_onstatisticsupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOnstatisticsupdateRpc;
}
inline void RpcMessage::set_has_rendererclient_onstatisticsupdate_rpc() {
  _oneof_case_[0] = kRendererclientOnstatisticsupdateRpc;
}
inline void RpcMessage::clear_rendererclient_onstatisticsupdate_rpc() {
  if (has_rendererclient_onstatisticsupdate_rpc()) {
    delete rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::PipelineStatistics& RpcMessage::rendererclient_onstatisticsupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return has_rendererclient_onstatisticsupdate_rpc()
      ? *rpc_oneof_.rendererclient_onstatisticsupdate_rpc_
      : ::media::remoting::pb::PipelineStatistics::default_instance();
}
inline ::media::remoting::pb::PipelineStatistics* RpcMessage::mutable_rendererclient_onstatisticsupdate_rpc() {
  if (!has_rendererclient_onstatisticsupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = new ::media::remoting::pb::PipelineStatistics;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
}
inline ::media::remoting::pb::PipelineStatistics* RpcMessage::release_rendererclient_onstatisticsupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  if (has_rendererclient_onstatisticsupdate_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::PipelineStatistics* temp = rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_onstatisticsupdate_rpc(::media::remoting::pb::PipelineStatistics* rendererclient_onstatisticsupdate_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onstatisticsupdate_rpc) {
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = rendererclient_onstatisticsupdate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_onstatisticsupdate_rpc)
}

// optional .media.remoting.pb.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
inline bool RpcMessage::has_rendererclient_onbufferingstatechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnbufferingstatechangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onbufferingstatechange_rpc() {
  _oneof_case_[0] = kRendererclientOnbufferingstatechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onbufferingstatechange_rpc() {
  if (has_rendererclient_onbufferingstatechange_rpc()) {
    delete rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererClientOnBufferingStateChange& RpcMessage::rendererclient_onbufferingstatechange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return has_rendererclient_onbufferingstatechange_rpc()
      ? *rpc_oneof_.rendererclient_onbufferingstatechange_rpc_
      : ::media::remoting::pb::RendererClientOnBufferingStateChange::default_instance();
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange* RpcMessage::mutable_rendererclient_onbufferingstatechange_rpc() {
  if (!has_rendererclient_onbufferingstatechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = new ::media::remoting::pb::RendererClientOnBufferingStateChange;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
}
inline ::media::remoting::pb::RendererClientOnBufferingStateChange* RpcMessage::release_rendererclient_onbufferingstatechange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  if (has_rendererclient_onbufferingstatechange_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererClientOnBufferingStateChange* temp = rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_onbufferingstatechange_rpc(::media::remoting::pb::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onbufferingstatechange_rpc) {
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = rendererclient_onbufferingstatechange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_onbufferingstatechange_rpc)
}

// optional .media.remoting.pb.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
inline bool RpcMessage::has_rendererclient_onaudioconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnaudioconfigchangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onaudioconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnaudioconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onaudioconfigchange_rpc() {
  if (has_rendererclient_onaudioconfigchange_rpc()) {
    delete rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererClientOnAudioConfigChange& RpcMessage::rendererclient_onaudioconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return has_rendererclient_onaudioconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onaudioconfigchange_rpc_
      : ::media::remoting::pb::RendererClientOnAudioConfigChange::default_instance();
}
inline ::media::remoting::pb::RendererClientOnAudioConfigChange* RpcMessage::mutable_rendererclient_onaudioconfigchange_rpc() {
  if (!has_rendererclient_onaudioconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = new ::media::remoting::pb::RendererClientOnAudioConfigChange;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
}
inline ::media::remoting::pb::RendererClientOnAudioConfigChange* RpcMessage::release_rendererclient_onaudioconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  if (has_rendererclient_onaudioconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererClientOnAudioConfigChange* temp = rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_onaudioconfigchange_rpc(::media::remoting::pb::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onaudioconfigchange_rpc) {
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = rendererclient_onaudioconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_onaudioconfigchange_rpc)
}

// optional .media.remoting.pb.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
inline bool RpcMessage::has_rendererclient_onvideoconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideoconfigchangeRpc;
}
inline void RpcMessage::set_has_rendererclient_onvideoconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideoconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideoconfigchange_rpc() {
  if (has_rendererclient_onvideoconfigchange_rpc()) {
    delete rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::RendererClientOnVideoConfigChange& RpcMessage::rendererclient_onvideoconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return has_rendererclient_onvideoconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onvideoconfigchange_rpc_
      : ::media::remoting::pb::RendererClientOnVideoConfigChange::default_instance();
}
inline ::media::remoting::pb::RendererClientOnVideoConfigChange* RpcMessage::mutable_rendererclient_onvideoconfigchange_rpc() {
  if (!has_rendererclient_onvideoconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = new ::media::remoting::pb::RendererClientOnVideoConfigChange;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
}
inline ::media::remoting::pb::RendererClientOnVideoConfigChange* RpcMessage::release_rendererclient_onvideoconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  if (has_rendererclient_onvideoconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::RendererClientOnVideoConfigChange* temp = rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_rendererclient_onvideoconfigchange_rpc(::media::remoting::pb::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onvideoconfigchange_rpc) {
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = rendererclient_onvideoconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.rendererclient_onvideoconfigchange_rpc)
}

// optional .media.remoting.pb.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
inline bool RpcMessage::has_demuxerstream_readuntil_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilRpc;
}
inline void RpcMessage::set_has_demuxerstream_readuntil_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntil_rpc() {
  if (has_demuxerstream_readuntil_rpc()) {
    delete rpc_oneof_.demuxerstream_readuntil_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::DemuxerStreamReadUntil& RpcMessage::demuxerstream_readuntil_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  return has_demuxerstream_readuntil_rpc()
      ? *rpc_oneof_.demuxerstream_readuntil_rpc_
      : ::media::remoting::pb::DemuxerStreamReadUntil::default_instance();
}
inline ::media::remoting::pb::DemuxerStreamReadUntil* RpcMessage::mutable_demuxerstream_readuntil_rpc() {
  if (!has_demuxerstream_readuntil_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = new ::media::remoting::pb::DemuxerStreamReadUntil;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  return rpc_oneof_.demuxerstream_readuntil_rpc_;
}
inline ::media::remoting::pb::DemuxerStreamReadUntil* RpcMessage::release_demuxerstream_readuntil_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
  if (has_demuxerstream_readuntil_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::DemuxerStreamReadUntil* temp = rpc_oneof_.demuxerstream_readuntil_rpc_;
    rpc_oneof_.demuxerstream_readuntil_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_demuxerstream_readuntil_rpc(::media::remoting::pb::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_readuntil_rpc) {
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = demuxerstream_readuntil_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.demuxerstream_readuntil_rpc)
}

// optional .media.remoting.pb.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
inline bool RpcMessage::has_demuxerstream_initializecb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamInitializecbRpc;
}
inline void RpcMessage::set_has_demuxerstream_initializecb_rpc() {
  _oneof_case_[0] = kDemuxerstreamInitializecbRpc;
}
inline void RpcMessage::clear_demuxerstream_initializecb_rpc() {
  if (has_demuxerstream_initializecb_rpc()) {
    delete rpc_oneof_.demuxerstream_initializecb_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::DemuxerStreamInitializeCallback& RpcMessage::demuxerstream_initializecb_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  return has_demuxerstream_initializecb_rpc()
      ? *rpc_oneof_.demuxerstream_initializecb_rpc_
      : ::media::remoting::pb::DemuxerStreamInitializeCallback::default_instance();
}
inline ::media::remoting::pb::DemuxerStreamInitializeCallback* RpcMessage::mutable_demuxerstream_initializecb_rpc() {
  if (!has_demuxerstream_initializecb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = new ::media::remoting::pb::DemuxerStreamInitializeCallback;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  return rpc_oneof_.demuxerstream_initializecb_rpc_;
}
inline ::media::remoting::pb::DemuxerStreamInitializeCallback* RpcMessage::release_demuxerstream_initializecb_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
  if (has_demuxerstream_initializecb_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::DemuxerStreamInitializeCallback* temp = rpc_oneof_.demuxerstream_initializecb_rpc_;
    rpc_oneof_.demuxerstream_initializecb_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_demuxerstream_initializecb_rpc(::media::remoting::pb::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_initializecb_rpc) {
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = demuxerstream_initializecb_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.demuxerstream_initializecb_rpc)
}

// optional .media.remoting.pb.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
inline bool RpcMessage::has_demuxerstream_readuntilcb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilcbRpc;
}
inline void RpcMessage::set_has_demuxerstream_readuntilcb_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilcbRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntilcb_rpc() {
  if (has_demuxerstream_readuntilcb_rpc()) {
    delete rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::DemuxerStreamReadUntilCallback& RpcMessage::demuxerstream_readuntilcb_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  return has_demuxerstream_readuntilcb_rpc()
      ? *rpc_oneof_.demuxerstream_readuntilcb_rpc_
      : ::media::remoting::pb::DemuxerStreamReadUntilCallback::default_instance();
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback* RpcMessage::mutable_demuxerstream_readuntilcb_rpc() {
  if (!has_demuxerstream_readuntilcb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = new ::media::remoting::pb::DemuxerStreamReadUntilCallback;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  return rpc_oneof_.demuxerstream_readuntilcb_rpc_;
}
inline ::media::remoting::pb::DemuxerStreamReadUntilCallback* RpcMessage::release_demuxerstream_readuntilcb_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
  if (has_demuxerstream_readuntilcb_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::DemuxerStreamReadUntilCallback* temp = rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_demuxerstream_readuntilcb_rpc(::media::remoting::pb::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_readuntilcb_rpc) {
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = demuxerstream_readuntilcb_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.demuxerstream_readuntilcb_rpc)
}

// optional .media.remoting.pb.CdmInitialize cdm_initialize_rpc = 500;
inline bool RpcMessage::has_cdm_initialize_rpc() const {
  return rpc_oneof_case() == kCdmInitializeRpc;
}
inline void RpcMessage::set_has_cdm_initialize_rpc() {
  _oneof_case_[0] = kCdmInitializeRpc;
}
inline void RpcMessage::clear_cdm_initialize_rpc() {
  if (has_cdm_initialize_rpc()) {
    delete rpc_oneof_.cdm_initialize_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmInitialize& RpcMessage::cdm_initialize_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  return has_cdm_initialize_rpc()
      ? *rpc_oneof_.cdm_initialize_rpc_
      : ::media::remoting::pb::CdmInitialize::default_instance();
}
inline ::media::remoting::pb::CdmInitialize* RpcMessage::mutable_cdm_initialize_rpc() {
  if (!has_cdm_initialize_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_initialize_rpc();
    rpc_oneof_.cdm_initialize_rpc_ = new ::media::remoting::pb::CdmInitialize;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  return rpc_oneof_.cdm_initialize_rpc_;
}
inline ::media::remoting::pb::CdmInitialize* RpcMessage::release_cdm_initialize_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
  if (has_cdm_initialize_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmInitialize* temp = rpc_oneof_.cdm_initialize_rpc_;
    rpc_oneof_.cdm_initialize_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_initialize_rpc(::media::remoting::pb::CdmInitialize* cdm_initialize_rpc) {
  clear_rpc_oneof();
  if (cdm_initialize_rpc) {
    set_has_cdm_initialize_rpc();
    rpc_oneof_.cdm_initialize_rpc_ = cdm_initialize_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_initialize_rpc)
}

// optional .media.remoting.pb.CdmSetServerCertificate cdm_setservercertificate_rpc = 501;
inline bool RpcMessage::has_cdm_setservercertificate_rpc() const {
  return rpc_oneof_case() == kCdmSetservercertificateRpc;
}
inline void RpcMessage::set_has_cdm_setservercertificate_rpc() {
  _oneof_case_[0] = kCdmSetservercertificateRpc;
}
inline void RpcMessage::clear_cdm_setservercertificate_rpc() {
  if (has_cdm_setservercertificate_rpc()) {
    delete rpc_oneof_.cdm_setservercertificate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmSetServerCertificate& RpcMessage::cdm_setservercertificate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  return has_cdm_setservercertificate_rpc()
      ? *rpc_oneof_.cdm_setservercertificate_rpc_
      : ::media::remoting::pb::CdmSetServerCertificate::default_instance();
}
inline ::media::remoting::pb::CdmSetServerCertificate* RpcMessage::mutable_cdm_setservercertificate_rpc() {
  if (!has_cdm_setservercertificate_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_setservercertificate_rpc();
    rpc_oneof_.cdm_setservercertificate_rpc_ = new ::media::remoting::pb::CdmSetServerCertificate;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  return rpc_oneof_.cdm_setservercertificate_rpc_;
}
inline ::media::remoting::pb::CdmSetServerCertificate* RpcMessage::release_cdm_setservercertificate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
  if (has_cdm_setservercertificate_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmSetServerCertificate* temp = rpc_oneof_.cdm_setservercertificate_rpc_;
    rpc_oneof_.cdm_setservercertificate_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_setservercertificate_rpc(::media::remoting::pb::CdmSetServerCertificate* cdm_setservercertificate_rpc) {
  clear_rpc_oneof();
  if (cdm_setservercertificate_rpc) {
    set_has_cdm_setservercertificate_rpc();
    rpc_oneof_.cdm_setservercertificate_rpc_ = cdm_setservercertificate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_setservercertificate_rpc)
}

// optional .media.remoting.pb.CdmCreateSessionAndGenerateRequest cdm_createsessionandgeneraterequest_rpc = 502;
inline bool RpcMessage::has_cdm_createsessionandgeneraterequest_rpc() const {
  return rpc_oneof_case() == kCdmCreatesessionandgeneraterequestRpc;
}
inline void RpcMessage::set_has_cdm_createsessionandgeneraterequest_rpc() {
  _oneof_case_[0] = kCdmCreatesessionandgeneraterequestRpc;
}
inline void RpcMessage::clear_cdm_createsessionandgeneraterequest_rpc() {
  if (has_cdm_createsessionandgeneraterequest_rpc()) {
    delete rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmCreateSessionAndGenerateRequest& RpcMessage::cdm_createsessionandgeneraterequest_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  return has_cdm_createsessionandgeneraterequest_rpc()
      ? *rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_
      : ::media::remoting::pb::CdmCreateSessionAndGenerateRequest::default_instance();
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* RpcMessage::mutable_cdm_createsessionandgeneraterequest_rpc() {
  if (!has_cdm_createsessionandgeneraterequest_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_createsessionandgeneraterequest_rpc();
    rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_ = new ::media::remoting::pb::CdmCreateSessionAndGenerateRequest;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  return rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
}
inline ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* RpcMessage::release_cdm_createsessionandgeneraterequest_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
  if (has_cdm_createsessionandgeneraterequest_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmCreateSessionAndGenerateRequest* temp = rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_;
    rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_createsessionandgeneraterequest_rpc(::media::remoting::pb::CdmCreateSessionAndGenerateRequest* cdm_createsessionandgeneraterequest_rpc) {
  clear_rpc_oneof();
  if (cdm_createsessionandgeneraterequest_rpc) {
    set_has_cdm_createsessionandgeneraterequest_rpc();
    rpc_oneof_.cdm_createsessionandgeneraterequest_rpc_ = cdm_createsessionandgeneraterequest_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_createsessionandgeneraterequest_rpc)
}

// optional .media.remoting.pb.CdmLoadSession cdm_loadsession_rpc = 503;
inline bool RpcMessage::has_cdm_loadsession_rpc() const {
  return rpc_oneof_case() == kCdmLoadsessionRpc;
}
inline void RpcMessage::set_has_cdm_loadsession_rpc() {
  _oneof_case_[0] = kCdmLoadsessionRpc;
}
inline void RpcMessage::clear_cdm_loadsession_rpc() {
  if (has_cdm_loadsession_rpc()) {
    delete rpc_oneof_.cdm_loadsession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmLoadSession& RpcMessage::cdm_loadsession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  return has_cdm_loadsession_rpc()
      ? *rpc_oneof_.cdm_loadsession_rpc_
      : ::media::remoting::pb::CdmLoadSession::default_instance();
}
inline ::media::remoting::pb::CdmLoadSession* RpcMessage::mutable_cdm_loadsession_rpc() {
  if (!has_cdm_loadsession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_loadsession_rpc();
    rpc_oneof_.cdm_loadsession_rpc_ = new ::media::remoting::pb::CdmLoadSession;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  return rpc_oneof_.cdm_loadsession_rpc_;
}
inline ::media::remoting::pb::CdmLoadSession* RpcMessage::release_cdm_loadsession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
  if (has_cdm_loadsession_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmLoadSession* temp = rpc_oneof_.cdm_loadsession_rpc_;
    rpc_oneof_.cdm_loadsession_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_loadsession_rpc(::media::remoting::pb::CdmLoadSession* cdm_loadsession_rpc) {
  clear_rpc_oneof();
  if (cdm_loadsession_rpc) {
    set_has_cdm_loadsession_rpc();
    rpc_oneof_.cdm_loadsession_rpc_ = cdm_loadsession_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_loadsession_rpc)
}

// optional .media.remoting.pb.CdmUpdateSession cdm_updatesession_rpc = 504;
inline bool RpcMessage::has_cdm_updatesession_rpc() const {
  return rpc_oneof_case() == kCdmUpdatesessionRpc;
}
inline void RpcMessage::set_has_cdm_updatesession_rpc() {
  _oneof_case_[0] = kCdmUpdatesessionRpc;
}
inline void RpcMessage::clear_cdm_updatesession_rpc() {
  if (has_cdm_updatesession_rpc()) {
    delete rpc_oneof_.cdm_updatesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmUpdateSession& RpcMessage::cdm_updatesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  return has_cdm_updatesession_rpc()
      ? *rpc_oneof_.cdm_updatesession_rpc_
      : ::media::remoting::pb::CdmUpdateSession::default_instance();
}
inline ::media::remoting::pb::CdmUpdateSession* RpcMessage::mutable_cdm_updatesession_rpc() {
  if (!has_cdm_updatesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_updatesession_rpc();
    rpc_oneof_.cdm_updatesession_rpc_ = new ::media::remoting::pb::CdmUpdateSession;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  return rpc_oneof_.cdm_updatesession_rpc_;
}
inline ::media::remoting::pb::CdmUpdateSession* RpcMessage::release_cdm_updatesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
  if (has_cdm_updatesession_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmUpdateSession* temp = rpc_oneof_.cdm_updatesession_rpc_;
    rpc_oneof_.cdm_updatesession_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_updatesession_rpc(::media::remoting::pb::CdmUpdateSession* cdm_updatesession_rpc) {
  clear_rpc_oneof();
  if (cdm_updatesession_rpc) {
    set_has_cdm_updatesession_rpc();
    rpc_oneof_.cdm_updatesession_rpc_ = cdm_updatesession_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_updatesession_rpc)
}

// optional .media.remoting.pb.CdmCloseSession cdm_closesession_rpc = 505;
inline bool RpcMessage::has_cdm_closesession_rpc() const {
  return rpc_oneof_case() == kCdmClosesessionRpc;
}
inline void RpcMessage::set_has_cdm_closesession_rpc() {
  _oneof_case_[0] = kCdmClosesessionRpc;
}
inline void RpcMessage::clear_cdm_closesession_rpc() {
  if (has_cdm_closesession_rpc()) {
    delete rpc_oneof_.cdm_closesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmCloseSession& RpcMessage::cdm_closesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  return has_cdm_closesession_rpc()
      ? *rpc_oneof_.cdm_closesession_rpc_
      : ::media::remoting::pb::CdmCloseSession::default_instance();
}
inline ::media::remoting::pb::CdmCloseSession* RpcMessage::mutable_cdm_closesession_rpc() {
  if (!has_cdm_closesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_closesession_rpc();
    rpc_oneof_.cdm_closesession_rpc_ = new ::media::remoting::pb::CdmCloseSession;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  return rpc_oneof_.cdm_closesession_rpc_;
}
inline ::media::remoting::pb::CdmCloseSession* RpcMessage::release_cdm_closesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
  if (has_cdm_closesession_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmCloseSession* temp = rpc_oneof_.cdm_closesession_rpc_;
    rpc_oneof_.cdm_closesession_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_closesession_rpc(::media::remoting::pb::CdmCloseSession* cdm_closesession_rpc) {
  clear_rpc_oneof();
  if (cdm_closesession_rpc) {
    set_has_cdm_closesession_rpc();
    rpc_oneof_.cdm_closesession_rpc_ = cdm_closesession_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_closesession_rpc)
}

// optional .media.remoting.pb.CdmRemoveSession cdm_removesession_rpc = 506;
inline bool RpcMessage::has_cdm_removesession_rpc() const {
  return rpc_oneof_case() == kCdmRemovesessionRpc;
}
inline void RpcMessage::set_has_cdm_removesession_rpc() {
  _oneof_case_[0] = kCdmRemovesessionRpc;
}
inline void RpcMessage::clear_cdm_removesession_rpc() {
  if (has_cdm_removesession_rpc()) {
    delete rpc_oneof_.cdm_removesession_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmRemoveSession& RpcMessage::cdm_removesession_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  return has_cdm_removesession_rpc()
      ? *rpc_oneof_.cdm_removesession_rpc_
      : ::media::remoting::pb::CdmRemoveSession::default_instance();
}
inline ::media::remoting::pb::CdmRemoveSession* RpcMessage::mutable_cdm_removesession_rpc() {
  if (!has_cdm_removesession_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_removesession_rpc();
    rpc_oneof_.cdm_removesession_rpc_ = new ::media::remoting::pb::CdmRemoveSession;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  return rpc_oneof_.cdm_removesession_rpc_;
}
inline ::media::remoting::pb::CdmRemoveSession* RpcMessage::release_cdm_removesession_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
  if (has_cdm_removesession_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmRemoveSession* temp = rpc_oneof_.cdm_removesession_rpc_;
    rpc_oneof_.cdm_removesession_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_removesession_rpc(::media::remoting::pb::CdmRemoveSession* cdm_removesession_rpc) {
  clear_rpc_oneof();
  if (cdm_removesession_rpc) {
    set_has_cdm_removesession_rpc();
    rpc_oneof_.cdm_removesession_rpc_ = cdm_removesession_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_removesession_rpc)
}

// optional .media.remoting.pb.CdmPromise cdm_promise_rpc = 600;
inline bool RpcMessage::has_cdm_promise_rpc() const {
  return rpc_oneof_case() == kCdmPromiseRpc;
}
inline void RpcMessage::set_has_cdm_promise_rpc() {
  _oneof_case_[0] = kCdmPromiseRpc;
}
inline void RpcMessage::clear_cdm_promise_rpc() {
  if (has_cdm_promise_rpc()) {
    delete rpc_oneof_.cdm_promise_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmPromise& RpcMessage::cdm_promise_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  return has_cdm_promise_rpc()
      ? *rpc_oneof_.cdm_promise_rpc_
      : ::media::remoting::pb::CdmPromise::default_instance();
}
inline ::media::remoting::pb::CdmPromise* RpcMessage::mutable_cdm_promise_rpc() {
  if (!has_cdm_promise_rpc()) {
    clear_rpc_oneof();
    set_has_cdm_promise_rpc();
    rpc_oneof_.cdm_promise_rpc_ = new ::media::remoting::pb::CdmPromise;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  return rpc_oneof_.cdm_promise_rpc_;
}
inline ::media::remoting::pb::CdmPromise* RpcMessage::release_cdm_promise_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdm_promise_rpc)
  if (has_cdm_promise_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmPromise* temp = rpc_oneof_.cdm_promise_rpc_;
    rpc_oneof_.cdm_promise_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdm_promise_rpc(::media::remoting::pb::CdmPromise* cdm_promise_rpc) {
  clear_rpc_oneof();
  if (cdm_promise_rpc) {
    set_has_cdm_promise_rpc();
    rpc_oneof_.cdm_promise_rpc_ = cdm_promise_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdm_promise_rpc)
}

// optional .media.remoting.pb.CdmClientOnSessionMessage cdmclient_onsessionmessage_rpc = 601;
inline bool RpcMessage::has_cdmclient_onsessionmessage_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionmessageRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionmessage_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionmessageRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionmessage_rpc() {
  if (has_cdmclient_onsessionmessage_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionmessage_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmClientOnSessionMessage& RpcMessage::cdmclient_onsessionmessage_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  return has_cdmclient_onsessionmessage_rpc()
      ? *rpc_oneof_.cdmclient_onsessionmessage_rpc_
      : ::media::remoting::pb::CdmClientOnSessionMessage::default_instance();
}
inline ::media::remoting::pb::CdmClientOnSessionMessage* RpcMessage::mutable_cdmclient_onsessionmessage_rpc() {
  if (!has_cdmclient_onsessionmessage_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionmessage_rpc();
    rpc_oneof_.cdmclient_onsessionmessage_rpc_ = new ::media::remoting::pb::CdmClientOnSessionMessage;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  return rpc_oneof_.cdmclient_onsessionmessage_rpc_;
}
inline ::media::remoting::pb::CdmClientOnSessionMessage* RpcMessage::release_cdmclient_onsessionmessage_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
  if (has_cdmclient_onsessionmessage_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmClientOnSessionMessage* temp = rpc_oneof_.cdmclient_onsessionmessage_rpc_;
    rpc_oneof_.cdmclient_onsessionmessage_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdmclient_onsessionmessage_rpc(::media::remoting::pb::CdmClientOnSessionMessage* cdmclient_onsessionmessage_rpc) {
  clear_rpc_oneof();
  if (cdmclient_onsessionmessage_rpc) {
    set_has_cdmclient_onsessionmessage_rpc();
    rpc_oneof_.cdmclient_onsessionmessage_rpc_ = cdmclient_onsessionmessage_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdmclient_onsessionmessage_rpc)
}

// optional .media.remoting.pb.CdmClientOnSessionKeysChange cdmclient_onsessionkeychange_rpc = 602;
inline bool RpcMessage::has_cdmclient_onsessionkeychange_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionkeychangeRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionkeychange_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionkeychangeRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionkeychange_rpc() {
  if (has_cdmclient_onsessionkeychange_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmClientOnSessionKeysChange& RpcMessage::cdmclient_onsessionkeychange_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  return has_cdmclient_onsessionkeychange_rpc()
      ? *rpc_oneof_.cdmclient_onsessionkeychange_rpc_
      : ::media::remoting::pb::CdmClientOnSessionKeysChange::default_instance();
}
inline ::media::remoting::pb::CdmClientOnSessionKeysChange* RpcMessage::mutable_cdmclient_onsessionkeychange_rpc() {
  if (!has_cdmclient_onsessionkeychange_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionkeychange_rpc();
    rpc_oneof_.cdmclient_onsessionkeychange_rpc_ = new ::media::remoting::pb::CdmClientOnSessionKeysChange;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  return rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
}
inline ::media::remoting::pb::CdmClientOnSessionKeysChange* RpcMessage::release_cdmclient_onsessionkeychange_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
  if (has_cdmclient_onsessionkeychange_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmClientOnSessionKeysChange* temp = rpc_oneof_.cdmclient_onsessionkeychange_rpc_;
    rpc_oneof_.cdmclient_onsessionkeychange_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdmclient_onsessionkeychange_rpc(::media::remoting::pb::CdmClientOnSessionKeysChange* cdmclient_onsessionkeychange_rpc) {
  clear_rpc_oneof();
  if (cdmclient_onsessionkeychange_rpc) {
    set_has_cdmclient_onsessionkeychange_rpc();
    rpc_oneof_.cdmclient_onsessionkeychange_rpc_ = cdmclient_onsessionkeychange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdmclient_onsessionkeychange_rpc)
}

// optional .media.remoting.pb.CdmClientOnSessionExpirationUpdate cdmclient_onsessionexpirationupdate_rpc = 603;
inline bool RpcMessage::has_cdmclient_onsessionexpirationupdate_rpc() const {
  return rpc_oneof_case() == kCdmclientOnsessionexpirationupdateRpc;
}
inline void RpcMessage::set_has_cdmclient_onsessionexpirationupdate_rpc() {
  _oneof_case_[0] = kCdmclientOnsessionexpirationupdateRpc;
}
inline void RpcMessage::clear_cdmclient_onsessionexpirationupdate_rpc() {
  if (has_cdmclient_onsessionexpirationupdate_rpc()) {
    delete rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
    clear_has_rpc_oneof();
  }
}
inline  const ::media::remoting::pb::CdmClientOnSessionExpirationUpdate& RpcMessage::cdmclient_onsessionexpirationupdate_rpc() const {
  // @@protoc_insertion_point(field_get:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  return has_cdmclient_onsessionexpirationupdate_rpc()
      ? *rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_
      : ::media::remoting::pb::CdmClientOnSessionExpirationUpdate::default_instance();
}
inline ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* RpcMessage::mutable_cdmclient_onsessionexpirationupdate_rpc() {
  if (!has_cdmclient_onsessionexpirationupdate_rpc()) {
    clear_rpc_oneof();
    set_has_cdmclient_onsessionexpirationupdate_rpc();
    rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_ = new ::media::remoting::pb::CdmClientOnSessionExpirationUpdate;
  }
  // @@protoc_insertion_point(field_mutable:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  return rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
}
inline ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* RpcMessage::release_cdmclient_onsessionexpirationupdate_rpc() {
  // @@protoc_insertion_point(field_release:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
  if (has_cdmclient_onsessionexpirationupdate_rpc()) {
    clear_has_rpc_oneof();
    ::media::remoting::pb::CdmClientOnSessionExpirationUpdate* temp = rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_;
    rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RpcMessage::set_allocated_cdmclient_onsessionexpirationupdate_rpc(::media::remoting::pb::CdmClientOnSessionExpirationUpdate* cdmclient_onsessionexpirationupdate_rpc) {
  clear_rpc_oneof();
  if (cdmclient_onsessionexpirationupdate_rpc) {
    set_has_cdmclient_onsessionexpirationupdate_rpc();
    rpc_oneof_.cdmclient_onsessionexpirationupdate_rpc_ = cdmclient_onsessionexpirationupdate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:media.remoting.pb.RpcMessage.cdmclient_onsessionexpirationupdate_rpc)
}

inline bool RpcMessage::has_rpc_oneof() const {
  return rpc_oneof_case() != RPC_ONEOF_NOT_SET;
}
inline void RpcMessage::clear_has_rpc_oneof() {
  _oneof_case_[0] = RPC_ONEOF_NOT_SET;
}
inline RpcMessage::RpcOneofCase RpcMessage::rpc_oneof_case() const {
  return RpcMessage::RpcOneofCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace pb
}  // namespace remoting
}  // namespace media

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::media::remoting::pb::EncryptionScheme_CipherMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_Codec> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_SampleFormat> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::AudioDecoderConfig_ChannelLayout> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Codec> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Profile> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_Format> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::VideoDecoderConfig_ColorSpace> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmKeyInformation_KeyStatus> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::RendererClientOnBufferingStateChange_State> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::DemuxerStreamReadUntilCallback_Status> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmCreateSessionAndGenerateRequest_EmeInitDataType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::RpcMessage_RpcProc> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::EncryptionMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmException> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmMessageType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::media::remoting::pb::CdmSessionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_rpc_2eproto__INCLUDED
