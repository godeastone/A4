//
// DO NOT MODIFY THIS FILE DIRECTLY!
// IT IS GENERATED BY generate_policy_source.py
// FROM ../../components/policy/resources/policy_templates.json
//


#include <limits>
#include <memory>
#include <utility>
#include <string>

#include "base/callback.h"
#include "base/json/json_reader.h"
#include "base/logging.h"
#include "base/memory/ptr_util.h"
#include "base/memory/weak_ptr.h"
#include "base/values.h"
#include "components/policy/core/common/cloud/cloud_external_data_manager.h"
#include "components/policy/core/common/external_data_fetcher.h"
#include "components/policy/core/common/policy_map.h"
#include "components/policy/core/common/policy_types.h"
#include "components/policy/policy_constants.h"
#include "components/policy/proto/cloud_policy.pb.h"

using google::protobuf::RepeatedPtrField;

namespace policy {

namespace em = enterprise_management;

std::unique_ptr<base::Value> DecodeIntegerValue(
    google::protobuf::int64 value) {
  if (value < std::numeric_limits<int>::min() ||
      value > std::numeric_limits<int>::max()) {
    LOG(WARNING) << "Integer value " << value
                 << " out of numeric limits, ignoring.";
    return nullptr;
  }

  return base::WrapUnique(
      new base::Value(static_cast<int>(value)));
}

std::unique_ptr<base::ListValue> DecodeStringList(
    const em::StringList& string_list) {
  std::unique_ptr<base::ListValue> list_value(new base::ListValue);
  for (const auto& entry : string_list.entries())
    list_value->AppendString(entry);
  return list_value;
}

std::unique_ptr<base::Value> DecodeJson(const std::string& json) {
  std::unique_ptr<base::Value> root =
      base::JSONReader::Read(json, base::JSON_ALLOW_TRAILING_COMMAS);

  if (!root)
    LOG(WARNING) << "Invalid JSON string, ignoring: " << json;

  // Accept any Value type that parsed as JSON, and leave it to the handler to
  // convert and check the concrete type.
  return root;
}

void DecodePolicy(const em::CloudPolicySettings& policy,
                  base::WeakPtr<CloudExternalDataManager> external_data_manager,
                  PolicyMap* map,
                  PolicyScope scope) {
  if (policy.has_homepagelocation()) {
    const em::StringPolicyProto& policy_proto = policy.homepagelocation();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kHomepageLocation, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_homepageisnewtabpage()) {
    const em::BooleanPolicyProto& policy_proto = policy.homepageisnewtabpage();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kHomepageIsNewTabPage, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_newtabpagelocation()) {
    const em::StringPolicyProto& policy_proto = policy.newtabpagelocation();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNewTabPageLocation, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultbrowsersettingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.defaultbrowsersettingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultBrowserSettingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_alternateerrorpagesenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.alternateerrorpagesenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAlternateErrorPagesEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_searchsuggestenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.searchsuggestenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSearchSuggestEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_networkpredictionoptions()) {
    const em::IntegerPolicyProto& policy_proto = policy.networkpredictionoptions();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNetworkPredictionOptions, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_wpadquickcheckenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.wpadquickcheckenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWPADQuickCheckEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disabledschemes()) {
    const em::StringListPolicyProto& policy_proto = policy.disabledschemes();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisabledSchemes, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_http09onnondefaultportsenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.http09onnondefaultportsenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kHttp09OnNonDefaultPortsEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.javascriptenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavascriptEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_incognitoenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.incognitoenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIncognitoEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_incognitomodeavailability()) {
    const em::IntegerPolicyProto& policy_proto = policy.incognitomodeavailability();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIncognitoModeAvailability, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_savingbrowserhistorydisabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.savingbrowserhistorydisabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSavingBrowserHistoryDisabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_allowdeletingbrowserhistory()) {
    const em::BooleanPolicyProto& policy_proto = policy.allowdeletingbrowserhistory();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowDeletingBrowserHistory, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_allowdinosaureasteregg()) {
    const em::BooleanPolicyProto& policy_proto = policy.allowdinosaureasteregg();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowDinosaurEasterEgg, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostclientdomain()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshostclientdomain();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostClientDomain, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostclientdomainlist()) {
    const em::StringListPolicyProto& policy_proto = policy.remoteaccesshostclientdomainlist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostClientDomainList, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostfirewalltraversal()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostfirewalltraversal();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostFirewallTraversal, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostdomain()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshostdomain();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostDomain, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostdomainlist()) {
    const em::StringListPolicyProto& policy_proto = policy.remoteaccesshostdomainlist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostDomainList, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshosttalkgadgetprefix()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshosttalkgadgetprefix();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostTalkGadgetPrefix, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostrequirecurtain()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostrequirecurtain();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostRequireCurtain, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostallowclientpairing()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostallowclientpairing();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostAllowClientPairing, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostallowgnubbyauth()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostallowgnubbyauth();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostAllowGnubbyAuth, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostallowrelayedconnection()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostallowrelayedconnection();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostAllowRelayedConnection, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostudpportrange()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshostudpportrange();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostUdpPortRange, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshostmatchusername()) {
    const em::BooleanPolicyProto& policy_proto = policy.remoteaccesshostmatchusername();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostMatchUsername, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshosttokenurl()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshosttokenurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostTokenUrl, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshosttokenvalidationurl()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshosttokenvalidationurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostTokenValidationUrl, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_remoteaccesshosttokenvalidationcertificateissuer()) {
    const em::StringPolicyProto& policy_proto = policy.remoteaccesshosttokenvalidationcertificateissuer();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRemoteAccessHostTokenValidationCertificateIssuer, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_printingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.printingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPrintingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cloudprintproxyenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.cloudprintproxyenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCloudPrintProxyEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forcesafesearch()) {
    const em::BooleanPolicyProto& policy_proto = policy.forcesafesearch();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceSafeSearch, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forcegooglesafesearch()) {
    const em::BooleanPolicyProto& policy_proto = policy.forcegooglesafesearch();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceGoogleSafeSearch, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forceyoutubesafetymode()) {
    const em::BooleanPolicyProto& policy_proto = policy.forceyoutubesafetymode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceYouTubeSafetyMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forceyoutuberestrict()) {
    const em::IntegerPolicyProto& policy_proto = policy.forceyoutuberestrict();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceYouTubeRestrict, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_safebrowsingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.safebrowsingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSafeBrowsingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_metricsreportingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.metricsreportingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMetricsReportingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_passwordmanagerenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.passwordmanagerenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPasswordManagerEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autofillenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.autofillenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutoFillEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autofillcreditcardenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.autofillcreditcardenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutofillCreditCardEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disabledplugins()) {
    const em::StringListPolicyProto& policy_proto = policy.disabledplugins();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisabledPlugins, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enabledplugins()) {
    const em::StringListPolicyProto& policy_proto = policy.enabledplugins();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnabledPlugins, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disabledpluginsexceptions()) {
    const em::StringListPolicyProto& policy_proto = policy.disabledpluginsexceptions();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisabledPluginsExceptions, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_alwaysopenpdfexternally()) {
    const em::BooleanPolicyProto& policy_proto = policy.alwaysopenpdfexternally();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAlwaysOpenPdfExternally, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_syncdisabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.syncdisabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSyncDisabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_signinallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.signinallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSigninAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_diskcachedir()) {
    const em::StringPolicyProto& policy_proto = policy.diskcachedir();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDiskCacheDir, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_diskcachesize()) {
    const em::IntegerPolicyProto& policy_proto = policy.diskcachesize();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDiskCacheSize, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_mediacachesize()) {
    const em::IntegerPolicyProto& policy_proto = policy.mediacachesize();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMediaCacheSize, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_downloadrestrictions()) {
    const em::IntegerPolicyProto& policy_proto = policy.downloadrestrictions();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDownloadRestrictions, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_downloaddirectory()) {
    const em::StringPolicyProto& policy_proto = policy.downloaddirectory();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDownloadDirectory, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxymode()) {
    const em::StringPolicyProto& policy_proto = policy.proxymode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxyservermode()) {
    const em::IntegerPolicyProto& policy_proto = policy.proxyservermode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyServerMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxyserver()) {
    const em::StringPolicyProto& policy_proto = policy.proxyserver();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyServer, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxypacurl()) {
    const em::StringPolicyProto& policy_proto = policy.proxypacurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyPacUrl, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxybypasslist()) {
    const em::StringPolicyProto& policy_proto = policy.proxybypasslist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxyBypassList, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_proxysettings()) {
    const em::StringPolicyProto& policy_proto = policy.proxysettings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kProxySettings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authschemes()) {
    const em::StringPolicyProto& policy_proto = policy.authschemes();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthSchemes, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disableauthnegotiatecnamelookup()) {
    const em::BooleanPolicyProto& policy_proto = policy.disableauthnegotiatecnamelookup();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisableAuthNegotiateCnameLookup, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enableauthnegotiateport()) {
    const em::BooleanPolicyProto& policy_proto = policy.enableauthnegotiateport();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableAuthNegotiatePort, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authserverwhitelist()) {
    const em::StringPolicyProto& policy_proto = policy.authserverwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthServerWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_authnegotiatedelegatewhitelist()) {
    const em::StringPolicyProto& policy_proto = policy.authnegotiatedelegatewhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAuthNegotiateDelegateWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_gssapilibraryname()) {
    const em::StringPolicyProto& policy_proto = policy.gssapilibraryname();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kGSSAPILibraryName, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_allowcrossoriginauthprompt()) {
    const em::BooleanPolicyProto& policy_proto = policy.allowcrossoriginauthprompt();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowCrossOriginAuthPrompt, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_ntlmv2enabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.ntlmv2enabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNtlmV2Enabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallblacklist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallblacklist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallBlacklist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallwhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallforcelist()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallforcelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallForcelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensioninstallsources()) {
    const em::StringListPolicyProto& policy_proto = policy.extensioninstallsources();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionInstallSources, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensionallowedtypes()) {
    const em::StringListPolicyProto& policy_proto = policy.extensionallowedtypes();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionAllowedTypes, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_extensionsettings()) {
    const em::StringPolicyProto& policy_proto = policy.extensionsettings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kExtensionSettings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_showhomebutton()) {
    const em::BooleanPolicyProto& policy_proto = policy.showhomebutton();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kShowHomeButton, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_developertoolsdisabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.developertoolsdisabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDeveloperToolsDisabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_developertoolsavailability()) {
    const em::IntegerPolicyProto& policy_proto = policy.developertoolsavailability();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDeveloperToolsAvailability, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_restoreonstartup()) {
    const em::IntegerPolicyProto& policy_proto = policy.restoreonstartup();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRestoreOnStartup, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_restoreonstartupurls()) {
    const em::StringListPolicyProto& policy_proto = policy.restoreonstartupurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRestoreOnStartupURLs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_blockthirdpartycookies()) {
    const em::BooleanPolicyProto& policy_proto = policy.blockthirdpartycookies();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBlockThirdPartyCookies, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.defaultsearchproviderenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidername()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidername();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderName, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderkeyword()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderkeyword();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderKeyword, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersearchurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSearchURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersuggesturl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSuggestURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidericonurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidericonurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderIconURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderencodings()) {
    const em::StringListPolicyProto& policy_proto = policy.defaultsearchproviderencodings();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderEncodings, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovideralternateurls()) {
    const em::StringListPolicyProto& policy_proto = policy.defaultsearchprovideralternateurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderAlternateURLs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderimageurl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderImageURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidernewtaburl()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidernewtaburl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderNewTabURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersearchurlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersearchurlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSearchURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchprovidersuggesturlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchprovidersuggesturlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderSuggestURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultsearchproviderimageurlpostparams()) {
    const em::StringPolicyProto& policy_proto = policy.defaultsearchproviderimageurlpostparams();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultSearchProviderImageURLPostParams, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultcookiessetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultcookiessetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultCookiesSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultimagessetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultimagessetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultImagesSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultjavascriptsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultjavascriptsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultJavaScriptSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultpluginssetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultpluginssetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultPluginsSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultpopupssetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultpopupssetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultPopupsSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultnotificationssetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultnotificationssetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultNotificationsSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultgeolocationsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultgeolocationsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultGeolocationSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultmediastreamsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultmediastreamsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultMediaStreamSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultwebbluetoothguardsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultwebbluetoothguardsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultWebBluetoothGuardSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultwebusbguardsetting()) {
    const em::IntegerPolicyProto& policy_proto = policy.defaultwebusbguardsetting();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultWebUsbGuardSetting, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webusbaskforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.webusbaskforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebUsbAskForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webusbblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.webusbblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebUsbBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autoselectcertificateforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.autoselectcertificateforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutoSelectCertificateForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiesallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiesallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiesblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiesblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cookiessessiononlyforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.cookiessessiononlyforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCookiesSessionOnlyForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_imagesallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.imagesallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImagesAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_imagesblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.imagesblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImagesBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.javascriptallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavaScriptAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_javascriptblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.javascriptblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kJavaScriptBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_pluginsallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.pluginsallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPluginsAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_pluginsblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.pluginsblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPluginsBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_popupsallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.popupsallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPopupsAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_registeredprotocolhandlers()) {
    const em::StringPolicyProto& policy_proto = policy.registeredprotocolhandlers();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRegisteredProtocolHandlers, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_popupsblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.popupsblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPopupsBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_notificationsallowedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.notificationsallowedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNotificationsAllowedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_notificationsblockedforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.notificationsblockedforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNotificationsBlockedForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_nativemessagingblacklist()) {
    const em::StringListPolicyProto& policy_proto = policy.nativemessagingblacklist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNativeMessagingBlacklist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_nativemessagingwhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.nativemessagingwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNativeMessagingWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_nativemessaginguserlevelhosts()) {
    const em::BooleanPolicyProto& policy_proto = policy.nativemessaginguserlevelhosts();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kNativeMessagingUserLevelHosts, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disable3dapis()) {
    const em::BooleanPolicyProto& policy_proto = policy.disable3dapis();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisable3DAPIs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_maxinvalidationfetchdelay()) {
    const em::IntegerPolicyProto& policy_proto = policy.maxinvalidationfetchdelay();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMaxInvalidationFetchDelay, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_translateenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.translateenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kTranslateEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_allowoutdatedplugins()) {
    const em::BooleanPolicyProto& policy_proto = policy.allowoutdatedplugins();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowOutdatedPlugins, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_runallflashinallowmode()) {
    const em::BooleanPolicyProto& policy_proto = policy.runallflashinallowmode();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRunAllFlashInAllowMode, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_bookmarkbarenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.bookmarkbarenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBookmarkBarEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_editbookmarksenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.editbookmarksenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEditBookmarksEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_showappsshortcutinbookmarkbar()) {
    const em::BooleanPolicyProto& policy_proto = policy.showappsshortcutinbookmarkbar();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kShowAppsShortcutInBookmarkBar, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_allowfileselectiondialogs()) {
    const em::BooleanPolicyProto& policy_proto = policy.allowfileselectiondialogs();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowFileSelectionDialogs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_securitykeypermitattestation()) {
    const em::StringListPolicyProto& policy_proto = policy.securitykeypermitattestation();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSecurityKeyPermitAttestation, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importbookmarks()) {
    const em::BooleanPolicyProto& policy_proto = policy.importbookmarks();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportBookmarks, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importhistory()) {
    const em::BooleanPolicyProto& policy_proto = policy.importhistory();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportHistory, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importhomepage()) {
    const em::BooleanPolicyProto& policy_proto = policy.importhomepage();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportHomepage, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importsearchengine()) {
    const em::BooleanPolicyProto& policy_proto = policy.importsearchengine();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportSearchEngine, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importsavedpasswords()) {
    const em::BooleanPolicyProto& policy_proto = policy.importsavedpasswords();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportSavedPasswords, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_importautofillformdata()) {
    const em::BooleanPolicyProto& policy_proto = policy.importautofillformdata();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kImportAutofillFormData, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_maxconnectionsperproxy()) {
    const em::IntegerPolicyProto& policy_proto = policy.maxconnectionsperproxy();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMaxConnectionsPerProxy, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_urlblacklist()) {
    const em::StringListPolicyProto& policy_proto = policy.urlblacklist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kURLBlacklist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_urlwhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.urlwhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kURLWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cloudprintsubmitenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.cloudprintsubmitenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCloudPrintSubmitEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disableprintpreview()) {
    const em::BooleanPolicyProto& policy_proto = policy.disableprintpreview();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisablePrintPreview, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultprinterselection()) {
    const em::StringPolicyProto& policy_proto = policy.defaultprinterselection();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultPrinterSelection, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enableonlinerevocationchecks()) {
    const em::BooleanPolicyProto& policy_proto = policy.enableonlinerevocationchecks();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableOnlineRevocationChecks, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_requireonlinerevocationchecksforlocalanchors()) {
    const em::BooleanPolicyProto& policy_proto = policy.requireonlinerevocationchecksforlocalanchors();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRequireOnlineRevocationChecksForLocalAnchors, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablesha1forlocalanchors()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablesha1forlocalanchors();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableSha1ForLocalAnchors, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablesymanteclegacyinfrastructure()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablesymanteclegacyinfrastructure();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableSymantecLegacyInfrastructure, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_forceephemeralprofiles()) {
    const em::BooleanPolicyProto& policy_proto = policy.forceephemeralprofiles();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kForceEphemeralProfiles, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_backgroundmodeenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.backgroundmodeenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBackgroundModeEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_restrictsignintopattern()) {
    const em::StringPolicyProto& policy_proto = policy.restrictsignintopattern();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRestrictSigninToPattern, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disablesafebrowsingproceedanyway()) {
    const em::BooleanPolicyProto& policy_proto = policy.disablesafebrowsingproceedanyway();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisableSafeBrowsingProceedAnyway, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_safebrowsingextendedreportingoptinallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.safebrowsingextendedreportingoptinallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSafeBrowsingExtendedReportingOptInAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_spellcheckserviceenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.spellcheckserviceenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSpellCheckServiceEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_audiocaptureallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.audiocaptureallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAudioCaptureAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_audiocaptureallowedurls()) {
    const em::StringListPolicyProto& policy_proto = policy.audiocaptureallowedurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAudioCaptureAllowedUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_videocaptureallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.videocaptureallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kVideoCaptureAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_videocaptureallowedurls()) {
    const em::StringListPolicyProto& policy_proto = policy.videocaptureallowedurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kVideoCaptureAllowedUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_disablescreenshots()) {
    const em::BooleanPolicyProto& policy_proto = policy.disablescreenshots();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDisableScreenshots, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_builtindnsclientenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.builtindnsclientenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBuiltInDnsClientEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_fullscreenallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.fullscreenallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kFullscreenAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_hidewebstoreicon()) {
    const em::BooleanPolicyProto& policy_proto = policy.hidewebstoreicon();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kHideWebStoreIcon, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_variationsrestrictparameter()) {
    const em::StringPolicyProto& policy_proto = policy.variationsrestrictparameter();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kVariationsRestrictParameter, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_contentpackdefaultfilteringbehavior()) {
    const em::IntegerPolicyProto& policy_proto = policy.contentpackdefaultfilteringbehavior();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kContentPackDefaultFilteringBehavior, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_contentpackmanualbehaviorhosts()) {
    const em::StringPolicyProto& policy_proto = policy.contentpackmanualbehaviorhosts();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kContentPackManualBehaviorHosts, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_contentpackmanualbehaviorurls()) {
    const em::StringPolicyProto& policy_proto = policy.contentpackmanualbehaviorurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kContentPackManualBehaviorURLs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_supervisedusercreationenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.supervisedusercreationenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSupervisedUserCreationEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_managedbookmarks()) {
    const em::StringPolicyProto& policy_proto = policy.managedbookmarks();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeJson(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kManagedBookmarks, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enabledeprecatedwebplatformfeatures()) {
    const em::StringListPolicyProto& policy_proto = policy.enabledeprecatedwebplatformfeatures();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableDeprecatedWebPlatformFeatures, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_browserguestmodeenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.browserguestmodeenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBrowserGuestModeEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_browseraddpersonenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.browseraddpersonenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBrowserAddPersonEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslversionmin()) {
    const em::StringPolicyProto& policy_proto = policy.sslversionmin();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLVersionMin, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslversionmax()) {
    const em::StringPolicyProto& policy_proto = policy.sslversionmax();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLVersionMax, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforurls()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForUrls, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforcas()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforcas();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForCas, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_certificatetransparencyenforcementdisabledforlegacycas()) {
    const em::StringListPolicyProto& policy_proto = policy.certificatetransparencyenforcementdisabledforlegacycas();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCertificateTransparencyEnforcementDisabledForLegacyCas, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_sslerroroverrideallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.sslerroroverrideallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSSLErrorOverrideAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_quicallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.quicallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kQuicAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_hardwareaccelerationmodeenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.hardwareaccelerationmodeenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kHardwareAccelerationModeEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_suppressunsupportedoswarning()) {
    const em::BooleanPolicyProto& policy_proto = policy.suppressunsupportedoswarning();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSuppressUnsupportedOSWarning, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_taskmanagerendprocessenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.taskmanagerendprocessenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kTaskManagerEndProcessEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_alloweddomainsforapps()) {
    const em::StringPolicyProto& policy_proto = policy.alloweddomainsforapps();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAllowedDomainsForApps, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_pachttpsurlstrippingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.pachttpsurlstrippingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPacHttpsUrlStrippingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_enablemediarouter()) {
    const em::BooleanPolicyProto& policy_proto = policy.enablemediarouter();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kEnableMediaRouter, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_showcasticonintoolbar()) {
    const em::BooleanPolicyProto& policy_proto = policy.showcasticonintoolbar();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kShowCastIconInToolbar, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_mediaroutercastallowallips()) {
    const em::BooleanPolicyProto& policy_proto = policy.mediaroutercastallowallips();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMediaRouterCastAllowAllIPs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webrtcudpportrange()) {
    const em::StringPolicyProto& policy_proto = policy.webrtcudpportrange();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebRtcUdpPortRange, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_componentupdatesenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.componentupdatesenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kComponentUpdatesEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_browsernetworktimequeriesenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.browsernetworktimequeriesenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kBrowserNetworkTimeQueriesEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_printpreviewusesystemdefaultprinter()) {
    const em::BooleanPolicyProto& policy_proto = policy.printpreviewusesystemdefaultprinter();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPrintPreviewUseSystemDefaultPrinter, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_cloudpolicyoverridesmachinepolicy()) {
    const em::BooleanPolicyProto& policy_proto = policy.cloudpolicyoverridesmachinepolicy();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kCloudPolicyOverridesMachinePolicy, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_promptfordownloadlocation()) {
    const em::BooleanPolicyProto& policy_proto = policy.promptfordownloadlocation();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPromptForDownloadLocation, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_isolateorigins()) {
    const em::StringPolicyProto& policy_proto = policy.isolateorigins();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kIsolateOrigins, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_siteperprocess()) {
    const em::BooleanPolicyProto& policy_proto = policy.siteperprocess();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSitePerProcess, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_webdriveroverridesincompatiblepolicies()) {
    const em::BooleanPolicyProto& policy_proto = policy.webdriveroverridesincompatiblepolicies();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kWebDriverOverridesIncompatiblePolicies, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_unsafelytreatinsecureoriginassecure()) {
    const em::StringListPolicyProto& policy_proto = policy.unsafelytreatinsecureoriginassecure();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kUnsafelyTreatInsecureOriginAsSecure, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_defaultdownloaddirectory()) {
    const em::StringPolicyProto& policy_proto = policy.defaultdownloaddirectory();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kDefaultDownloadDirectory, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_abusiveexperienceinterventionenforce()) {
    const em::BooleanPolicyProto& policy_proto = policy.abusiveexperienceinterventionenforce();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAbusiveExperienceInterventionEnforce, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_spellchecklanguage()) {
    const em::StringListPolicyProto& policy_proto = policy.spellchecklanguage();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSpellcheckLanguage, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_spellcheckenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.spellcheckenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSpellcheckEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_adssettingforintrusiveadssites()) {
    const em::IntegerPolicyProto& policy_proto = policy.adssettingforintrusiveadssites();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAdsSettingForIntrusiveAdsSites, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_passwordprotectionwarningtrigger()) {
    const em::IntegerPolicyProto& policy_proto = policy.passwordprotectionwarningtrigger();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPasswordProtectionWarningTrigger, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_relaunchnotification()) {
    const em::IntegerPolicyProto& policy_proto = policy.relaunchnotification();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRelaunchNotification, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_relaunchnotificationperiod()) {
    const em::IntegerPolicyProto& policy_proto = policy.relaunchnotificationperiod();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeIntegerValue(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kRelaunchNotificationPeriod, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_safebrowsingwhitelistdomains()) {
    const em::StringListPolicyProto& policy_proto = policy.safebrowsingwhitelistdomains();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSafeBrowsingWhitelistDomains, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_passwordprotectionloginurls()) {
    const em::StringListPolicyProto& policy_proto = policy.passwordprotectionloginurls();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPasswordProtectionLoginURLs, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_passwordprotectionchangepasswordurl()) {
    const em::StringPolicyProto& policy_proto = policy.passwordprotectionchangepasswordurl();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kPasswordProtectionChangePasswordURL, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_safebrowsingextendedreportingenabled()) {
    const em::BooleanPolicyProto& policy_proto = policy.safebrowsingextendedreportingenabled();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kSafeBrowsingExtendedReportingEnabled, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_machinelevelusercloudpolicyenrollmenttoken()) {
    const em::StringPolicyProto& policy_proto = policy.machinelevelusercloudpolicyenrollmenttoken();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kMachineLevelUserCloudPolicyEnrollmentToken, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autoplayallowed()) {
    const em::BooleanPolicyProto& policy_proto = policy.autoplayallowed();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(new base::Value(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutoplayAllowed, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
  if (policy.has_autoplaywhitelist()) {
    const em::StringListPolicyProto& policy_proto = policy.autoplaywhitelist();
    if (policy_proto.has_value()) {
      PolicyLevel level = POLICY_LEVEL_MANDATORY;
      bool do_set = true;
      if (policy_proto.has_policy_options()) {
        do_set = false;
        switch(policy_proto.policy_options().mode()) {
          case em::PolicyOptions::MANDATORY:
            do_set = true;
            level = POLICY_LEVEL_MANDATORY;
            break;
          case em::PolicyOptions::RECOMMENDED:
            do_set = true;
            level = POLICY_LEVEL_RECOMMENDED;
            break;
          case em::PolicyOptions::UNSET:
            break;
        }
      }
      if (do_set) {
        std::unique_ptr<base::Value> value(DecodeStringList(policy_proto.value()));
        if (value) {
          std::unique_ptr<ExternalDataFetcher>
              external_data_fetcher(nullptr);
          map->Set(key::kAutoplayWhitelist, 
                   level, 
                   scope, 
                   POLICY_SOURCE_CLOUD, 
                   std::move(value), 
                   std::move(external_data_fetcher));
        }
      }
    }
  }
}

}  // namespace policy
