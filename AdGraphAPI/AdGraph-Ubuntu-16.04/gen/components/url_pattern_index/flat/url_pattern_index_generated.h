// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_
#define FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_

#include "flatbuffers/flatbuffers.h"

namespace url_pattern_index {
namespace flat {

struct UrlRule;

struct NGramToRules;

struct UrlPatternIndex;

enum UrlPatternType {
  UrlPatternType_SUBSTRING = 0,
  UrlPatternType_WILDCARDED = 1,
  UrlPatternType_REGEXP = 2,
  UrlPatternType_MIN = UrlPatternType_SUBSTRING,
  UrlPatternType_MAX = UrlPatternType_REGEXP
};

inline const char **EnumNamesUrlPatternType() {
  static const char *names[] = {
    "SUBSTRING",
    "WILDCARDED",
    "REGEXP",
    nullptr
  };
  return names;
}

inline const char *EnumNameUrlPatternType(UrlPatternType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesUrlPatternType()[index];
}

enum AnchorType {
  AnchorType_NONE = 0,
  AnchorType_BOUNDARY = 1,
  AnchorType_SUBDOMAIN = 2,
  AnchorType_MIN = AnchorType_NONE,
  AnchorType_MAX = AnchorType_SUBDOMAIN
};

inline const char **EnumNamesAnchorType() {
  static const char *names[] = {
    "NONE",
    "BOUNDARY",
    "SUBDOMAIN",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnchorType(AnchorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnchorType()[index];
}

enum OptionFlag {
  OptionFlag_IS_WHITELIST = 1,
  OptionFlag_APPLIES_TO_FIRST_PARTY = 2,
  OptionFlag_APPLIES_TO_THIRD_PARTY = 4,
  OptionFlag_IS_MATCH_CASE = 8,
  OptionFlag_NONE = 0,
  OptionFlag_ANY = 15
};

inline const char **EnumNamesOptionFlag() {
  static const char *names[] = {
    "IS_WHITELIST",
    "APPLIES_TO_FIRST_PARTY",
    "",
    "APPLIES_TO_THIRD_PARTY",
    "",
    "",
    "",
    "IS_MATCH_CASE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOptionFlag(OptionFlag e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(OptionFlag_IS_WHITELIST);
  return EnumNamesOptionFlag()[index];
}

enum ActivationType {
  ActivationType_DOCUMENT = 1,
  ActivationType_GENERIC_BLOCK = 2,
  ActivationType_NONE = 0,
  ActivationType_ANY = 3
};

inline const char **EnumNamesActivationType() {
  static const char *names[] = {
    "DOCUMENT",
    "GENERIC_BLOCK",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(ActivationType_DOCUMENT);
  return EnumNamesActivationType()[index];
}

enum ElementType {
  ElementType_OTHER = 1,
  ElementType_SCRIPT = 2,
  ElementType_IMAGE = 4,
  ElementType_STYLESHEET = 8,
  ElementType_OBJECT = 16,
  ElementType_XMLHTTPREQUEST = 32,
  ElementType_OBJECT_SUBREQUEST = 64,
  ElementType_SUBDOCUMENT = 128,
  ElementType_PING = 256,
  ElementType_MEDIA = 512,
  ElementType_FONT = 1024,
  ElementType_WEBSOCKET = 2048,
  ElementType_CSP_REPORT = 4096,
  ElementType_MAIN_FRAME = 8192,
  ElementType_NONE = 0,
  ElementType_ANY = 16383
};

struct UrlRule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OPTIONS = 4,
    VT_ELEMENT_TYPES = 6,
    VT_ACTIVATION_TYPES = 8,
    VT_URL_PATTERN_TYPE = 10,
    VT_ANCHOR_LEFT = 12,
    VT_ANCHOR_RIGHT = 14,
    VT_DOMAINS_INCLUDED = 16,
    VT_DOMAINS_EXCLUDED = 18,
    VT_URL_PATTERN = 20,
    VT_ID = 22,
    VT_PRIORITY = 24
  };
  uint8_t options() const {
    return GetField<uint8_t>(VT_OPTIONS, 0);
  }
  uint16_t element_types() const {
    return GetField<uint16_t>(VT_ELEMENT_TYPES, 8191);
  }
  uint8_t activation_types() const {
    return GetField<uint8_t>(VT_ACTIVATION_TYPES, 0);
  }
  UrlPatternType url_pattern_type() const {
    return static_cast<UrlPatternType>(GetField<uint8_t>(VT_URL_PATTERN_TYPE, 0));
  }
  AnchorType anchor_left() const {
    return static_cast<AnchorType>(GetField<uint8_t>(VT_ANCHOR_LEFT, 0));
  }
  AnchorType anchor_right() const {
    return static_cast<AnchorType>(GetField<uint8_t>(VT_ANCHOR_RIGHT, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *domains_included() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOMAINS_INCLUDED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *domains_excluded() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DOMAINS_EXCLUDED);
  }
  const flatbuffers::String *url_pattern() const {
    return GetPointer<const flatbuffers::String *>(VT_URL_PATTERN);
  }
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  uint32_t priority() const {
    return GetField<uint32_t>(VT_PRIORITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPTIONS) &&
           VerifyField<uint16_t>(verifier, VT_ELEMENT_TYPES) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVATION_TYPES) &&
           VerifyField<uint8_t>(verifier, VT_URL_PATTERN_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR_LEFT) &&
           VerifyField<uint8_t>(verifier, VT_ANCHOR_RIGHT) &&
           VerifyOffset(verifier, VT_DOMAINS_INCLUDED) &&
           verifier.Verify(domains_included()) &&
           verifier.VerifyVectorOfStrings(domains_included()) &&
           VerifyOffset(verifier, VT_DOMAINS_EXCLUDED) &&
           verifier.Verify(domains_excluded()) &&
           verifier.VerifyVectorOfStrings(domains_excluded()) &&
           VerifyOffset(verifier, VT_URL_PATTERN) &&
           verifier.Verify(url_pattern()) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_PRIORITY) &&
           verifier.EndTable();
  }
};

struct UrlRuleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_options(uint8_t options) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_OPTIONS, options, 0);
  }
  void add_element_types(uint16_t element_types) {
    fbb_.AddElement<uint16_t>(UrlRule::VT_ELEMENT_TYPES, element_types, 8191);
  }
  void add_activation_types(uint8_t activation_types) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ACTIVATION_TYPES, activation_types, 0);
  }
  void add_url_pattern_type(UrlPatternType url_pattern_type) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_URL_PATTERN_TYPE, static_cast<uint8_t>(url_pattern_type), 0);
  }
  void add_anchor_left(AnchorType anchor_left) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ANCHOR_LEFT, static_cast<uint8_t>(anchor_left), 0);
  }
  void add_anchor_right(AnchorType anchor_right) {
    fbb_.AddElement<uint8_t>(UrlRule::VT_ANCHOR_RIGHT, static_cast<uint8_t>(anchor_right), 0);
  }
  void add_domains_included(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_included) {
    fbb_.AddOffset(UrlRule::VT_DOMAINS_INCLUDED, domains_included);
  }
  void add_domains_excluded(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_excluded) {
    fbb_.AddOffset(UrlRule::VT_DOMAINS_EXCLUDED, domains_excluded);
  }
  void add_url_pattern(flatbuffers::Offset<flatbuffers::String> url_pattern) {
    fbb_.AddOffset(UrlRule::VT_URL_PATTERN, url_pattern);
  }
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(UrlRule::VT_ID, id, 0);
  }
  void add_priority(uint32_t priority) {
    fbb_.AddElement<uint32_t>(UrlRule::VT_PRIORITY, priority, 0);
  }
  UrlRuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UrlRuleBuilder &operator=(const UrlRuleBuilder &);
  flatbuffers::Offset<UrlRule> Finish() {
    const auto end = fbb_.EndTable(start_, 11);
    auto o = flatbuffers::Offset<UrlRule>(end);
    return o;
  }
};

inline flatbuffers::Offset<UrlRule> CreateUrlRule(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t options = 0,
    uint16_t element_types = 8191,
    uint8_t activation_types = 0,
    UrlPatternType url_pattern_type = UrlPatternType_SUBSTRING,
    AnchorType anchor_left = AnchorType_NONE,
    AnchorType anchor_right = AnchorType_NONE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_included = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> domains_excluded = 0,
    flatbuffers::Offset<flatbuffers::String> url_pattern = 0,
    uint32_t id = 0,
    uint32_t priority = 0) {
  UrlRuleBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_id(id);
  builder_.add_url_pattern(url_pattern);
  builder_.add_domains_excluded(domains_excluded);
  builder_.add_domains_included(domains_included);
  builder_.add_element_types(element_types);
  builder_.add_anchor_right(anchor_right);
  builder_.add_anchor_left(anchor_left);
  builder_.add_url_pattern_type(url_pattern_type);
  builder_.add_activation_types(activation_types);
  builder_.add_options(options);
  return builder_.Finish();
}

inline flatbuffers::Offset<UrlRule> CreateUrlRuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t options = 0,
    uint16_t element_types = 8191,
    uint8_t activation_types = 0,
    UrlPatternType url_pattern_type = UrlPatternType_SUBSTRING,
    AnchorType anchor_left = AnchorType_NONE,
    AnchorType anchor_right = AnchorType_NONE,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *domains_included = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *domains_excluded = nullptr,
    const char *url_pattern = nullptr,
    uint32_t id = 0,
    uint32_t priority = 0) {
  return url_pattern_index::flat::CreateUrlRule(
      _fbb,
      options,
      element_types,
      activation_types,
      url_pattern_type,
      anchor_left,
      anchor_right,
      domains_included ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*domains_included) : 0,
      domains_excluded ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*domains_excluded) : 0,
      url_pattern ? _fbb.CreateString(url_pattern) : 0,
      id,
      priority);
}

struct NGramToRules FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NGRAM = 4,
    VT_RULE_LIST = 6
  };
  uint64_t ngram() const {
    return GetField<uint64_t>(VT_NGRAM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UrlRule>> *rule_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UrlRule>> *>(VT_RULE_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_NGRAM) &&
           VerifyOffset(verifier, VT_RULE_LIST) &&
           verifier.Verify(rule_list()) &&
           verifier.VerifyVectorOfTables(rule_list()) &&
           verifier.EndTable();
  }
};

struct NGramToRulesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram(uint64_t ngram) {
    fbb_.AddElement<uint64_t>(NGramToRules::VT_NGRAM, ngram, 0);
  }
  void add_rule_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRule>>> rule_list) {
    fbb_.AddOffset(NGramToRules::VT_RULE_LIST, rule_list);
  }
  NGramToRulesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NGramToRulesBuilder &operator=(const NGramToRulesBuilder &);
  flatbuffers::Offset<NGramToRules> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NGramToRules>(end);
    return o;
  }
};

inline flatbuffers::Offset<NGramToRules> CreateNGramToRules(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ngram = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRule>>> rule_list = 0) {
  NGramToRulesBuilder builder_(_fbb);
  builder_.add_ngram(ngram);
  builder_.add_rule_list(rule_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<NGramToRules> CreateNGramToRulesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ngram = 0,
    const std::vector<flatbuffers::Offset<UrlRule>> *rule_list = nullptr) {
  return url_pattern_index::flat::CreateNGramToRules(
      _fbb,
      ngram,
      rule_list ? _fbb.CreateVector<flatbuffers::Offset<UrlRule>>(*rule_list) : 0);
}

struct UrlPatternIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_N = 4,
    VT_NGRAM_INDEX = 6,
    VT_NGRAM_INDEX_EMPTY_SLOT = 8,
    VT_FALLBACK_RULES = 10
  };
  uint32_t n() const {
    return GetField<uint32_t>(VT_N, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NGramToRules>> *ngram_index() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NGramToRules>> *>(VT_NGRAM_INDEX);
  }
  const NGramToRules *ngram_index_empty_slot() const {
    return GetPointer<const NGramToRules *>(VT_NGRAM_INDEX_EMPTY_SLOT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UrlRule>> *fallback_rules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UrlRule>> *>(VT_FALLBACK_RULES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_N) &&
           VerifyOffset(verifier, VT_NGRAM_INDEX) &&
           verifier.Verify(ngram_index()) &&
           verifier.VerifyVectorOfTables(ngram_index()) &&
           VerifyOffset(verifier, VT_NGRAM_INDEX_EMPTY_SLOT) &&
           verifier.VerifyTable(ngram_index_empty_slot()) &&
           VerifyOffset(verifier, VT_FALLBACK_RULES) &&
           verifier.Verify(fallback_rules()) &&
           verifier.VerifyVectorOfTables(fallback_rules()) &&
           verifier.EndTable();
  }
};

struct UrlPatternIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_n(uint32_t n) {
    fbb_.AddElement<uint32_t>(UrlPatternIndex::VT_N, n, 0);
  }
  void add_ngram_index(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NGramToRules>>> ngram_index) {
    fbb_.AddOffset(UrlPatternIndex::VT_NGRAM_INDEX, ngram_index);
  }
  void add_ngram_index_empty_slot(flatbuffers::Offset<NGramToRules> ngram_index_empty_slot) {
    fbb_.AddOffset(UrlPatternIndex::VT_NGRAM_INDEX_EMPTY_SLOT, ngram_index_empty_slot);
  }
  void add_fallback_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRule>>> fallback_rules) {
    fbb_.AddOffset(UrlPatternIndex::VT_FALLBACK_RULES, fallback_rules);
  }
  UrlPatternIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UrlPatternIndexBuilder &operator=(const UrlPatternIndexBuilder &);
  flatbuffers::Offset<UrlPatternIndex> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<UrlPatternIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<UrlPatternIndex> CreateUrlPatternIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t n = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NGramToRules>>> ngram_index = 0,
    flatbuffers::Offset<NGramToRules> ngram_index_empty_slot = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UrlRule>>> fallback_rules = 0) {
  UrlPatternIndexBuilder builder_(_fbb);
  builder_.add_fallback_rules(fallback_rules);
  builder_.add_ngram_index_empty_slot(ngram_index_empty_slot);
  builder_.add_ngram_index(ngram_index);
  builder_.add_n(n);
  return builder_.Finish();
}

inline flatbuffers::Offset<UrlPatternIndex> CreateUrlPatternIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t n = 0,
    const std::vector<flatbuffers::Offset<NGramToRules>> *ngram_index = nullptr,
    flatbuffers::Offset<NGramToRules> ngram_index_empty_slot = 0,
    const std::vector<flatbuffers::Offset<UrlRule>> *fallback_rules = nullptr) {
  return url_pattern_index::flat::CreateUrlPatternIndex(
      _fbb,
      n,
      ngram_index ? _fbb.CreateVector<flatbuffers::Offset<NGramToRules>>(*ngram_index) : 0,
      ngram_index_empty_slot,
      fallback_rules ? _fbb.CreateVector<flatbuffers::Offset<UrlRule>>(*fallback_rules) : 0);
}

inline const url_pattern_index::flat::UrlPatternIndex *GetUrlPatternIndex(const void *buf) {
  return flatbuffers::GetRoot<url_pattern_index::flat::UrlPatternIndex>(buf);
}

inline bool VerifyUrlPatternIndexBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<url_pattern_index::flat::UrlPatternIndex>(nullptr);
}

inline void FinishUrlPatternIndexBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<url_pattern_index::flat::UrlPatternIndex> root) {
  fbb.Finish(root);
}

}  // namespace flat
}  // namespace url_pattern_index

#endif  // FLATBUFFERS_GENERATED_URLPATTERNINDEX_URL_PATTERN_INDEX_FLAT_H_
